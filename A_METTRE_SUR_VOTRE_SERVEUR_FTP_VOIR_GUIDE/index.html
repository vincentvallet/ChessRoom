<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gestionnaire de Plan de Salles d'Échecs</title>

    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>

    <style>
        /* ... [La plupart du CSS est identique] ... */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            height: 100%;
        }



        /* ... [CSS Mode Player identique] ... */
        body.player-plan-view-mode .sidebar,
        body.player-plan-view-mode .toolbar,
        body.player-plan-view-mode .shortcut-bar,
        body.player-plan-view-mode .zoom-controls,
        body.player-plan-view-mode #sidebarToggle {
            display: none !important;
        }

        body.player-plan-view-mode #playerPlanReturnButton {
            display: block;
        }

        /* =====================================================
            NOUVEAU: Verrouillage complet du Mode Spectateur
        =====================================================
        */

        /* 1. Cache tous les boutons d'action DANS les sections (redondant mais sécurisé) */


        /* =====================================================
            MODE PROJECTEUR (FULL SCREEN)
        ===================================================== */
        body.projector-mode {
            overflow: hidden;
        }

        body.projector-mode .sidebar,
        body.projector-mode .toolbar,
        body.projector-mode .shortcut-bar,
        body.projector-mode .zoom-controls,
        body.projector-mode #sidebarToggle,
        body.projector-mode #saveStatus {
            display: none !important;
        }

        body.projector-mode .container {
            height: 100vh;
            max-width: 100vw;
            margin: 0;
            border-radius: 0;
            box-shadow: none;
            padding: 0;
        }

        body.projector-mode .main-content {
            height: 100vh;
        }

        body.projector-mode .canvas-container {
            background: white;
            /* Fond blanc propre */
        }

        /* Bouton Retour Projecteur */
        #projectorReturnBtn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 9999;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            font-size: 1.2em;
            display: none;
            transition: background 0.3s;
        }

        body.projector-mode #projectorReturnBtn {
            display: block;
        }

        /* --- DARK MODE --- */
        body.dark-mode {
            background-color: #1a1a1a;
            color: #e0e0e0;
        }

        body.dark-mode .sidebar {
            background-color: #2d2d2d;
            border-right-color: #404040;
        }

        body.dark-mode .sidebar-header {
            border-bottom-color: #404040;
        }

        body.dark-mode .sidebar-section-title {
            color: #a0a0a0;
        }

        body.dark-mode .control-group label {
            color: #c0c0c0;
        }

        body.dark-mode input[type="text"],
        body.dark-mode input[type="number"],
        body.dark-mode select {
            background-color: #333;
            color: #fff;
            border-color: #555;
        }

        body.dark-mode .chess-table {
            background-color: #2d2d2d;
            border-color: #404040;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        }

        body.dark-mode .table-header {
            background-color: #333;
            border-bottom-color: #404040;
        }

        body.dark-mode .player-name {
            color: #e0e0e0;
        }

        body.dark-mode .vs {
            color: #888;
        }

        body.dark-mode .modal-content {
            background-color: #2d2d2d;
            color: #e0e0e0;
        }

        body.dark-mode .close {
            color: #aaa;
        }

        body.dark-mode .filter-btn {
            background: #333;
            border-color: #555;
            color: #ddd;
        }

        body.dark-mode .filter-btn.active {
            background: #0056b3;
        }

        /* --- HEARTBEAT --- */
        #connectionStatus {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #ccc;
            /* Unknown */
            z-index: 10000;
            border: 2px solid #fff;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
            transition: background-color 0.3s;
        }

        #connectionStatus.online {
            background-color: #2ecc71;
        }

        #connectionStatus.offline {
            background-color: #e74c3c;
        }

        #connectionStatus.checking {
            background-color: #f1c40f;
        }

        /* --- FILTERS --- */
        .filter-buttons {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .filter-btn {
            padding: 4px 8px;
            font-size: 12px;
            border: 1px solid #ccc;
            background: #f0f0f0;
            cursor: pointer;
            border-radius: 4px;
        }

        .filter-btn.active {
            background: #007bff;
            color: white;
            border-color: #0056b3;
        }

        .table-element.hidden-by-filter {
             display: none !important;
        }

        #projectorReturnBtn:hover {
            background: rgba(0, 0, 0, 0.8);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            width: 100vw;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-size: 14px;
        }

        /* ... [CSS Mode Player identique] ... */
        body.player-plan-view-mode .sidebar,
        body.player-plan-view-mode .toolbar,
        body.player-plan-view-mode .shortcut-bar,
        body.player-plan-view-mode .zoom-controls,
        body.player-plan-view-mode #sidebarToggle {
            display: none !important;
        }

        body.player-plan-view-mode #playerPlanReturnButton {
            display: block;
        }

        /* =====================================================
            NOUVEAU: Verrouillage complet du Mode Spectateur
        =====================================================
        */

        /* 1. Cache tous les boutons d'action DANS les sections */
        .spectator-mode .sidebar-content button,
        .spectator-mode .sidebar-content input[type="file"],
        .spectator-mode .sidebar-content label.file-upload-label,
        .spectator-mode button[onclick="showArbiterPasswordModal()"],
        .spectator-mode button[onclick="showPlayerLoginModal()"] {
            display: none !important;
        }

        /* 2. Cache les boutons de la barre d'outils (sauf Outils de navigation) */
        .spectator-mode .timer-controls,
        .spectator-mode .tool-btn[onclick*="delete"],
        .spectator-mode .tool-btn[onclick*="duplicate"],
        .spectator-mode .tool-btn[onclick*="rotate"],
        .spectator-mode .tool-btn[onclick*="flip"],
        .spectator-mode .tool-btn[onclick*="undo"],
        .spectator-mode .tool-btn[onclick*="redo"],
        .spectator-mode .btn-success[onclick*="startQRScanner"] {
            display: none !important;
        }

        /* 3. Désactive les interactions sur le plan */
        .spectator-mode .table-element,
        .spectator-mode .room-element,
        .spectator-mode .board-container {
            cursor: default !important;
            pointer-events: none !important;
        }

        /* 4. Cache les poignées de modification */
        .spectator-mode .delete-btn,
        .spectator-mode .rotate-btn,
        .spectator-mode .resize-handle,
        .spectator-mode .flip-btn-single,
        .spectator-mode .arbiter-flag,
        .spectator-mode .room-delete-btn,
        .spectator-mode .room-resize-handle {
            display: none !important;
        }

        /* 5. Cache TOUTES les sections de la sidebar */
        .spectator-mode .sidebar-section {
            display: none !important;
        }
        .spectator-mode #liveFollowSection {
            display: block !important;
        }

        /* 6. Ré-affiche UNIQUEMENT les sections autorisées */
        .spectator-mode .sidebar-section:first-child,
        .spectator-mode #saveControlsSection,
        .spectator-mode #playersSection {
            display: block !important;
        }

        /* 7. Cache la barre de raccourcis */
        .spectator-mode .shortcut-bar {
            display: none !important;
        }

        /* =========================================================
           CORRECTION : Forcer l'affichage du Suivi en Spectateur
        ========================================================= */
        
        /* Rendre visibles les boutons et le menu déroulant UNIQUEMENT dans la section Suivi */
        .spectator-mode #liveFollowSection button,
        .spectator-mode #liveFollowSection select {
            display: block !important;
        }

        /* S'assurer que le conteneur de suivi reste visible */
        .spectator-mode #liveFollowSection {
            display: block !important;
        }

        .container {
            width: 100%;
            height: 100%;
            margin: 0;
            background: white;
            border-radius: 0;
            box-shadow: none;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .main-content {
            display: flex;
            flex-direction: row !important;
            flex: 1;
            overflow: hidden;
            position: relative;
            width: 100%;
        }

        .sidebar {
            width: 200px;
            flex-shrink: 0;
            background: #f8f9fa;
            border-right: 2px solid #e9ecef;
            display: flex;
            flex-direction: column;
            overflow-y: hidden;
            transition: width 0.3s ease, padding 0.3s ease;
            position: relative;
            padding: 0;
        }

        .main-content.sidebar-collapsed .sidebar {
            width: 0 !important;
            padding: 0;
            border-right: none;
            overflow: hidden;
        }

        #sidebarToggle {
            position: absolute;
            top: 10px;
            left: 200px;
            width: 28px;
            height: 28px;
            padding: 0;
            font-size: 1.2em;
            z-index: 1001;
            border-radius: 50% 0 0 50%;
            margin-bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: left 0.3s ease;
            transform: translateX(-100%);
        }

        .main-content.sidebar-collapsed #sidebarToggle {
            left: 0px;
            border-radius: 0 50% 50% 0;
            transform: translateX(0);
        }

        /*
        =====================================================
            NOUVEAU SYSTÈME ACCORDÉON
        =====================================================
        */
        .sidebar-section {
            /* MODIFIÉ: Plus de padding/margin, géré par le contenu */
            margin-bottom: 0;
            border-bottom: 2px solid #e9ecef;
            /* min-width: 270px; */
            /* MODIFIÉ: Supprimé ou commenté */
        }

        .sidebar-section:last-child {
            border-bottom: none;
            /* NOUVEAU: Permet à la dernière section de remplir l'espace */
            flex: 1;
            display: flex;
            flex-direction: column;
            /* CORRECTION: Ajouté pour forcer la contrainte de hauteur */
            min-height: 0;
        }

        .sidebar-section h3 {
            color: #2c3e50;
            font-size: 1.05em;
            display: flex;
            align-items: center;
            gap: 8px;
            /* NOUVEAU: Cliquable */
            padding: 15px;
            margin-bottom: 0;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .sidebar-section h3:hover {
            background-color: #e9ecef;
        }

        .sidebar-section h3.active {
            background-color: #667eea;
            color: white;
        }

        /* NOUVEAU: Conteneur du contenu de l'accordéon */
        .sidebar-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
            padding: 0 15px;
            /* Padding latéral */
            background: #ffffff;
        }

        .sidebar-content.expanded {
            /* NOUVEAU: Hauteur pour le contenu */
            max-height: 70vh;
            /* Hauteur max pour le contenu */
            overflow-y: auto;
            /* Scroll si besoin DANS la section */
            padding: 15px;
            /* Padding complet */
        }

        .sidebar-section:last-child .sidebar-content.expanded {
            /* NOUVEAU: Permet au dernier de s'étendre */
            max-height: none;
            flex: 1;
        }

        /* Fin NOUVEAU SYSTÈME ACCORDÉON */


        .control-group {
            margin-bottom: 12px;
        }

        /* ... [Reste du CSS identique] ... */

        .control-group label {
            display: block;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 4px;
            font-size: 0.9em;
        }

        input[type="number"],
        input[type="text"],
        input[type="file"],
        select,
        input[type="password"] {
            width: 100%;
            padding: 6px 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 0.95em;
            transition: border-color 0.3s;
            background: white;
        }

        .toolbar input[type="number"] {
            width: 60px;
            padding: 4px 8px;
            font-size: 0.9em;
            text-align: center;
        }

        input:focus,
        select:focus {
            outline: none;
            border-color: #667eea;
        }

        button {
            width: 100%;
            padding: 8px 12px;
            font-size: 0.9em;
            font-weight: 600;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 6px;
        }

        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-primary,
        .btn-success,
        .btn-danger,
        .btn-secondary,
        .btn-info {
            color: white;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .btn-success {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        }

        .btn-danger {
            background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #6c757d 0%, #5a6268 100%);
        }

        .btn-info {
            background: linear-gradient(135deg, #17a2b8 0%, #138496 100%);
        }

        .btn-small {
            width: auto;
            padding: 4px 8px;
            font-size: 0.85em;
            margin-left: 5px;
        }

        .stats {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
        }

        .stat-item {
            background: white;
            padding: 8px;
            border-radius: 6px;
            border: 2px solid #e9ecef;
        }

        .stat-label {
            color: #6c757d;
            font-size: 0.85em;
            font-weight: 600;
        }

        .stat-value {
            color: #2c3e50;
            font-weight: 700;
            font-size: 1.3em;
        }

        .workspace {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #ecf0f1;
            position: relative;
            overflow: hidden;
            height: 100%;
        }

        .toolbar {
            background: white;
            padding: 4px 10px;
            /* MODIFIÉ: 10px est devenu 6px */
            border-bottom: 2px solid #e9ecef;
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        .toolbar button {
            width: auto;
            padding: 3px 6px;
            font-size: 0.8em;
            margin: 0;
        }

        .timer-controls {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-left: 15px;
            padding-left: 15px;
            border-left: 2px solid #e9ecef;
        }

        #roundTimer {
            font-size: 1.1em;
            /* MODIFIÉ: 1.3em est devenu 1.1em */
            font-weight: 700;
            color: #2c3e50;
            background: #f8f9fa;
            padding: 3px 6px;
            /* MODIFIÉ: 4px 10px est devenu 3px 8px */
            border-radius: 6px;
            min-width: 70px;
            text-align: center;
        }

        #roundTimer.timer-countdown {
            color: #1565c0;
        }

        #roundTimer.timer-elapsed {
            color: #c62828;
        }

        #roundTimer.timer-flash {
            animation: flash 1s infinite;
        }

        @keyframes flash {

            0%,
            100% {
                background-color: #69f0ae;
            }

            50% {
                background-color: #f8f9fa;
            }
        }

        .tool-btn {
            background: #e9ecef;
            color: #2c3e50;
        }

        .toolbar .tool-btn[onclick="undo()"],
        .toolbar .tool-btn[onclick="redo()"] {
            font-size: 1.1em;
            padding: 6px 8px;
        }

        .tool-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            overflow: auto;
            width: 100%;
            height: 100%;
            background:
                linear-gradient(90deg, #ddd 1px, transparent 1px),
                linear-gradient(#ddd 1px, transparent 1px);
            background-size: 50px 50px;
        }

        .canvas {
            position: relative;
            width: 3000px;
            height: 2000px;
            cursor: default;
            transform-origin: 0 0;
        }

        .canvas.move-mode {
            cursor: grab;
        }

        .canvas.move-mode:active {
            cursor: grabbing;
        }

        .table-element {
            position: absolute;
            background: white;
            border: 3px solid #2c3e50;
            border-radius: 8px;
            padding: 8px;
            cursor: move;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            transition: box-shadow 0.3s, transform 0.3s;
            min-width: 150px;
            user-select: none;
            transform-origin: top left;
            z-index: 10;
        }

        .table-element:hover {
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
            z-index: 100;
        }

        .table-element.selected {
            border-color: #667eea;
            box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.5);
            z-index: 101;
        }

        .table-element.has-pairing {
            background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
            border-color: #4caf50;
        }

        /* STYLE SURBRILLANCE JOUEUR (JAUNE PERMANENT) */
        .table-element.highlight-player {
            background-color: #fff176 !important; /* Jaune vif fond */
            border: 4px solid #ff6f00 !important; /* Bordure Orange/Rouge */
            box-shadow: 0 0 20px rgba(255, 111, 0, 0.6) !important; /* Halo lumineux */
            z-index: 9999 !important; /* Toujours au-dessus des autres */
            transform: scale(1.05); /* Légèrement grossi */
            transition: all 0.3s ease;
        }
        
        /* En mode sombre, on adapte pour que ça ne pique pas les yeux */
        body.dark-mode .table-element.highlight-player {
            background-color: #fdd835 !important;
            border-color: #ff6f00 !important;
            color: #000 !important; /* Force le texte en noir pour lisibilité */
        }
        body.dark-mode .table-element.highlight-player .player-name {
            color: #000 !important;
        }

        @keyframes pulse-highlight {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }
        }

        .table-content {
            transform-origin: center center;
        }

        .table-element.rotate-0 {
            transform: rotate(0deg);
        }

        .table-element.rotate-90 {
            transform: rotate(90deg);
        }

        .table-element.rotate-180 {
            transform: rotate(180deg);
        }

        .table-element.rotate-270 {
            transform: rotate(270deg);
        }

        .board-container {
            position: relative;
            padding: 4px;
            flex: 1;
            border-right: 1px solid #ddd;
            border-bottom: none;
            min-width: 140px;
            transition: background-color 0.3s, border-color 0.3s;
        }

        .board-container:last-child {
            border-right: none;
            border-bottom: none;
        }

        .board-container.board-scored {
            background-color: #ffebee;
            border-color: #c62828;
        }

        .canvas.moveboard-mode .board-container {
            cursor: grab;
        }

        .canvas.moveboard-mode .board-container:active {
            cursor: grabbing;
        }

        .canvas.moveboard-mode .board-container.over {
            background-color: rgba(102, 126, 234, 0.2);
        }

        body.player-plan-view-mode .board-container.has-players {
            cursor: pointer;
        }

        body.player-plan-view-mode .board-container.has-players:hover {
            background-color: rgba(102, 126, 234, 0.2);
        }


        .board-number {
            font-size: 1.4em;
            font-weight: 700;
            color: #667eea;
            margin-bottom: 5px;
            text-align: center;
        }

        .table-element.has-pairing .board-number {
            color: #2e7d32;
        }

        .table-content-inner {
            display: flex;
            width: 100%;
        }

        .player-comment {
            font-size: 0.9em;
            font-style: italic;
            color: #b71c1c;
            padding: 2px 4px;
            background: #fff9c4;
            border-radius: 3px;
            text-align: center;
            margin-bottom: 3px;
            white-space: normal;
            word-wrap: break-word;
        }

        .player {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 6px;
            font-size: 0.85em;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 5px;
            margin-top: 5px;
            overflow: hidden;
            min-height: 40px;
        }

        .player-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid #2c3e50;
            flex-shrink: 0;
        }

        .player-color.white {
            background: white;
        }

        .player-color.black {
            background: #2c3e50;
        }

        .player-info {
            flex: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
        }

        .player-name {
            font-weight: 400;
            color: #2c3e50;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.2;
            cursor: pointer;
        }

        .player-name:hover {
            color: #667eea;
        }

        .player-name .lastname {
            font-weight: 700;
            text-transform: uppercase;
        }

        .player-elo {
            font-size: 0.9em;
            color: #6c757d;
            white-space: nowrap;
        }

        .player-score {
            font-weight: 700;
            font-size: 1.1em;
            padding: 4px 8px;
            cursor: pointer;
            border-radius: 4px;
            margin-left: auto;
            flex-shrink: 0;
        }

        .player-score:hover {
            background: #e0e0e0;
        }

        .table-element.expanded .player-name {
            white-space: normal;
            overflow: visible;
            text-overflow: clip;
        }

        .delete-btn,
        .rotate-btn {
            position: absolute;
            width: 24px;
            height: 24px;
            color: white;
            border: 2px solid white;
            border-radius: 50%;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            z-index: 5;
        }

        .delete-btn {
            background: #f44336;
            top: -10px;
            right: -10px;
        }

        .rotate-btn {
            background: #2196f3;
            bottom: -10px;
            right: -10px;
            font-size: 12px;
        }

        .arbiter-flag {
            position: absolute;
            width: 24px;
            height: 24px;
            color: #424242;
            border: 2px solid white;
            background: #eeeeee;
            border-radius: 50%;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            z-index: 5;
            top: -10px;
            left: -10px;
        }

        .arbiter-flag.flag-red {
            background: #f44336;
            color: white;
        }

        .arbiter-flag.flag-yellow {
            background: #ffeb3b;
            color: #424242;
        }

        .arbiter-flag.flag-green {
            background: #4caf50;
            color: white;
        }

        .arbiter-flag.flag-none {
            display: none;
        }

        .table-element.selected .arbiter-flag {
            display: flex;
        }

        .table-element .arbiter-flag:not(.flag-none) {
            display: flex;
        }

        .table-element.selected .delete-btn,
        .table-element.selected .rotate-btn {
            display: flex;
        }

        .flip-btn-single {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 20px;
            height: 20px;
            background: #ff9800;
            color: white;
            border: 1px solid white;
            border-radius: 50%;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            padding: 0;
            margin: 0;
            z-index: 5;
        }

        .table-element.selected .flip-btn-single {
            display: flex;
        }

        .flip-btn-single:hover {
            background: #f57c00;
        }

        .resize-handle {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 24px;
            height: 30px;
            background: #2196f3;
            color: white;
            border: 2px solid white;
            border-radius: 5px;
            cursor: ew-resize;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            z-index: 102;
        }

        .resize-handle.handle-left {
            left: -12px;
        }

        .resize-handle.handle-right {
            right: -12px;
        }

        .table-element.rotate-90 .resize-handle,
        .table-element.rotate-270 .resize-handle {
            cursor: ns-resize;
        }

        .table-element.selected .resize-handle {
            display: flex;
        }

        .selection-box {
            position: absolute;
            border: 2px dashed #667eea;
            background: rgba(102, 126, 234, 0.1);
            pointer-events: none;
            z-index: 9999;
        }

        .zoom-controls {
            position: absolute;
            bottom: 35px;
            right: 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            padding: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 1000;
        }

        .zoom-btn {
            width: 32px;
            height: 32px;
            padding: 0;
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1em;
            flex-shrink: 0;
        }

        .zoom-slider {
            width: 120px;
            margin: 0 5px;
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: #ddd;
            outline: none;
            border-radius: 5px;
        }

        .zoom-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #667eea;
            cursor: pointer;
            border-radius: 50%;
        }

        .zoom-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #667eea;
            cursor: pointer;
            border-radius: 50%;
        }

        .file-upload-label {
            width: 100%;
            padding: 8px 14px;
            font-size: 0.9em;
            font-weight: 600;
            border-radius: 6px;
            cursor: pointer;
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
            display: block;
            text-align: center;
            margin-bottom: 6px;
        }

        input[type="file"] {
            display: none;
        }

        #ghost {
            background: white;
            border: 2px dashed #667eea;
            padding: 10px;
            border-radius: 8px;
            pointer-events: none;
        }

        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            font-weight: bold;
            z-index: 9999;
            flex-direction: column;
            gap: 20px;
        }

        #loadingOverlay::before {
            content: '⏳';
            font-size: 3em;
            animation: spin 1.5s linear infinite;
        }

        @keyframes spin {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        /* Modale de Score */
        #scoreModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: none;
            align-items: center;
            justify-content: center;
            /* MODIFICATION Z-INDEX */
            z-index: 10002;
        }

        #scoreModalContent {
            background: white;
            padding: 20px 25px;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            width: 300px;
        }

        #scoreModalContent h4 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        #scoreModalContent p {
            font-size: 0.95em;
            margin-bottom: 10px;
        }

        #scoreModalSelect {
            width: 100%;
            font-size: 1.1em;
            padding: 8px 10px;
            margin-bottom: 20px;
        }

        .score-modal-buttons {
            display: flex;
            gap: 10px;
        }

        .score-modal-buttons button {
            margin-bottom: 0;
        }

        /* Barre d'aide Raccourcis */
        .shortcut-bar {
            background: #4a4a4a;
            color: #f0f0f0;
            padding: 4px 15px;
            font-size: 0.8em;
            text-align: center;
            z-index: 1000;
            position: absolute;
            bottom: 0;
            width: 100%;
            border-top: 1px solid #666;
        }

        .shortcut-bar span {
            margin-left: 50px;
            margin-right: 5px;
            color: #fafafa;
            background: #616161;
            padding: 2px 5px;
            border-radius: 4px;
        }

        /*
        =====================================================
            STYLES CSS QR AJOUTÉS
        =====================================================
        */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: none;
            align-items: center;
            justify-content: center;
            /* MODIFICATION Z-INDEX */
            z-index: 10002;
            /* Mettre au-dessus de playerHomeModal */
        }

        .modal-content {
            background: white;
            padding: 20px 25px;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            width: 90%;
            max-width: 500px;
        }

        .modal-content h2,
        .modal-content h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            text-align: center;
        }

        /* Styles pour la notification */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 16px 24px;
            border-radius: 10px;
            color: white;
            font-weight: 600;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            /* MODIFICATION Z-INDEX */
            z-index: 10003;
            /* Au-dessus de tout */
            opacity: 0;
            transform: translateX(400px);
            transition: all 0.3s;
        }

        .notification.show {
            opacity: 1;
            transform: translateX(0);
        }

        .notification.success {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        }

        .notification.error {
            background: linear-gradient(135deg, #ee0979 0%, #ff6a00 100%);
        }

        .notification.info {
            background: linear-gradient(135deg, #17a2b8 0%, #138496 100%);
        }

        .info-box {
            background: #e7f3ff;
            border-left: 4px solid #2196F3;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }

        /*
        =====================================================
            STYLES CSS SALLES / MURS (MODIFIÉS)
        =====================================================
        */
        .room-element {
            position: absolute;
            background: rgba(102, 126, 234, 0.05);
            border: 3px dashed #667eea;
            border-radius: 10px;
            min-width: 200px;
            min-height: 200px;
            cursor: move;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            user-select: none;
            padding-top: 30px;
            z-index: 1;
        }

        .room-element.selected {
            border-style: solid;
            border-color: #764ba2;
            background: rgba(102, 126, 234, 0.1);
            z-index: 5;
        }

        .room-title {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            background: #667eea;
            color: white;
            padding: 4px 10px;
            font-weight: 600;
            font-size: 0.9em;
            border-radius: 8px 8px 0 0;
            text-align: center;
            cursor: pointer;
        }

        .room-delete-btn {
            position: absolute;
            width: 24px;
            height: 24px;
            color: white;
            border: 2px solid white;
            border-radius: 50%;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            z-index: 6;
            background: #f44336;
            top: -10px;
            right: -10px;
        }

        .room-element.selected .room-delete-btn {
            display: flex;
        }

        .room-resize-handle {
            position: absolute;
            width: 15px;
            height: 15px;
            background: #667eea;
            border: 2px solid white;
            border-radius: 50%;
            z-index: 6;
        }

        .room-resize-handle.br {
            bottom: -8px;
            right: -8px;
            cursor: se-resize;
        }

        .room-resize-handle.bl {
            bottom: -8px;
            left: -8px;
            cursor: sw-resize;
        }

        .room-resize-handle.tr {
            top: -8px;
            right: -8px;
            cursor: ne-resize;
        }

        .room-resize-handle.tl {
            top: -8px;
            left: -8px;
            cursor: nw-resize;
        }

        .room-element:not(.selected) .room-resize-handle {
            display: none;
        }

        #playerPlanReturnButton {
            position: fixed;
            /* MODIFIÉ: en bas au centre et plus petit */
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10002;
            /* MODIFIÉ: padding et font-size */
            padding: 8px 16px;
            font-size: 0.9em;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
            display: none;
            /* Caché par défaut */
            width: auto;
            /* NOUVEAU */
            margin-bottom: 0;
            /* NOUVEAU */
        }

        body.player-plan-view-mode .sidebar,
        body.player-plan-view-mode .toolbar,
        body.player-plan-view-mode .shortcut-bar,
        body.player-plan-view-mode .zoom-controls,
        body.player-plan-view-mode #sidebarToggle {
            display: none !important;
        }

        body.player-plan-view-mode #playerPlanReturnButton {
            display: block;
        }

        /* NOUVEAU: Réduire la taille des boutons dans la sidebar */
        .sidebar-content button {
            font-size: 0.8em;
            /* Plus petit pour s'adapter à 200px */
            padding: 6px 8px;
            /* Ajuster le padding */
        }

        /* NOUVEAU: Styles pour le décompte plein écran */
        #bigTimerOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;

            /* Caché par défaut */
            display: none;

            /* Centrage */
            align-items: center;
            justify-content: center;

            /* Au-dessus du plan, mais sous les modales */
            z-index: 10000;

            /* TRÈS IMPORTANT: Laisse passer les clics ! */
            pointer-events: none;
        }

        #bigTimerDisplay {
            font-size: 15vw;
            /* Taille énorme qui s'adapte à l'écran */
            font-weight: bold;
            color: white;

            /* Ombre pour la lisibilité sur tous les fonds */
            text-shadow: 0 0 25px rgba(0, 0, 0, 0.8), 0 0 10px rgba(0, 0, 0, 0.5);
        }

        /* AJOUT: Cacher les sélecteurs d'outils en mode spectateur */
        .spectator-mode #selectTool,
        .spectator-mode #multiselectTool,
        .spectator-mode #panTool,
        .spectator-mode #moveboardTool {
            display: none !important;
        }

        /* AJOUT: Cacher les "..." des scores non saisis en mode spectateur */
        .spectator-mode .board-container:not(.board-scored) .player-score {
            visibility: hidden;
            /* On cache juste le texte, pas l'espace */
        }

        /* NOUVEAU: Styles pour l'interrupteur (toggle switch) */
        .switch-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-top: 12px;
            margin-bottom: 6px;
            /* Maintient l'espacement */
        }

        .switch-container span {
            font-weight: bold;
            color: #2c3e50;
            font-size: 0.9em;
            /* Correspond à .control-group label */
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 54px;
            /* Taille réduite */
            height: 28px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 28px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked+.slider {
            background-color: #667eea;
            /* Couleur Arbitre */
        }

        input:checked+.slider:before {
            transform: translateX(26px);
        }

        /* --- DARK MODE IMPROVEMENTS --- */
        body.dark-mode {
            background-color: #2a2a2a;
            color: #e0e0e0;
        }

        /* Fix Plan Background */
        body.dark-mode .canvas-container,
        body.dark-mode #canvasContainer {
            background-color: #2a2a2a !important;
            /* Dark background for the plan */
        }

        /* Fix Sidebar Background */
        body.dark-mode .sidebar {
            background-color: #333333;
            border-right-color: #555555;
        }

        /* Fix Sidebar Section Titles */
        body.dark-mode .sidebar-section h3 {
            color: #ffffff !important;
            /* Bright white for section titles */
            font-weight: 600;
        }

        /* Fix Text Contrast for Player Names */
        body.dark-mode .player-name {
            color: #1a1a1a !important;
            /* Dark text on light tables */
            font-weight: 600;
        }

        body.dark-mode .player-elo {
            color: #333333 !important;
            /* Dark grey for ELO */
        }

        body.dark-mode .sidebar-section-title {
            color: #ffffff;
        }

        /* Fix Table Color (Light Beige/Cream) */
        body.dark-mode .table-element {
            background-color: #d4c5b0 !important;
            /* Light beige for better contrast */
            border-color: #8d7a5f;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.6);
        }

        body.dark-mode .board-container {
            background-color: #d4c5b0 !important;
        }

        body.dark-mode .table-header {
            background-color: #8d7a5f !important;
            /* Darker brown header */
            border-bottom-color: #6d5a3f;
            color: #ffffff;
        }

        body.dark-mode .board-number {
            color: #1a1a1a !important;
            /* Dark board numbers */
        }

        /* Fix Inputs */
        body.dark-mode input,
        body.dark-mode select,
        body.dark-mode textarea {
            background-color: #424242;
            color: #fff;
            border: 1px solid #616161;
        }

        /* Fix Modals */
        body.dark-mode .modal-content {
            background-color: #333;
            color: #fff;
            border: 1px solid #555;
        }

        body.dark-mode .close {
            color: #fff;
        }

        /* Fix Stats */
        body.dark-mode .stat-item {
            background-color: #424242;
            border-color: #555;
        }

        body.dark-mode .stat-label {
            color: #bbb;
        }

        body.dark-mode .stat-value {
            color: #fff;
        }

        /* NUCLEAR RESET */
        html,
        body {
            height: 100% !important;
            width: 100% !important;
            margin: 0 !important;
            padding: 0 !important;
            overflow: hidden !important;
        }

        .container {
            height: 100% !important;
            width: 100% !important;
            margin: 0 !important;
            padding: 0 !important;
        }

        /* =====================================================
        CORRECTION : Mode Sombre pour les tables terminées
        ===================================================== */
        body.dark-mode .board-container.board-scored {
            background-color: #4a1a1a !important; /* Rouge foncé pour le fond */
            border-color: #ff5252 !important;     /* Rouge vif pour la bordure */
        }

        body.dark-mode .board-container.board-scored .player-name {
            color: #ffdcdc !important; /* Texte clair légèrement rosé */
        }

        body.dark-mode .board-container.board-scored .board-number {
            color: #ff8a80 !important; /* Numéro d'échiquier rouge clair */
        }
        /* --- CORRECTIONS MODE SPECTATEUR --- */

        /* 1. Afficher la section des Rondes */
        .spectator-mode #roundsSection {
            display: block !important;
        }

        /* 2. Mais cacher les boutons d'ajout/suppression dedans (Lecture seule) */
        .spectator-mode #roundsSection button,
        .spectator-mode #roundsSection hr {
            display: none !important;
        }

        /* 3. Désactiver le menu déroulant des rondes pour qu'il soit juste informatif */
        .spectator-mode #roundSelector {
            pointer-events: none;
            background-color: #e9ecef;
            color: #6c757d;
        }

        /* =====================================================
       STYLES POPUP INFO JOUEUR (CORRIGÉS & RÉDUITS)
    ===================================================== */
    #playerTableInfoModal {
        display: none; 
        position: fixed;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        width: 90%; max-width: 450px; /* Plus étroit */
        background: rgba(255, 255, 255, 0.98); /* Fond blanc opaque */
        border-radius: 12px;
        padding: 25px 20px;
        text-align: center;
        box-shadow: 0 15px 50px rgba(0,0,0,0.5);
        z-index: 10005; 
        border: 3px solid #667eea;
        pointer-events: auto; /* Clics activés */
    }

    /* Bouton Fermer */
    #closePlayerTableInfoBtn {
        position: absolute; top: 10px; right: 10px;
        background: #eb3349; color: white;
        border: none; border-radius: 50%;
        width: 30px; height: 30px;
        font-size: 1.2em; cursor: pointer;
        display: flex; align-items: center; justify-content: center;
    }

    /* Nom du joueur suivi */
    .info-name-container {
        font-size: 1.6em; /* Était 3em -> Réduit de moitié */
        margin-bottom: 10px;
        font-weight: 800;
        color: #2c3e50;
        word-wrap: break-word;
        line-height: 1.2;
    }

    /* "Table X" */
    .info-table-container {
        font-size: 1.4em; /* Était 2.5em */
        margin-bottom: 15px;
        color: #34495e;
    }
    #playerTableInfoTable {
        color: #e74c3c; font-weight: bold; font-size: 1.2em;
    }

    /* Bloc Adversaire */
    .info-opponent-block {
        padding: 15px;
        background: #f8f9fa;
        border-radius: 8px;
        border: 1px solid #e9ecef;
    }

    /* Couleur (Blancs/Noirs) */
    .info-color {
        font-size: 1.2em; font-weight: bold; margin-bottom: 5px;
    }

    .info-vs {
        font-size: 0.9em; color: #7f8c8d; font-style: italic; margin-bottom: 5px;
    }

    /* Nom de l'adversaire */
    .info-opponent-name {
        font-size: 1.3em; /* Était 2em -> Réduit */
        font-weight: bold;
        color: #2c3e50;
        word-wrap: break-word; /* Coupe les noms très longs */
    }
    </style>
</head>

<body>
    <div class="container">
        <!-- HEARTBEAT INDICATOR -->
        <div id="connectionStatus" title="Statut Connexion"></div>
        <button id="projectorReturnBtn" onclick="toggleProjectorMode()">↩ Retour</button>
        <div class="main-content">
            <button id="sidebarToggle" onclick="toggleSidebar()" class="btn-secondary"
                title="Masquer/Afficher le volet">«</button>

            <div class="sidebar">

                <div class="sidebar-section" id="liveFollowSection">
                    <h3 onclick="toggleAccordion(this); setTimeout(updateSpectatorPlayerList, 100);" style="background: #e8f5e9; color: #2e7d32; cursor: pointer;">
                        🕵️ Suivi (Live)
                    </h3>
                    
                    <div class="sidebar-content expanded">
                        <div style="background: #e8f5e9; color: #2e7d32; padding: 5px 10px; font-weight: bold; text-align: center; font-size: 0.9em; border-bottom: 1px solid #c8e6c9; margin-bottom: 10px; border-radius: 4px;">
                            En cours : <span id="spectatorRoundDisplay">--</span>
                        </div>

                        <div id="playerSelectContainer">
                            <label style="font-weight: bold; font-size: 0.9em; color: #555;">Joueur à suivre ?</label>
                            <select id="spectatorPlayerSelect" style="width: 100%; padding: 8px; margin-top: 5px; font-size: 1em; border: 2px solid #2e7d32; background: white;">
                                <option value="">-- Charger la liste --</option>
                            </select>

                            <button class="btn-success" style="margin-top: 10px; width: 100%; font-weight: bold;" onclick="startAutoWatchFromList()">
                                ▶️ Activer le Suivi
                            </button>
                        </div>

                        <div id="playerTrackingContainer" style="display: none; text-align: center;">
                            <div style="background: #2e7d32; color: white; padding: 8px; border-radius: 5px; margin-bottom: 10px;">
                                Suivi de : <strong id="trackingPlayerName" style="font-size: 1.1em;">...</strong>
                            </div>

                            <div id="trackingLiveInfo" style="background: white; border: 2px solid #667eea; padding: 10px; border-radius: 5px; margin-bottom: 10px; min-height: 60px; display: flex; flex-direction: column; justify-content: center;">
                                <span style="font-size: 1.2em; font-weight: bold; color: #666;">⏳ En attente...</span>
                            </div>

                            <button class="btn-danger" style="width: 100%; font-size: 0.9em;" onclick="stopAutoWatch()">
                                ⏹️ Arrêter le suivi
                            </button>
                        </div>
                    </div>
                </div>

                <div class="sidebar-section"> <h3 onclick="toggleAccordion(this)">📊 Statistiques</h3>
                    <div class="sidebar-content">
                        <div class="stats">
                            <div class="stat-item">
                                <div class="stat-label">Total</div>
                                <div class="stat-value" id="totalBoards">0</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Échiquiers</div>
                                <div class="stat-value" id="pairedBoards">0</div>
                            </div>

                            <div class="stat-item" style="background-color: #fff3cd; border-color: #ffeeba;">
                                <div class="stat-label" style="color: #856404;">Restants</div>
                                <div class="stat-value" id="remainingBoards" style="color: #856404;">0</div>
                            </div>

                            <div class="stat-item">
                                <div class="stat-label">Joueurs</div>
                                <div class="stat-value" id="totalPlayers">0</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="sidebar-section" id="saveControlsSection">
                        <h3 onclick="toggleAccordion(this)">💾 Mode</h3>
                    <div class="sidebar-content">

                        <div class="switch-container">
                            <span>Mode <strong id="modeSwitchLabel">Arbitre</strong></span>
                            <label class="switch">
                                <input type="checkbox" id="modeSwitch">
                                <span class="slider"></span>
                            </label>
                        </div>

                        <div class="control-group">
                            <label for="saveStrategySelector" style="font-weight: bold;">Sauvegarde :</label>
                            <select id="saveStrategySelector">
                                <option value="server_only" selected>☁️ Serveur</option>
                                <option value="local_only">💾 Local</option>
                            </select>
                        </div>

                        <button id="btnShowHistory" class="btn-secondary" style="margin-top: 8px;">
                            📂 Historique Serveur
                        </button>

                        <button class="btn-info" onclick="showArbiterPasswordModal()">🔐 Changer Mot de
                            Passe</button>
                        <button class="btn-success" onclick="showPlayerLoginModal()">🧑‍🤝‍🧑 Mode Saisie
                            Joueurs</button>

                        <div id="saveStatus"
                            style="margin-top: 10px; padding: 8px; border-radius: 4px; font-size: 0.8em; display: none; word-wrap: break-word;">
                        </div>
                    </div>
                </div>

                <div class="sidebar-section" id="playersSection">
                    <h3 onclick="toggleAccordion(this)">🔍 Joueurs</h3>
                    <div class="sidebar-content">
                        <div class="control-group">
                            <label for="searchInput">Chercher échiquier/joueur :</label>
                            <input type="text" id="searchInput" placeholder="Nom ou numéro d'échiquier..."
                                oninput="searchTables()" list="search-suggestions">
                            <datalist id="search-suggestions"></datalist>
                        </div>
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3 onclick="toggleAccordion(this)">⛳️ Rondes</h3>
                    <div class="sidebar-content">
                        <div class="control-group">
                            <label for="roundSelector">Ronde Actuelle :</label>
                            <select id="roundSelector" onchange="switchRound(this.value)"></select>
                        </div>
                        <button class="btn-primary" onclick="addNewRound()">+ Nouvelle Ronde</button>
                        <button class="btn-secondary" onclick="cloneRoundLayout()">+ Cloner la dispo</button>

                        <button class="btn-danger" style="margin-top: 5px;" onclick="deleteCurrentRound()">-
                            Supprimer
                            la Ronde</button>

                        <hr style="margin: 10px 0; border: 1px solid #e9ecef;">

                        <button class="btn-danger" onclick="createNewTournament()">⚠️ Nouveau Tournoi</button>
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3 onclick="toggleAccordion(this)">➕ Disposition</h3>
                    <div class="sidebar-content">

                        <div class="control-group">
                            <label for="boardsPerTable">Échiquiers par table physique :</label>
                            <input type="number" id="boardsPerTable" min="1" max="10" value="1">
                        </div>
                        <div class="control-group">
                            <label for="physicalTablesPerRow">Tables par rangée :</label>
                            <input type="number" id="physicalTablesPerRow" min="1" max="20" value="10">
                        </div>
                        <div class="control-group">
                            <label for="tableLength">Taille des tables :</label>
                            <select id="tableLength">
                                <option value="140">Petite</option>
                                <option value="180" selected>Moyenne</option>
                                <option value="220">Grande</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label for="startCorner">Position de départ :</label>
                            <select id="startCorner">
                                <option value="tl">En haut à gauche</option>
                                <option value="tr">En haut à droite</option>
                                <option value="bl">En bas à gauche</option>
                                <option value="br">En bas à droite</option>
                            </select>
                        </div>
                        <button class="btn-secondary" onclick="autoArrangeTables()">📐 Réorganiser le plan</button>
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3 onclick="toggleAccordion(this)">🏛️ Salles</h3>
                    <div class="sidebar-content">
                        <div class="control-group">
                            <label for="roomNameInput">Nom de la salle/zone :</label>
                            <input type="text" id="roomNameInput" placeholder="Ex: Salle A, Zone Calme...">
                        </div>
                        <button class="btn-info" onclick="addRoom()">+ Ajouter une Salle/Mur</button>
                    </div>
                </div>
                <div class="sidebar-section">
                    <h3 onclick="toggleAccordion(this)">🎮 Appariements</h3>
                    <div class="sidebar-content">
                        <label for="pairingFileInput" class="file-upload-label">📁 Charger</label>
                        <input type="file" id="pairingFileInput" accept=".html,.htm" onchange="loadPapiFile(event)">

                        <hr style="margin: 10px 0; border: 1px solid #e9ecef;">

                        <div class="control-group">
                            <label for="boardCount">Échiquiers à créer :</label>
                            <input type="number" id="boardCount" min="1" max="2000" value="10">
                        </div>
                        <button class="btn-primary" onclick="addBoards()">Ajouter</button>

                        <hr style="margin: 10px 0; border: 1px solid #e9ecef;">

                        <button class="btn-danger" onclick="clearPairings()">Effacer</button>
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3 onclick="toggleAccordion(this)">📠 QR-codes</h3>
                    <div class="sidebar-content">
                        <div class="control-group">
                            <label for="qrNumTables">Nombre d'échiquiers à générer :</label>
                            <input type="number" id="qrNumTables" min="1" max="2000" value="50">
                        </div>
                        <button class="btn-info" onclick="generateQRFiches()">🖨️ Générer Fiches QR
                            Résultats</button>
                        <button class="btn-success" onclick="generatePlayerQRCodes()" style="margin-top: 10px;">🎫
                            Générer QR-codes Joueurs</button>
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3 onclick="toggleAccordion(this)">🎛️ Actions</h3>
                    <div class="sidebar-content">
                        
                        <button class="tool-btn" onclick="toggleProjectorMode()">📽️ Mode Projecteur</button>
                        <button class="tool-btn" onclick="toggleDarkMode()">🌙 Mode Sombre</button>

                        <div style="margin-top: 15px; border-top: 1px solid #ddd; padding-top: 10px; background: #fdfaff; border-radius: 5px; padding: 10px;">
                            <button id="btnSubscribeNotif" class="btn-info" style="background: #6f42c1; border: none; width: 100%;" onclick="setupGeneralNotification()">
                                🔔 M'avertir (Nouvelle Ronde)
                            </button>
                            <div id="notifStatus" style="display:none; font-size: 0.85em; margin-top: 5px; padding: 5px; border-radius: 4px; background: #e8f5e9; color: #2e7d32;"></div>
                        </div>

                        <div style="margin-top: 10px; border-top: 1px solid #eee; padding-top: 10px;">
                            <label style="font-size: 12px; font-weight: bold; display: block; margin-bottom: 5px;">Filtres Tables :</label>
                            <div class="filter-buttons">
                                <button id="filterBtnAll" class="filter-btn active" onclick="filterTables('all')">Toutes</button>
                                <button id="filterBtnPlaying" class="filter-btn" onclick="filterTables('playing')">En cours</button>
                                <button id="filterBtnFinished" class="filter-btn" onclick="filterTables('finished')">Terminées</button>
                            </div>
                        </div>

                        <hr style="margin: 10px 0; border: 1px solid #e9ecef;">

                        <button class="btn-info" onclick="exportToPDF()">📄 Résultats (PDF)</button>
                        <button class="btn-secondary" onclick="exportToTRF()" style="margin-top: 5px;">🌍 Export TRF (FIDE)</button>
                        
                        <div class="control-group" style="margin-top: 10px; margin-bottom: 5px;">
                            <label for="pdfOrientation" style="font-size: 0.9em;">Orientation Plan :</label>
                            <select id="pdfOrientation" style="padding: 4px 8px; font-size: 0.9em;">
                                <option value="l">Paysage</option>
                                <option value="p">Portrait</option>
                            </select>
                        </div>
                        <button class="btn-info" id="exportVisualPdfBtn" onclick="exportVisualPDF()">🖨️ Imprimer le Plan</button>

                        <hr style="margin: 10px 0; border: 1px solid #e9ecef;">

                        <button class="btn-secondary" onclick="saveLayout()">💾 Sauvegarder le Tournoi</button>
                        <button class="btn-secondary" onclick="loadLayout()">📂 Charger le Tournoi</button>
                        <button class="btn-danger" onclick="clearAll()">🗑️ Tout effacer</button>
                    </div>
                </div>
            </div>
            <div class="workspace">
            <div class="toolbar">
                <button class="tool-btn active" onclick="setTool('select')" id="selectTool">
                    &nbsp;&nbsp;&nbsp;🖱️ Sélection
                </button>
                <button class="tool-btn" onclick="setTool('multiselect')" id="multiselectTool">
                    ☑️ Plusieurs
                </button>
                <button class="tool-btn" onclick="setTool('pan')" id="panTool">
                    ✋ Bouger
                </button>
                <button class="tool-btn" onclick="setTool('moveboard')" id="moveboardTool">
                    ⇭ Déplacer
                </button>

                <button class="tool-btn" onclick="undo()" id="undoButton" title="Annuler (Ctrl+Z)" disabled>
                    ↶
                </button>
                <button class="tool-btn" onclick="redo()" id="redoButton" title="Rétablir (Ctrl+Y)" disabled>
                    ↷
                </button>

                <button class="tool-btn" onclick="deleteSelected()" title="Supprimer (Touche Suppr ou Retour)">
                    🗑️ Effacer
                </button>
                <button class="tool-btn" onclick="duplicateSelected()" title="Dupliquer (Ctrl+D)">
                    📋 Dupliquer
                </button>
                <button class="tool-btn" onclick="rotateSelected()" title="Rotation (R)">
                    ↻ Tourner
                </button>
                <button class="tool-btn" onclick="flipPlayersSelected()">
                    🔄 Inverser
                </button>

                <button class="btn-success" onclick="startQRScanner()" title="Scanner un résultat par QR Code"
                    style="margin: 0;">
                    📷 QR-codes
                </button>

                <div class="timer-controls">
                    <label for="timerMinutes" style="font-size: 0.9em; color: #333;">Minuteur :</label>
                    <input type="number" id="timerMinutes" value="15" min="-240">
                    <button class="btn-success btn-small" onclick="startRoundTimer()">▶</button>
                    <button class="btn-danger btn-small" onclick="stopRoundTimer()">⏹</button>
                    <span id="roundTimer">00:00</span>

                    <button class="btn-secondary btn-small" id="toggleBigTimerBtn" onclick="toggleBigTimer()"
                        title="Masquer/Afficher le chrono plein écran"
                        style="margin-left: 5px; display: none;">👁️</button>
                </div>
                <div style="margin-left: auto; color: #6c757d; font-size: 0.9em;">
                    Nb: <span id="selectedCount">0</span> | Z: <span id="zoomLevel">100%</span>
                </div>
            </div>

            <div class="canvas-container" id="canvasContainer">
                <div class="canvas" id="canvas"></div>
            </div>

            <div class="zoom-controls">
                <input type="range" min="10" max="200" value="100" class="zoom-slider" id="zoomSlider"
                    oninput="applyZoom(this.value / 100)" onchange="applyZoom(this.value / 100)">
                <button class="zoom-btn btn-secondary" onclick="resetZoom()" title="Zoom 100%">⊙</button>
                <button class="zoom-btn btn-secondary" onclick="fitAllTables()"
                    title="Voir toutes les tables">⛶</button>
            </div>

            <div class="shortcut-bar">
                <span>S</span> Sél. <span>P</span> Dépl. <span>M</span> Multi-Sél. <span>Ctrl+Z</span> Annuler
                <span>Suppr/Retour</span> Suppr. <span>R</span> Rotation <span>Ctrl+A</span> Tout Sél.
            </div>

        </div>
        </div>
        
    </div>
    </div>

    <button id="playerPlanReturnButton" class="btn-secondary" onclick="returnToPlayerHome()">
        ⬅️ Retour à l'accueil
    </button>
    <div id="loadingOverlay">
        <span>Génération du PDF en cours...</span>
    </div>
    <div id="scoreModal">
        <div id="scoreModalContent">
            <h4>Saisir le résultat</h4>
            <p>Pour l'échiquier : <strong id="scoreModalBoardNum"></strong></p>
            <select id="scoreModalSelect">
                <option value="">-- Choisir Résultat --</option>
                <option value="1-0">1-0</option>
                <option value="0-1">0-1</option>
                <option value="1/2-1/2">½-½</option>
                <option value="1-F">1-F (Blanc gagne F)</option>
                <option value="F-1">F-1 (Noir gagne F)</option>
                <option value="1/2-0">½-0</option>
                <option value="0-1/2">0-½</option>
                <option value="0-0">0-0 (Double perte)</option>
                <option value="F-F">F-F (Double forfait)</option>
            </select>
            <div class="score-modal-buttons">
                <button class="btn-success" onclick="saveScoreFromModal()">OK</button>
                <button class="btn-secondary" onclick="hideScoreModal()">Annuler</button>
            </div>
        </div>
    </div>
    <div id="qrScannerModal" class="modal-overlay" style="display:none;">
        <div id="qrScannerContent" class="modal-content">
            <h2>Scanner le QR Code</h2>
            <div id="video-container" style="background: #000; border-radius: 8px; overflow: hidden; margin: 20px 0;">
                <video id="qrVideo" autoplay playsinline style="width: 100%; display: block;"></video>
            </div>
            <div class="info-box">
                Positionnez le QR code dans le cadre de la caméra
            </div>
            <button class="btn-danger" onclick="stopQRScanner()" style="width: 100%;">
                Arrêter et Fermer
            </button>
        </div>
    </div>
    <div id="qrValidationModal" class="modal-overlay" style="display:none;">
        <div id="qrValidationContent" class="modal-content" style="width: 90%; max-width: 450px;">
            <h3>Valider le résultat ?</h3>
            <div id="validation-info"
                style="background: #f8f9fa; border-radius: 8px; padding: 20px; text-align: left; margin: 20px 0; line-height: 1.6;">
                <p style="font-size:1.1em; margin-bottom: 10px;">
                    <strong>Échiquier :</strong> <span id="qrValidateBoard"></span>
                </p>
                <p style="font-size:1.1em; margin-bottom: 5px;">
                    <strong>Blancs :</strong> <span id="qrValidateWhite"></span>
                </p>
                <p style="font-size:1.1em; margin-bottom: 15px; border-bottom: 1px solid #ddd; padding-bottom: 15px;">
                    <strong>Noirs :</strong> <span id="qrValidateBlack"></span>
                </p>
                <p style="font-size:1.4em; color:#667eea; text-align: center;">
                    <strong>Résultat :</strong> <span id="qrValidateResult"></span>
                </p>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                <button class="btn-success" onclick="validateQRResult()">
                    ✅ Valider
                </button>
                <button class="btn-secondary" onclick="cancelQRValidation()">
                    ❌ Annuler
                </button>
            </div>
        </div>
    </div>
    <div id="notification" class="notification"></div>
    <div id="arbiterPassModal" class="modal-overlay">
        <div class="modal-content" style="width: 350px;">
            <h2>Mot de passe Arbitre</h2>
            <p style="font-size: 0.9em; color: #666; margin-bottom: 15px;">
                Définissez un mot de passe pour le "Mode Saisie Joueur".
                Laissez vide pour désactiver ce mode.
            </p>
            <div class="control-group">
                <label for="arbiterPassInput">Nouveau mot de passe :</label>
                <input type="password" id="arbiterPassInput" placeholder="Minimum 4 caractères">
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn-success" onclick="setArbiterPassword()">Enregistrer</button>
                <button class="btn-secondary"
                    onclick="document.getElementById('arbiterPassModal').style.display = 'none'">Annuler</button>
            </div>
        </div>
    </div>

    <div id="switchToArbiterModal" class="modal-overlay" style="display: none;">
        <div class="modal-content" style="width: 350px;">
            <h2>🔐 Passage en Mode Arbitre</h2>
            <p style="margin-bottom: 15px;">Veuillez entrer le mot de passe arbitre pour passer en mode modification.
            </p>
            <div class="control-group">
                <label for="switchArbiterPassInput">Mot de passe :</label>
                <input type="password" id="switchArbiterPassInput" placeholder="Mot de passe arbitre">
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn-success" onclick="validateSwitchToArbiter()">Valider</button>
                <button class="btn-secondary" onclick="cancelSwitchToArbiter()">Annuler</button>
            </div>
        </div>
    </div>

    <div id="playerLoginModal" class="modal-overlay">
        <div class="modal-content" style="width: 350px;">
            <h2>Accès Saisie Résultat</h2>
            <p style="margin-bottom: 15px;">Veuillez entrer le mot de passe arbitre pour continuer.</p>
            <div class="control-group">
                <label for="playerPassInput">Mot de passe :</label>
                <input type="password" id="playerPassInput">
            </div>
            <div id="playerLoginError" style="color: #c00; font-weight: 600; margin-top: 10px; display: none;">
                Mot de passe incorrect.
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn-primary" onclick="loginAsPlayer()">Valider</button>
                <button class="btn-secondary"
                    onclick="document.getElementById('playerLoginModal').style.display = 'none'">Annuler</button>
            </div>
        </div>
    </div>
    <div id="playerHomeModal" class="modal-overlay"
        style="z-index: 10001; flex-direction: column; background: rgba(240, 240, 240, 0.98);">
        <div class="modal-content" style="width: 90%; max-width: 800px; box-shadow: 0 10px 40px rgba(0,0,0,0.3);">
            <h2 style="font-size: 1.8em; text-align: center;">Voir sa table / Encoder un résultat (Ronde: <span
                    id="playerModeRound"></span>)</h2>

            <div style="text-align: center; margin-bottom: 25px; margin-top: 15px;">
                <button class="btn-success" style="font-size: 1.2em; padding: 15px; width: 70%;"
                    onclick="startQRScanner()">
                    📷 Scanner QR Code (résultat)
                </button>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
            
            <div style="border: 2px solid #667eea; border-radius: 10px; padding: 20px;">
                <h3 style="text-align: center; color: #667eea; margin-top: 0; margin-bottom: 20px;">📍 Où est ma table ?</h3>
                <div style="display: grid; grid-template-columns: 1fr; gap: 15px;">
                    <button class="btn-primary" style="font-size: 1.1em; padding: 12px;" onclick="startPlayerQRScanner()">
                        🎫 Scanner mon QR-code
                    </button>
                    <button class="btn-info" style="font-size: 1.1em; padding: 12px;" onclick="showPlayerListSearch('VIEW')">
                        🧑‍🤝‍🧑 Chercher (Liste)
                    </button>
                    <button class="btn-info" style="font-size: 1.1em; padding: 12px;" onclick="showPlayerTextSearch('VIEW')">
                        🔍 Chercher (Texte)
                    </button>
                </div>
            </div>
            
            <div style="border: 2px solid #11998e; border-radius: 10px; padding: 20px;">
                <h3 style="text-align: center; color: #11998e; margin-top: 0; margin-bottom: 20px;">✍️ Encoder un résultat</h3>
                <div style="display: grid; grid-template-columns: 1fr; gap: 15px;">
                    <button class="btn-primary" style="font-size: 1.1em; padding: 12px;" onclick="showPlayerPlanView()">
                        🗺️ Saisir (Plan)
                    </button>
                    <button class="btn-info" style="font-size: 1.1em; padding: 12px;" onclick="showPlayerListSearch('ENCODE')">
                        🧑‍🤝‍🧑 Choisir (Liste)
                    </button>
                    <button class="btn-info" style="font-size: 1.1em; padding: 12px;" onclick="showPlayerTextSearch('ENCODE')">
                        🔍 Chercher (Texte)
                    </button>
                </div>
            </div>
            
        </div>

            <button class="btn-danger"
                style="margin-top: 30px; width: auto; padding: 10px 20px; display: block; margin-left: auto; margin-right: auto;"
                onclick="promptToLogoutPlayer()">
                Quitter le Mode Saisie
            </button>
        </div>
    </div>
    <div id="playerTextSearchModal" class="modal-overlay" style="z-index: 10002;">
        <div class="modal-content" style="width: 90%; max-width: 500px;">
            <h3>Chercher ma partie</h3>
            <div class="control-group">
                <label for="playerSearchInput">Entrez votre nom :</label>
                <input type="text" id="playerSearchInput" placeholder="Ex: Durand..." list="player-search-suggestions"
                    oninput="populatePlayerSearchSuggestions()">
                <datalist id="player-search-suggestions"></datalist>
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn-primary" onclick="findPlayerFromTextSearch()">Rechercher</button>
                <button class="btn-secondary" onclick="closePlayerTextSearch()">Annuler</button>
            </div>
        </div>
    </div>
    <div id="playerListSearchModal" class="modal-overlay" style="z-index: 10002;">
        <div class="modal-content" style="width: 90%; max-width: 500px;">
            <h3>Choisir ma partie</h3>
            <div class="control-group">
                <label for="playerListSelect">Sélectionnez votre nom dans la liste :</label>
                <select id="playerListSelect" style="font-size: 1.1em; padding: 8px 10px;">
                    <option value="">-- Chargement... --</option>
                </select>
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn-primary" onclick="findPlayerFromListSearch()">Valider</button>
                <button class="btn-secondary" onclick="closePlayerListSearch()">Annuler</button>
            </div>
        </div>
    </div>
    <div id="simplifiedScoreModal" class="modal-overlay" style="z-index: 10002;">
        <div class="modal-content" style="width: 90%; max-width: 500px;">
            <h3>Saisir Résultat (Échiquier <span id="simplifiedBoardNum"></span>)</h3>

            <div id="simplifiedPlayerInfo"
                style="background: #f8f9fa; border-radius: 8px; padding: 15px; text-align: center; margin-bottom: 20px; font-size: 1.1em;">
                <p><strong>Blancs:</strong> <span id="simplifiedWhitePlayer"></span></p>
                <p><strong>Noirs:</strong> <span id="simplifiedBlackPlayer"></span></p>
            </div>

            <div style="display: grid; grid-template-columns: 1fr; gap: 15px;">
                <button id="btnWinWhite" class="btn-primary"
                    style="font-size: 1.1em; padding: 15px; line-height: 1.4;"></button>
                <button id="btnDraw" class="btn-secondary"
                    style="font-size: 1.1em; padding: 15px; line-height: 1.4;"></button>
                <button id="btnWinBlack" class="btn-primary"
                    style="font-size: 1.1em; padding: 15px; line-height: 1.4;"></button>
            </div>

            <button class="btn-danger" style="margin-top: 25px;" onclick="closeSimplifiedScoreModal()">
                Annuler
            </button>
        </div>
    </div>
    <div id="playerLogoutConfirmModal" class="modal-overlay" style="z-index: 10002;">
        <div class="modal-content" style="width: 350px;">
            <h2>Quitter le Mode Saisie</h2>
            <p style="margin-bottom: 15px;">Veuillez entrer le mot de passe arbitre pour quitter.</p>
            <div class="control-group">
                <label for="playerLogoutPassInput">Mot de passe :</label>
                <input type="password" id="playerLogoutPassInput">
            </div>
            <div id="playerLogoutError" style="color: #c00; font-weight: 600; margin-top: 10px; display: none;">
                Mot de passe incorrect.
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn-danger" onclick="attemptPlayerLogout()">Confirmer</button>
                <button class="btn-secondary" onclick="closePlayerLogoutConfirm()">Annuler</button>
            </div>
        </div>
    </div>
    <div id="playerLogoutConfirmModal" class="modal-overlay" style="z-index: 10002;">
    </div>

    <div id="bigTimerOverlay">
        <span id="bigTimerDisplay">00:00</span>
    </div>

    <div id="playerTableInfoModal">
        <button id="closePlayerTableInfoBtn">×</button>

        <div class="info-name-container">
            <span id="playerTableInfoName"></span>
        </div>
        
        <div class="info-table-container">
            Table <span id="playerTableInfoTable"></span>
        </div>
        
        <div class="info-opponent-block">
            <div class="info-color">
                <span id="playerTableInfoColor"></span>
            </div>
            <div class="info-vs">contre</div>
            <div class="info-opponent-name">
                <span id="playerTableInfoOpponent"></span>
            </div>
        </div>
    </div>

    <script>
        // --- NOUVEAU: Gestion Accordéon ---
        function toggleAccordion(headerElement) {
            const content = headerElement.nextElementSibling;
            const isExpanded = content.classList.contains('expanded');

            // Fermer tous les autres
            document.querySelectorAll('.sidebar-content.expanded').forEach(el => {
                if (el !== content) {
                    el.classList.remove('expanded');
                    el.previousElementSibling.classList.remove('active');
                }
            });

            // Ouvrir/Fermer celui-ci
            if (isExpanded) {
                content.classList.remove('expanded');
                headerElement.classList.remove('active');
            } else {
                content.classList.add('expanded');
                headerElement.classList.add('active');
            }
        }
        // --- Fin Gestion Accordéon ---

        // --- Gestion Multi-Rondes ---
        window.roundsStore = {};
        window.currentRoundKey = 'ronde1';

        // --- Templates de salle (Supprimé) ---
        // const roomTemplates = { ... }; // SUPPRIMÉ

        function getCurrentState() {
            if (!roundsStore[currentRoundKey]) {
                roundsStore[currentRoundKey] = {
                    physicalTables: [],
                    rooms: [],
                    nextPhysicalTableId: 1,
                    nextRoomId: 1,
                    nextBoardNumber: 1,
                    historyStack: [],
                    redoStack: [],
                    timerState: { mode: 'stop', targetTime: 0, hidden: false } // <-- MODIFIÉ
                };
            }
            // Compatibilité anciens fichiers
            if (!roundsStore[currentRoundKey].timerState) {
                roundsStore[currentRoundKey].timerState = { mode: 'stop', targetTime: 0, hidden: false }; // <-- MODIFIÉ
            }
            // NOUVEAU: Compatibilité pour la propriété 'hidden'
            if (roundsStore[currentRoundKey].timerState.hidden === undefined) {
                roundsStore[currentRoundKey].timerState.hidden = false;
            }
            // Assurer la compatibilité avec les anciens sauvegardes
            if (!roundsStore[currentRoundKey].rooms) {
                roundsStore[currentRoundKey].rooms = [];
            }
            if (!roundsStore[currentRoundKey].nextRoomId) {
                roundsStore[currentRoundKey].nextRoomId = 1;
            }
            return roundsStore[currentRoundKey];
        }

        // Variables globales pour l'état ACTIF
        let physicalTables = [];
        let rooms = [];
        let nextPhysicalTableId = 1;
        let nextRoomId = 1;
        let nextBoardNumber = 1;
        let historyStack = [];
        let redoStack = [];

        // --- Gestion du Timer ---
        let timerInterval = null;
        let timerTargetTime = 0;
        let timerMode = 'stop';
        let timerStartTime = 0; // NOUVEAU: Pour le mode 'countup'

        let selectedTables = [];
        let currentTool = 'select';
        let isDragging = false;
        let isResizing = false;
        let dragContext = {};
        let canvasDrag = { active: false, startX: 0, startY: 0, scrollLeft: 0, scrollTop: 0 };
        let selectionBox = { active: false, startX: 0, startY: 0, element: null };
        let currentZoom = 1;
        let defaultTableWidth = 200;
        let lastTablePosition = { x: 100, y: 100 };

        let isUndoRedoing = false;
        let movingBoard = null;
        let bigTimerUserHidden = false;

        const CANVAS_WIDTH = 3000;
        const CANVAS_HEIGHT = 2000;
        const START_MARGIN = 100;

        // --- Sauvegarde Auto LocalStorage ---
        window.SAVE_KEY = 'chessRoomManagerSave';
        window.SAVE_KEY_TIMESTAMP = 'chessRoomManagerSaveTimestamp';
        window.SERVER_URL = 'save.php';
        window.USE_SERVER_SYNC = true;
        // NOUVEAU: Clé pour mémoriser la stratégie
        const STRATEGY_KEY = 'chessRoomSaveStrategy';

        // === NOUVEAU SYSTÈME DE SAUVEGARDE ===
        window.currentSaveMode = 'arbiter'; // 'arbiter' ou 'spectator'
        window.localSaveInterval = null;
        window.serverSyncInterval = null;
        window.lastServerTimestamp = 0;
        window.lastLocalSaveTime = 0;

        // ========================================
        // SYNCHRONISATION SERVEUR
        // ========================================
        // Les fonctions de sauvegarde sont maintenant dans chessroom-save-system.js
        // - saveToLocalStorage()
        // - saveToServer()
        // - loadFromServer()
        // - syncFromServerIfNeeded()
        // - Gestion de l'historique
        // - Interface utilisateur de contrôle

        function autoSaveToLocalStorage() {
            try {
                saveCurrentStateToStore();

                const dataToSave = {
                    roundsStore: JSON.parse(JSON.stringify(roundsStore)),
                    currentRoundKey: currentRoundKey,
                    arbiterPassword: arbiterPassword
                };

                Object.values(dataToSave.roundsStore).forEach(roundState => {
                    if (roundState.physicalTables) {
                        roundState.physicalTables.forEach(t => {
                            delete t.mouseDownHandler;
                        });
                    }
                });

                const json = JSON.stringify(dataToSave);
                localStorage.setItem(SAVE_KEY, json);
                localStorage.setItem(SAVE_KEY_TIMESTAMP, Date.now().toString());

            } catch (error) {
                console.error("Erreur lors de la sauvegarde auto:", error);
                if (error.name === 'QuotaExceededError') {
                    alert("Erreur: Impossible de sauvegarder. La mémoire cache du navigateur est pleine.");
                }
            }
        }

        function loadFromLocalStorage() {
            const savedData = localStorage.getItem(SAVE_KEY);
            const savedTimestamp = localStorage.getItem(SAVE_KEY_TIMESTAMP);

            if (!savedData || !savedTimestamp) {
                return false; // Pas de sauvegarde
            }

            try {
                const data = JSON.parse(savedData);

                // NOUVEAU: Formatage de la date
                const timestampStr = new Date(parseInt(savedTimestamp)).toLocaleString('fr-FR', {
                    day: 'numeric', month: 'long', hour: '2-digit', minute: '2-digit'
                });

                // MODIFIÉ: Afficher le confirm() avec la date
                if (data && data.roundsStore && typeof data.roundsStore === 'object' && !Array.isArray(data.roundsStore) && Object.keys(data.roundsStore).length > 0 && confirm(`Une sauvegarde automatique du ${timestampStr} a été trouvée. Voulez-vous la charger ?`)) {
                    roundsStore = data.roundsStore;
                    currentRoundKey = data.currentRoundKey || 'ronde1';
                    arbiterPassword = data.arbiterPassword || null; // NOUVEAU: Charger le mot de passe

                    // Migration (identique à loadLayout)
                    Object.values(roundsStore).forEach(roundState => {
                        if (!roundState.physicalTables) roundState.physicalTables = [];
                        if (!roundState.rooms) roundState.rooms = [];
                        if (!roundState.nextRoomId) roundState.nextRoomId = 1;
                        roundState.physicalTables.forEach(pt => {
                            if (!pt.arbiterComment) pt.arbiterComment = { text: "", flag: "none" };
                            pt.boards.forEach(b => {
                                if (b.score === undefined) b.score = { white: "", black: "" };
                                // Correction migration
                                if (b.players && b.players.white && typeof b.players.white === 'string') {
                                    b.players = {
                                        white: { name: b.players.white, elo: (b.players.white_elo || ""), comment: "" },
                                        black: { name: b.players.black, elo: (b.players.black_elo || ""), comment: "" }
                                    };
                                } else if (b.players) {
                                    if (b.players.white && !b.players.white.elo) b.players.white.elo = "";
                                    if (b.players.white && !b.players.white.comment) b.players.white.comment = "";
                                    if (b.players.black && !b.players.black.elo) b.players.black.elo = "";
                                    if (b.players.black && !b.players.black.comment) b.players.black.comment = "";
                                }
                            });
                        });
                        if (!roundState.historyStack) roundState.historyStack = [];
                        if (!roundState.redoStack) roundState.redoStack = [];
                    });

                    updateRoundSelector();
                    loadStateFromStore(currentRoundKey);

                    showNotification('Sauvegarde automatique chargée !', 'success');
                    return true; // Chargement réussi
                }
                return false; // L'utilisateur a refusé
            } catch (error) {
                console.error("Erreur chargement localStorage:", error);
                localStorage.removeItem(SAVE_KEY); // Supprimer la sauvegarde corrompue
                localStorage.removeItem(SAVE_KEY_TIMESTAMP);
                return false;
            }
        }


        // --- Gestion Multi-Rondes ---
        function saveCurrentStateToStore() {
            let state = getCurrentState();
            state.physicalTables = JSON.parse(JSON.stringify(physicalTables));
            state.rooms = JSON.parse(JSON.stringify(rooms));
            state.nextPhysicalTableId = nextPhysicalTableId;
            state.nextRoomId = nextRoomId;
            state.nextBoardNumber = nextBoardNumber;
            state.historyStack = JSON.parse(JSON.stringify(historyStack));
            state.redoStack = JSON.parse(JSON.stringify(redoStack));

            // NOUVEAU: Sauvegarder l'état du minuteur
            state.timerState = {
                mode: timerMode,
                targetTime: timerTargetTime,
                hidden: bigTimerUserHidden, // <-- NOUVELLE LIGNE
                startTime: timerStartTime // NOUVEAU: Sauvegarder le startTime
            };
        }

        function loadStateFromStore(key) {
            currentRoundKey = key;
            const state = getCurrentState();

            physicalTables = JSON.parse(JSON.stringify(state.physicalTables));
            rooms = JSON.parse(JSON.stringify(state.rooms));
            nextPhysicalTableId = state.nextPhysicalTableId;
            nextRoomId = state.nextRoomId;
            nextBoardNumber = state.nextBoardNumber;
            historyStack = JSON.parse(JSON.stringify(state.historyStack));
            redoStack = JSON.parse(JSON.stringify(state.redoStack));
            
            // Gestion du Timer
            clearInterval(timerInterval); 
            timerInterval = null;

            const savedTimerState = state.timerState || { mode: 'stop', targetTime: 0, hidden: false, startTime: 0 };
            timerMode = savedTimerState.mode;
            timerTargetTime = savedTimerState.targetTime;
            bigTimerUserHidden = savedTimerState.hidden;
            timerStartTime = savedTimerState.startTime || 0;

            // Mise à jour icône timer
            const btn = document.getElementById('toggleBigTimerBtn');
            if (btn) {
                btn.innerHTML = bigTimerUserHidden ? '👁️‍🗨️' : '👁️';
                btn.style.display = (timerMode !== 'stop') ? 'inline-block' : 'none';
            }

            if (timerMode !== 'stop') {
                timerInterval = setInterval(updateTimer, 500);
            }
            updateTimer(); 

            renderAllTables();
            // renderAllTables(); // Doublon supprimé
            renderAllRooms();
            updateStats();
            updateHistoryButtons();
            
            if (typeof updateSpectatorPlayerList === 'function') {
                updateSpectatorPlayerList();
            }

            // CES LIGNES DOIVENT ÊTRE DANS LA FONCTION (AVANT L'ACCOLADE FERMANTE)
            if (document.getElementById('roundSelector')) {
                document.getElementById('roundSelector').value = key;
            }
            const roundName = key.replace('r', 'R');
            if (document.getElementById('playerModeRound')) {
                document.getElementById('playerModeRound').textContent = roundName;
            }
        }

        function updateRoundSelector() {
            const selector = document.getElementById('roundSelector');
            if (!selector) return;
            selector.innerHTML = '';
            // S'assurer qu'il y a au moins une ronde
            if (Object.keys(roundsStore).length === 0) {
                roundsStore['ronde1'] = {
                    physicalTables: [], rooms: [], nextPhysicalTableId: 1, nextRoomId: 1,
                    nextBoardNumber: 1, historyStack: [], redoStack: []
                };
                currentRoundKey = 'ronde1';
            }
            Object.keys(roundsStore).forEach((key, index) => {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = key.replace('r', 'R');
                selector.appendChild(option);
            });
            selector.value = currentRoundKey;
        }

        function switchRound(key) {
            if (key === currentRoundKey) return;
            saveCurrentStateToStore();
            loadStateFromStore(key);
            autoSaveToLocalStorage();
        }

        function addNewRound() {
            saveCurrentStateToStore();
            const newKey = `ronde${Object.keys(roundsStore).length + 1}`;
            currentRoundKey = newKey;

            roundsStore[newKey] = {
                physicalTables: [],
                rooms: [],
                nextPhysicalTableId: 1,
                nextRoomId: 1,
                nextBoardNumber: 1,
                historyStack: [],
                redoStack: []
            };

            loadStateFromStore(newKey);
            updateRoundSelector();

            // CORRECTION: Sauvegarder l'état vide
            saveHistoryState();
        }

        function cloneRoundLayout() {
            saveCurrentStateToStore();

            const newLayout = JSON.parse(JSON.stringify(physicalTables));
            newLayout.forEach(pt => {
                pt.boards.forEach(b => {
                    // Initialiser avec des joueurs vides (Table Verte)
                    b.players = {
                        white: { name: "", elo: "", comment: "" },
                        black: { name: "", elo: "", comment: "" }
                    };
                });
            });

            const newRooms = JSON.parse(JSON.stringify(rooms));

            const newKey = `ronde${Object.keys(roundsStore).length + 1}`;
            currentRoundKey = newKey;

            roundsStore[newKey] = {
                physicalTables: newLayout,
                rooms: newRooms,
                nextPhysicalTableId: nextPhysicalTableId,
                nextRoomId: nextRoomId,
                nextBoardNumber: nextBoardNumber,
                historyStack: [],
                redoStack: []
            };

            loadStateFromStore(newKey);
            updateRoundSelector();

            // CORRECTION: Sauvegarder l'état cloné
            saveHistoryState();
        }


        // --- Fonctions du Timer ---
        function startRoundTimer() {
            clearInterval(timerInterval);

            // NOUVEAU: Réinitialiser l'état masqué
            bigTimerUserHidden = false;
            const btn = document.getElementById('toggleBigTimerBtn');
            if (btn) btn.innerHTML = '👁️';

            const minutes = parseInt(document.getElementById('timerMinutes').value) || 0;

            if (minutes > 0) {
                // CAS 1: DÉCOMPTE (Ex: 15)
                // AFFICHE le grand minuteur
                document.getElementById('bigTimerOverlay').style.display = 'flex';
                timerTargetTime = Date.now() + (minutes * 60 * 1000);
                timerMode = 'countdown'; // MODIFIÉ: Nouveau mode 'countdown'
            } else {
                // CAS 2: COMPTEUR (Ex: 0 ou -5)
                // N'affiche PAS le grand minuteur
                document.getElementById('bigTimerOverlay').style.display = 'none';
                timerStartTime = Date.now(); // NOUVEAU: Enregistrer le début du compte à rebours
                timerMode = 'countup'; // MODIFIÉ: Nouveau mode 'countup'
            }

            // Afficher le bouton toggle
            const btnToggle = document.getElementById('toggleBigTimerBtn');
            if (btnToggle) btnToggle.style.display = 'inline-block';

            updateTimer(); // Met à jour l'affichage immédiatement
            timerInterval = setInterval(updateTimer, 500);
            saveHistoryState(); // <-- NOUVEAU: Déclencher la synchronisation
        }
        // NOUVELLE FONCTION POUR MASQUER LE CHRONO PLEIN ÉCRAN
        function toggleBigTimer() {
            bigTimerUserHidden = !bigTimerUserHidden; // Inverse l'état

            // Met à jour l'icône du bouton
            const btn = document.getElementById('toggleBigTimerBtn');
            if (btn) {
                // 👁️‍🗨️ est l'icône "œil barré"
                btn.innerHTML = bigTimerUserHidden ? '👁️‍🗨️' : '👁️';
            }

            // Applique le changement d'affichage immédiatement
            // Afficher le bouton toggle
            const btnToggle = document.getElementById('toggleBigTimerBtn');
            if (btnToggle) btnToggle.style.display = 'inline-block';

            updateTimer();
            saveHistoryState();
        }
        // CORRECTION: CETTE FONCTION ÉTAIT MANQUANTE
        function stopRoundTimer() {
            clearInterval(timerInterval); // <-- LIGNE AJOUTÉE
            timerInterval = null;         // <-- LIGNE AJOUTÉE
            timerMode = 'stop';
            timerTargetTime = 0; // NOUVEAU: Réinitialiser
            bigTimerUserHidden = false; // NOUVEAU: Réinitialiser
            timerStartTime = 0; // NOUVEAU: Réinitialiser

            const timerDisplay = document.getElementById('roundTimer');
            timerDisplay.textContent = '00:00';
            timerDisplay.className = '';
            // Cacher le bouton toggle
            const btn = document.getElementById('toggleBigTimerBtn');
            if (btn) {
                btn.innerHTML = '👁️';
                btn.style.display = 'none';
            }
            saveHistoryState(); // <-- NOUVEAU: Déclencher la synchronisation

            // CACHE et réinitialise le grand minuteur (comme demandé)
            document.getElementById('bigTimerOverlay').style.display = 'none';
            document.getElementById('bigTimerDisplay').textContent = '00:00';
        }

        function updateTimer() {
            const timerDisplay = document.getElementById('roundTimer');
            const bigTimerDisplay = document.getElementById('bigTimerDisplay');
            const bigTimerOverlay = document.getElementById('bigTimerOverlay'); // <-- NOUVEAU: Récupérer l'overlay
            const now = Date.now();

            // --- NOUVEAU BLOC AJOUTÉ ---
            // Gérer le cas 'stop' explicitement pour forcer l'arrêt
            if (timerMode === 'stop') {
                clearInterval(timerInterval);
                timerInterval = null;
                timerDisplay.textContent = '00:00';
                timerDisplay.className = '';
                bigTimerOverlay.style.display = 'none';
                bigTimerDisplay.textContent = '00:00';
                return; // Fin
            }
            // --- FIN DU NOUVEAU BLOC ---

            if (timerMode === 'countdown') { // MODIFIÉ: Utiliser 'countdown'
                let remainingMs = timerTargetTime - now;

                if (remainingMs <= 0) {
                    // --- MODIFICATION: Passer automatiquement en AJOUT DE TEMPS ---
                    timerMode = 'countup';
                    // On définit le start time pour que ça commence à 0
                    timerStartTime = now;
                    timerDisplay.className = 'timer-elapsed'; // Rouge
                    timerDisplay.textContent = "00:00";
                    if (bigTimerDisplay) {
                        bigTimerDisplay.textContent = "00:00";
                        bigTimerDisplay.style.color = "#ff4444";
                    }
                    return; // On laisse le prochain cycle faire l'affichage
                }

                const seconds = Math.floor((remainingMs / 1000) % 60);
                const minutes = Math.floor((remainingMs / 1000 / 60) % 60);
                const newTime = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                timerDisplay.textContent = newTime;
                bigTimerDisplay.textContent = newTime;
                timerDisplay.className = 'timer-countdown';

                // --- NOUVELLE LOGIQUE DE MASQUAGE ---
                if (bigTimerUserHidden) {
                    bigTimerOverlay.style.display = 'none';
                } else {
                    bigTimerOverlay.style.display = 'flex';
                }
                // --- FIN ---

            } else if (timerMode === 'countup') { // MODIFIÉ: Utiliser 'countup'
                // NOUVEAU: S'assurer qu'il est aussi caché si on compte vers le haut
                bigTimerOverlay.style.display = 'none';

                let elapsedMs = now - timerStartTime; // MODIFIÉ: Utiliser timerStartTime
                // ... (le reste de la logique 'up')

                // CORRECTION: Les calculs étaient manquants
                const totalSeconds = Math.floor(elapsedMs / 1000);
                const seconds = totalSeconds % 60;
                const totalMinutes = Math.floor(totalSeconds / 60);
                const minutes = totalMinutes % 60;
                const hours = Math.floor(totalMinutes / 60);

                let newTime = '';
                if (hours > 0) {
                    newTime = `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                } else {
                    newTime = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }
                timerDisplay.textContent = newTime;
                timerDisplay.className = 'timer-elapsed'; // Style rouge
            }
        }


        // --- Template (Supprimé) ---
        function applyTemplate(templateName) {
            // SUPPRIMÉ
            alert("Cette fonctionnalité a été retirée.");
        }
        // --- Fonctions d'historique (Modifiées pour le store) ---
        function saveHistoryState() {
            if (isUndoRedoing) return;
            const state = {
                physicalTables: JSON.parse(JSON.stringify(physicalTables)),
                rooms: JSON.parse(JSON.stringify(rooms)),
                nextPhysicalTableId: nextPhysicalTableId,
                nextRoomId: nextRoomId,
                nextBoardNumber: nextBoardNumber,
                timerState: { // NOUVEAU: Sauvegarder l'état du minuteur dans l'historique
                    mode: timerMode,
                    targetTime: timerTargetTime,
                    hidden: bigTimerUserHidden,
                    startTime: timerStartTime
                }
            };
            historyStack.push(state);
            redoStack = [];
            if (historyStack.length > 50) {
                historyStack.shift();
            }
            updateHistoryButtons();
            autoSaveToLocalStorage();

            // NOUVEAU: Déclencher la sauvegarde serveur (si activée)
            // CORRECTION: C'est le SEUL endroit où onResultSaved() doit être appelé.
            if (window.ChessRoomSave) window.ChessRoomSave.onResultSaved();
        }
        function restoreState(state) {
            isUndoRedoing = true;
            physicalTables = JSON.parse(JSON.stringify(state.physicalTables));
            rooms = state.rooms ? JSON.parse(JSON.stringify(state.rooms)) : [];
            nextPhysicalTableId = state.nextPhysicalTableId;
            nextRoomId = state.nextRoomId || 1;
            nextBoardNumber = state.nextBoardNumber;

            // NOUVEAU: Restaurer l'état du minuteur
            const savedTimerState = state.timerState || { mode: 'stop', targetTime: 0, hidden: false, startTime: 0 };
            timerMode = savedTimerState.mode;
            timerTargetTime = savedTimerState.targetTime;
            bigTimerUserHidden = savedTimerState.hidden;
            timerStartTime = savedTimerState.startTime;

            clearInterval(timerInterval);
            timerInterval = null;
            if (timerMode !== 'stop') {
                timerInterval = setInterval(updateTimer, 500);
            }
            updateTimer(); // Mettre à jour l'affichage immédiatement

            // Mettre à jour l'icône et la visibilité du bouton toggle
            const btn = document.getElementById('toggleBigTimerBtn');
            if (btn) {
                btn.innerHTML = bigTimerUserHidden ? '👁️‍🗨️' : '👁️';
                btn.style.display = (timerMode !== 'stop') ? 'inline-block' : 'none';
            }


            renderAllTables();
            renderAllRooms();
            updateStats();
            clearSelection();
            isUndoRedoing = false;
        }
        function undo() {
            if (historyStack.length < 2) return;
            const currentState = historyStack.pop();
            redoStack.push(currentState);
            const prevState = historyStack[historyStack.length - 1];
            restoreState(prevState);
            updateHistoryButtons();
            autoSaveToLocalStorage();
        }
        function redo() {
            if (redoStack.length === 0) return;
            const nextState = redoStack.pop();
            historyStack.push(nextState);
            restoreState(nextState);
            updateHistoryButtons();
            autoSaveToLocalStorage();
        }
        function updateHistoryButtons() {
            document.getElementById('undoButton').disabled = historyStack.length < 2;
            document.getElementById('redoButton').disabled = redoStack.length === 0;
        }

        // --- Toggle Sidebar ---
        function toggleSidebar() {
            const mainContent = document.querySelector('.main-content');
            const btn = document.getElementById('sidebarToggle');
            mainContent.classList.toggle('sidebar-collapsed');
            if (mainContent.classList.contains('sidebar-collapsed')) {
                btn.innerHTML = '»';
            } else {
                btn.innerHTML = '«';
            }
        }

        // --- Fonctions Utilitaires ---
        function findBoard(boardNum) {
            const searchKey = boardNum.toString();
            for (const physicalTable of physicalTables) {
                const board = physicalTable.boards.find(b => b.boardNumber.toString() === searchKey);
                if (board) {
                    return { board, physicalTable };
                }
            }
            return { board: null, physicalTable: null };
        }

        // --- Format des Noms (NOM Prénom) ---
        function formatPlayerName(fullName) {
            if (!fullName) return '';
            const parts = fullName.trim().split(/\s+/);
            const lastName = parts.pop() || '';
            const firstName = parts.join(' ');
            return `<strong class="lastname">${lastName.toUpperCase()}</strong> ${firstName}`;
        }

        // NOUVEAU: Obtenir le nom simple
        function getSimplePlayerName(fullName) {
            if (!fullName) return 'N/A';
            const parts = fullName.trim().split(/\s+/);
            const lastName = parts.pop() || '';
            const firstName = parts.join(' ');
            return `${firstName} ${lastName.toUpperCase()}`;
        }


        function getLayoutConfig() {
            const corner = document.getElementById('startCorner').value;
            const physicalTablesPerRow = parseInt(document.getElementById('physicalTablesPerRow').value) || 10;
            const tableLengthCm = parseInt(document.getElementById('tableLength').value) || 180;

            const boardsPerTable = parseInt(document.getElementById('boardsPerTable').value) || 1;

            const minWidthPerBoard = 150;
            const estimatedTableWidth = Math.max(tableLengthCm * 1.2, minWidthPerBoard * boardsPerTable);
            const estimatedRowWidth = (estimatedTableWidth + 30) * physicalTablesPerRow - 30;
            const estimatedTableHeight = 160;

            switch (corner) {
                case 'tr':
                    return {
                        startX: CANVAS_WIDTH - START_MARGIN,
                        startY: START_MARGIN,
                        xDir: -1,
                        yDir: 1
                    };
                case 'bl':
                    return {
                        startX: START_MARGIN,
                        startY: CANVAS_HEIGHT - START_MARGIN - estimatedTableHeight,
                        xDir: 1,
                        yDir: -1
                    };
                case 'br':
                    return {
                        startX: CANVAS_WIDTH - START_MARGIN,
                        startY: CANVAS_HEIGHT - START_MARGIN - estimatedTableHeight,
                        xDir: -1,
                        yDir: -1
                    };
                case 'tl':
                default:
                    return {
                        startX: START_MARGIN,
                        startY: START_MARGIN,
                        xDir: 1,
                        yDir: 1
                    };
            }
        }


        // --- Gestion des Outils ---
        function setTool(tool) {
            // NOUVEAU: Ne pas changer d'outil en mode joueur
            if (isPlayerMode && !document.body.classList.contains('player-plan-view-mode')) return;

            currentTool = tool;
            const canvas = document.getElementById('canvas');

            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(tool + 'Tool').classList.add('active');

            canvas.classList.remove('move-mode', 'moveboard-mode');

            if (tool === 'pan') {
                canvas.classList.add('move-mode');
                canvas.style.cursor = 'grab';
            } else if (tool === 'multiselect') {
                canvas.style.cursor = 'crosshair';
            } else if (tool === 'moveboard') {
                canvas.classList.add('moveboard-mode');
                canvas.style.cursor = 'default';
            } else {
                canvas.style.cursor = 'default';
            }
        }

        // --- Création/Disposition des Tables ---
        function addBoards() {
            // CORRECTION: Sauvegarde APRÈS modification
            try {
                const boardCount = parseInt(document.getElementById('boardCount').value);
                const boardsPerTable = parseInt(document.getElementById('boardsPerTable').value) || 1;
                const physicalTablesPerRow = parseInt(document.getElementById('physicalTablesPerRow').value) || 10;
                const tableLengthCm = parseInt(document.getElementById('tableLength').value) || 180;

                const minWidthPerBoard = 150;

                if (!boardCount || boardCount < 1 || boardCount > 2000) {
                    alert('Veuillez saisir un nombre d\'échiquiers entre 1 et 2000');
                    return;
                }

                const physicalTableCount = Math.ceil(boardCount / boardsPerTable);
                const spacingY = 160;
                const newTables = [];

                let currentX, currentY, currentCol, xDir, yDir;

                if (physicalTables.length === 0) {
                    nextBoardNumber = 1;      // On repart à l'échiquier 1
                    nextPhysicalTableId = 1;  // On repart à l'ID interne 1
                    // ==============================

                    let layout = getLayoutConfig();
                    currentX = layout.startX;
                    currentY = layout.startY;
                    xDir = layout.xDir;
                    yDir = layout.yDir;
                    currentCol = 0;
                } else {
                    xDir = 1; yDir = 1;
                    const totalExistingTables = physicalTables.length;
                    const lastCompleteRow = Math.floor((totalExistingTables - 1) / physicalTablesPerRow);
                    const lastCol = (totalExistingTables - 1) % physicalTablesPerRow;

                    if (lastCol === physicalTablesPerRow - 1) {
                        currentX = START_MARGIN;
                        currentY = START_MARGIN + ((lastCompleteRow + 1) * spacingY);
                        currentCol = 0;
                    } else {
                        const lastTableInRow = physicalTables.find(t => t.y === (START_MARGIN + (lastCompleteRow * spacingY)) && (physicalTables.indexOf(t) % physicalTablesPerRow === lastCol));
                        const lastTableWidth = lastTableInRow ? (lastTableInRow.width || defaultTableWidth) : defaultTableWidth;

                        currentX = (lastTableInRow ? lastTableInRow.x : START_MARGIN) + lastTableWidth + 30;
                        currentY = START_MARGIN + (lastCompleteRow * spacingY);
                        currentCol = lastCol + 1;
                    }
                }

                let currentBoardCount = physicalTables.reduce((acc, p) => acc + p.boards.length, 0);
                const totalBoardTarget = boardCount + currentBoardCount;

                for (let i = 0; i < physicalTableCount; i++) {
                    const col = (currentCol + i) % physicalTablesPerRow;

                    if (col === 0 && i > 0) {
                        currentX = (physicalTables.length === 0) ? getLayoutConfig().startX : START_MARGIN;
                        currentY += spacingY * yDir;
                    }

                    const actualBoardsForThisTable = Math.min(boardsPerTable, totalBoardTarget - currentBoardCount);
                    if (actualBoardsForThisTable <= 0) break;

                    const tableWidth = Math.max(tableLengthCm * 1.2, minWidthPerBoard * actualBoardsForThisTable);

                    const tableX = (xDir === 1) ? currentX : currentX - tableWidth;
                    const tableY = (yDir === 1) ? currentY : currentY;

                    const physicalTable = {
                        id: nextPhysicalTableId++,
                        x: tableX,
                        y: tableY,
                        rotation: 0,
                        width: tableWidth,
                        arbiterComment: { text: "", flag: "none" },
                        boards: []
                    };

                    for (let j = 0; j < actualBoardsForThisTable; j++) {
                        physicalTable.boards.push({
                            boardNumber: nextBoardNumber++,
                            // CORRECTION: Initialiser avec des joueurs vides (Table Verte)
                            players: {
                                white: { name: "", elo: "", comment: "" },
                                black: { name: "", elo: "", comment: "" }
                            },
                            flipped: false,
                            score: { white: "", black: "" }
                        });
                        currentBoardCount++;
                    }

                    if (physicalTable.boards.length > 0) {
                        physicalTables.push(physicalTable);
                        newTables.push(physicalTable);
                        createTableElement(physicalTable);
                        lastTablePosition = { x: tableX, y: tableY };
                        currentX += (tableWidth + 30) * xDir;
                    }
                }
                updateStats();

                if (newTables.length > 0) {
                    saveHistoryState(); // Sauvegarder APRÈS que les tables ont été ajoutées
                    setTimeout(() => centerViewOnTables(newTables), 100);
                }

            } catch (error) {
                console.error('Error in addBoards:', error);
                alert('Une erreur est survenue: ' + error.message);
            }
        }

        function centerViewOnTables(tablesToCenter) {
            if (tablesToCenter.length === 0) return;
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            tablesToCenter.forEach(pTable => {
                minX = Math.min(minX, pTable.x);
                minY = Math.min(minY, pTable.y);
                maxX = Math.max(maxX, pTable.x + (pTable.width || 200));
                maxY = Math.max(maxY, pTable.y + 160);
            });
            const margin = 100;
            minX -= margin; minY -= margin; maxX += margin; maxY += margin;
            const centerX = (minX + maxX) / 2; const centerY = (minY + maxY) / 2;
            const container = document.getElementById('canvasContainer');
            const containerWidth = container.clientWidth; const containerHeight = container.clientHeight;
            const contentWidth = maxX - minX; const contentHeight = maxY - minY;
            const zoomX = containerWidth / contentWidth; const zoomY = containerHeight / contentHeight;
            const suggestedZoom = Math.min(zoomX, zoomY, 1) * 0.9;
            if (suggestedZoom < currentZoom) {
                applyZoom(Math.max(0.1, suggestedZoom));
            }
            container.scrollLeft = (centerX * currentZoom) - containerWidth / 2;
            container.scrollTop = (centerY * currentZoom) - containerHeight / 2;
        }

        function createTableElement(physicalTable) {
            try {
                const canvas = document.getElementById('canvas');
                if (!canvas) return;

                const element = document.createElement('div');
                element.className = `table-element rotate-${physicalTable.rotation}`;
                element.id = `phys-table-${physicalTable.id}`;
                element.style.left = physicalTable.x + 'px';
                element.style.top = physicalTable.y + 'px';
                element.style.width = (physicalTable.width || defaultTableWidth) + 'px';
                element.style.setProperty('--rotation', `${physicalTable.rotation}deg`);
                element.dataset.tableId = physicalTable.id;

                const contentInner = document.createElement('div');
                contentInner.className = 'table-content-inner';

                element.prepend(contentInner);

                const flagClass = physicalTable.arbiterComment ? `flag-${physicalTable.arbiterComment.flag}` : 'flag-none';

                element.innerHTML += `
                    <div class="arbiter-flag ${flagClass}" onclick="event.stopPropagation(); editArbiterComment(${physicalTable.id})" title="Commentaire arbitre">⚐</div>
                    <div class="delete-btn" onclick="event.stopPropagation(); deleteTable(${physicalTable.id})">×</div>
                    <div class="rotate-btn" onclick="event.stopPropagation(); rotateTable(${physicalTable.id})">↻</div>
                    <div class="resize-handle handle-left" onmousedown="event.stopPropagation(); startResize(event, ${physicalTable.id}, 'left')">⬌</div>
                    <div class="resize-handle handle-right" onmousedown="event.stopPropagation(); startResize(event, ${physicalTable.id}, 'right')">⬌</div>
                `;

                updateTableDisplay(physicalTable.id, element);

                physicalTable.mouseDownHandler = (e) => handleTableMouseDown(e, physicalTable.id);
                element.addEventListener('mousedown', physicalTable.mouseDownHandler);
                element.addEventListener('click', (e) => {
                    // NOUVEAU: Désactivé en mode joueur
                    if (isPlayerMode) return;
                    if (e.target.classList.contains('player-name')) element.classList.toggle('expanded');
                });

                canvas.appendChild(element);
            } catch (error) { console.error('Error in createTableElement:', error); }
        }

        // --- Drag/Drop Échiquier ---
        function startMoveBoard(e, boardNumber, tableId) {
            if (isDragging || movingBoard) return;
            isDragging = true;

            const { board } = findBoard(boardNumber);
            if (!board) return;

            const sourceElement = e.currentTarget;

            const ghost = sourceElement.cloneNode(true);
            ghost.id = 'ghost';
            ghost.style.position = 'absolute';
            ghost.style.opacity = '0.7';
            ghost.style.zIndex = '2000';
            ghost.style.width = sourceElement.offsetWidth + 'px';
            document.body.appendChild(ghost);

            movingBoard = {
                boardNumber,
                originalTableId: tableId,
                element: ghost,
                offsetX: e.offsetX,
                offsetY: e.offsetY
            };

            moveGhost(e);

            document.querySelectorAll('.table-element').forEach(tableEl => {
                tableEl.addEventListener('mouseenter', handleTableDropEnter);
                tableEl.addEventListener('mouseleave', handleTableDropLeave);
            });
        }

        function moveGhost(e) {
            if (!movingBoard) return;
            movingBoard.element.style.left = (e.clientX - movingBoard.offsetX) + 'px';
            movingBoard.element.style.top = (e.clientY - movingBoard.offsetY) + 'px';
        }

        function handleTableDropEnter(e) {
            if (!movingBoard) return;
            e.currentTarget.classList.add('selected');
        }

        function handleTableDropLeave(e) {
            if (!movingBoard) return;
            const tableId = parseInt(e.currentTarget.dataset.tableId);
            if (!selectedTables.includes(tableId)) {
                e.currentTarget.classList.remove('selected');
            }
        }


        // --- Modification des Éléments ---

        // Commentaire Arbitre (Table)
        function editArbiterComment(tableId) {
            const table = physicalTables.find(t => t.id === tableId);
            if (!table) return;

            if (!table.arbiterComment) {
                table.arbiterComment = { text: "", flag: "none" };
            }

            const currentText = table.arbiterComment.text || '';
            const newText = prompt("Ajouter/modifier le commentaire arbitre pour cette table:", currentText);

            if (newText !== null) {
                const currentFlag = table.arbiterComment.flag || 'none';
                const newFlag = prompt("Couleur du drapeau (none, red, yellow, green):", currentFlag);

                // CORRECTION: Modifier AVANT de sauvegarder
                table.arbiterComment.text = newText.trim();
                table.arbiterComment.flag = newFlag ? newFlag.trim().toLowerCase() : 'none';

                const element = document.getElementById(`phys-table-${tableId}`);
                if (element) {
                    const flagEl = element.querySelector('.arbiter-flag');
                    if (flagEl) {
                        flagEl.className = `arbiter-flag flag-${table.arbiterComment.flag}`;
                    }
                }

                saveHistoryState();
            }
        }

        function editPlayerComment(boardNum, color) {
            if (isPlayerMode) return;

            const { board, physicalTable } = findBoard(boardNum);
            if (!board || !board.players) return;

            const player = board.players[color];
            const currentValue = player.comment || '';
            const newValue = prompt(`Ajouter/modifier le commentaire pour ${player.name}:`, currentValue);

            if (newValue !== null) {
                // CORRECTION: Modifier AVANT de sauvegarder
                player.comment = newValue.trim();
                updateTableDisplay(physicalTable.id);

                saveHistoryState();
            }
        }

        // --- Saisie de score par Modale ---
        function editScore(boardNum) {
            // NOUVEAU: Si on est en mode joueur, utiliser la modale simplifiée
            if (isPlayerMode) {
                const { board, physicalTable } = findBoard(boardNum);
                // NOUVEAU: Vérifier si le score est déjà saisi
                if (board && (board.score.white !== '' || board.score.black !== '')) {
                    showNotification("Ce résultat a déjà été saisi.", "info");
                    return;
                }
                if (board && board.players) {
                    showSimplifiedScoreModal(board, physicalTable);
                }
                return;
            }

            // Logique arbitre (modale complète)
            const { board } = findBoard(boardNum);
            if (!board) return;
            showScoreModal(boardNum);
        }

        function showScoreModal(boardNum) {
            const { board } = findBoard(boardNum);
            if (!board) return;

            const modal = document.getElementById('scoreModal');
            const select = document.getElementById('scoreModalSelect');
            const boardNumEl = document.getElementById('scoreModalBoardNum');

            boardNumEl.textContent = boardNum;
            modal.dataset.boardNum = boardNum;

            let currentValue = "";
            if (board.score.white && board.score.black) {
                // Gérer le cas 1/2-1/2
                if (board.score.white === "1/2" && board.score.black === "1/2") {
                    currentValue = "1/2-1/2";
                } else {
                    currentValue = `${board.score.white}-${board.score.black}`;
                }
            }

            select.value = currentValue;
            if (select.value !== currentValue) {
                select.value = "";
            }

            modal.style.display = 'flex';
            select.focus();
        }

        function hideScoreModal() {
            document.getElementById('scoreModal').style.display = 'none';
        }

        function saveScoreFromModal() {
            const modal = document.getElementById('scoreModal');
            const select = document.getElementById('scoreModalSelect');
            const boardNum = modal.dataset.boardNum;
            const value = select.value;

            const { board, physicalTable } = findBoard(boardNum);
            if (!board) {
                hideScoreModal();
                return;
            }

            // CORRECTION: Modifier AVANT de sauvegarder
            if (value === "") {
                board.score.white = "";
                board.score.black = "";
            } else {
                const parts = value.split('-');
                board.score.white = parts[0] || "";
                board.score.black = parts[1] || "";
            }

            updateTableDisplay(physicalTable.id);
            updateStats();

            saveHistoryState(); // Sauvegarder APRÈS

            // --- NOUVEAU: Sauvegarde Atomique ---
            // On lance la mise à jour serveur spécifique
            if (typeof updateScoreOnServer === 'function') {
                updateScoreOnServer(currentRoundKey, boardNum, value);
            }

            // On sauvegarde en local pour ne pas perdre la donnée si on refresh
            // Mais on ÉVITE saveToServer() complet pour ne pas écraser les autres
            if (typeof saveToLocalStorage === 'function') {
                saveToLocalStorage();
            }

            hideScoreModal();
        }


        // --- Validation "Entrée" pour le numéro d'échiquier ---
        function editBoardNumber(oldNumber) {
            // NOUVEAU: Désactivé en mode joueur
            if (isPlayerMode) return;

            try {
                const { board, physicalTable } = findBoard(oldNumber);
                if (!board) return;

                const physicalTableEl = document.getElementById(`phys-table-${physicalTable.id}`);
                const boardEl = physicalTableEl.querySelector(`[data-board-number="${oldNumber.toString().replace(/"/g, '\\"')}"]`);
                const numberDisplay = boardEl.querySelector('.board-number-display');
                const originalText = numberDisplay.textContent.trim();

                const input = document.createElement('input');
                input.type = 'text';
                input.value = oldNumber;
                input.style.cssText = `
                    width: 100px; text-align: center; margin: 0 auto; display: block;
                    border: 2px solid #667eea; font-size: 1.2em; padding: 4px; font-weight: 700;
                `;

                numberDisplay.innerHTML = '';
                numberDisplay.appendChild(input);
                input.focus();
                input.select();

                // Fonction de sauvegarde (closure)
                function saveEdit() {
                    input.removeEventListener('blur', saveEdit);
                    input.removeEventListener('keydown', handleKeydown);

                    const newNumberStr = input.value.trim();
                    const originalNumber = oldNumber;

                    if (newNumberStr === "") {
                        numberDisplay.innerHTML = originalText;
                        return;
                    }

                    const newNumberValue = parseInt(newNumberStr);
                    let newNumber;

                    if (isNaN(newNumberValue) || newNumberValue.toString() !== newNumberStr) {
                        newNumber = newNumberStr;
                    } else {
                        newNumber = newNumberValue;
                    }

                    if (newNumber.toString() === originalNumber.toString()) {
                        numberDisplay.innerHTML = newNumber;
                        return;
                    }

                    const { board: targetBoard } = findBoard(originalNumber);

                    if (targetBoard) {
                        // CORRECTION: Modifier AVANT de sauvegarder
                        targetBoard.boardNumber = newNumber;

                        numberDisplay.innerHTML = newNumber;
                        boardEl.dataset.boardNumber = newNumber;

                        const boardNumForEvent = (typeof newNumber === 'string') ? `'${newNumber.replace(/'/g, "\\'")}'` : newNumber;

                        numberDisplay.setAttribute('onDblClick', `event.stopPropagation(); editBoardNumber(${boardNumForEvent})`);
                        boardEl.querySelector('.flip-btn-single').setAttribute('onclick', `event.stopPropagation(); flipSingleBoard(${boardNumForEvent})`);

                        boardEl.querySelectorAll('.player-name').forEach(nameEl => {
                            const player = nameEl.closest('.player');
                            if (player) {
                                const color = player.dataset.color;
                                nameEl.setAttribute('onclick', `event.stopPropagation(); editPlayerComment(${boardNumForEvent}, '${color}')`);
                            }
                        });
                        boardEl.querySelectorAll('.player-score').forEach(scoreEl => {
                            scoreEl.setAttribute('onclick', `event.stopPropagation(); editScore(${boardNumForEvent})`);
                        });

                        saveHistoryState(); // Sauvegarder APRÈS

                    } else {
                        numberDisplay.innerHTML = originalText;
                    }
                }

                // Gestionnaire de clavier
                function handleKeydown(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        saveEdit();
                    } else if (e.key === 'Escape') {
                        input.removeEventListener('blur', saveEdit);
                        input.removeEventListener('keydown', handleKeydown);
                        numberDisplay.innerHTML = originalText;
                    }
                }

                input.addEventListener('blur', saveEdit);
                input.addEventListener('keydown', handleKeydown);

            } catch (error) { console.error('Error in editBoardNumber:', error); }
        }

        function handleTableMouseDown(e, tableId) {
            try {
                // MODIFIÉ: Logique de clic en mode joueur simplifiée (gérée par le clic sur .board-container)
                if (isPlayerMode && document.body.classList.contains('player-plan-view-mode')) {
                    // Laisser le clic remonter jusqu'au .board-container si c'est la cible
                    if (e.target.closest('.board-container')) {
                        return;
                    }
                    // Empêcher d'autres actions
                    e.stopPropagation();
                    e.preventDefault();
                    return;
                }

                if (e.target.classList.contains('delete-btn') ||
                    e.target.classList.contains('rotate-btn') ||
                    e.target.classList.contains('resize-handle') ||
                    e.target.classList.contains('flip-btn-single') ||
                    e.target.classList.contains('arbiter-flag') ||
                    e.target.classList.contains('player-name') ||
                    e.target.classList.contains('player-score') ||
                    (e.target.closest('.board-container') && currentTool === 'moveboard') ||
                    e.target.tagName.toLowerCase() === 'input') {
                    return;
                }

                // Ne pas sélectionner la table si on clique sur une salle (car la salle est derrière)
                if (e.target.classList.contains('room-element') || e.target.classList.contains('room-title')) {
                    return;
                }

                if (currentTool === 'select') {
                    isDragging = true;
                    if (!e.ctrlKey && !e.metaKey && !selectedTables.includes(tableId)) {
                        clearSelection(true); // MODIFIÉ: Ne pas désélectionner les salles
                        selectTable(tableId);
                    } else if (e.ctrlKey || e.metaKey) {
                        toggleTableSelection(tableId);
                    }

                    dragContext = {
                        isRoom: false,
                        tables: [],
                        startX: e.clientX,
                        startY: e.clientY
                    };

                    selectedTables.forEach(id => {
                        const table = physicalTables.find(t => t.id === id);
                        const element = document.getElementById(`phys-table-${id}`);
                        if (table && element) {
                            dragContext.tables.push({ table, element, initialX: table.x, initialY: table.y });
                            element.style.zIndex = '1000';
                        }
                    });

                    e.preventDefault();
                    e.stopPropagation();
                }
            } catch (error) { console.error('Error in handleTableMouseDown:', error); }
        }

        function selectTable(tableId) {
            if (selectedTables.includes(tableId)) return;
            selectedTables.push(tableId);
            const element = document.getElementById(`phys-table-${tableId}`);
            if (element) element.classList.add('selected');
            updateSelectedCount();
        }

        function toggleTableSelection(tableId) {
            const index = selectedTables.indexOf(tableId);
            if (index > -1) {
                selectedTables.splice(index, 1);
                const element = document.getElementById(`phys-table-${tableId}`);
                if (element) element.classList.remove('selected');
            } else {
                selectTable(tableId);
            }
            updateSelectedCount();
        }

        function clearSelection(keepRooms = false) {
            selectedTables.forEach(id => {
                const element = document.getElementById(`phys-table-${id}`);
                if (element) element.classList.remove('selected');
            });
            selectedTables = [];
            updateSelectedCount();

            if (!keepRooms) {
                document.querySelectorAll('.room-element.selected').forEach(el => el.classList.remove('selected'));
            }
        }

        function updateSelectedCount() {
            document.getElementById('selectedCount').textContent = selectedTables.length;
        }

        function deleteTable(tableId, addToHistory = true) {
            // CORRECTION: Sauvegarde gérée par deleteSelected ou appelée après modification
            try {
                const index = physicalTables.findIndex(t => t.id === tableId);
                if (index !== -1) {
                    physicalTables.splice(index, 1);
                    const element = document.getElementById(`phys-table-${tableId}`);
                    if (element) element.remove();
                    const selIndex = selectedTables.indexOf(tableId);
                    if (selIndex > -1) {
                        selectedTables.splice(selIndex, 1);
                        updateSelectedCount();
                    }
                    updateStats();

                    if (addToHistory) {
                        saveHistoryState(); // Sauvegarder APRÈS
                    }
                }
            } catch (error) { console.error('Error in deleteTable:', error); }
        }

        function deleteSelected() {
            if (selectedTables.length === 0) return;
            try {
                [...selectedTables].forEach(id => deleteTable(id, false));
                clearSelection();
                saveHistoryState(); // Sauvegarder APRÈS
            } catch (error) { console.error('Error in deleteSelected:', error); }
        }
        function rotateSelected() {
            if (selectedTables.length === 0) return;
            try {
                selectedTables.forEach(id => rotateTable(id, false));
                saveHistoryState(); // Sauvegarder APRÈS
            } catch (error) { console.error('Error in rotateSelected:', error); }
        }

        function flipSingleBoard(boardNumber) {
            if (isPlayerMode) return;

            try {
                const { board, physicalTable } = findBoard(boardNumber);
                if (board && board.players) {
                    board.flipped = !board.flipped;
                    updateTableDisplay(physicalTable.id);
                    saveHistoryState(); // Sauvegarder APRÈS
                }
            } catch (error) { console.error('Error in flipSingleBoard:', error); }
        }

        function flipPlayersSelected() {
            if (selectedTables.length === 0) return;
            try {
                selectedTables.forEach(id => {
                    const table = physicalTables.find(t => t.id === id);
                    if (table) {
                        table.boards.forEach(board => {
                            board.flipped = !board.flipped;
                        });
                        updateTableDisplay(id);
                    }
                });
                saveHistoryState(); // Sauvegarder APRÈS
            } catch (error) { console.error('Error in flipPlayersSelected:', error); }
        }

        // --- FONCTION DE RENDU PRINCIPALE (MODIFIÉE POUR SUIVI PERSISTANT) ---
        // --- FONCTION DE RENDU AVEC SURBRILLANCE ROBUSTE ---
        function updateTableDisplay(tableId, element) {
            try {
                const table = physicalTables.find(t => t.id === tableId);
                if (!table) return;

                if (!element) element = document.getElementById(`phys-table-${tableId}`);
                if (!element) return;

                // 1. Récupération du nom suivi (nettoyage accents/espaces)
                const rawWatchedName = localStorage.getItem('chessRoomWatchedPlayer');
                const normalize = (str) => str ? str.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").trim() : "";
                const targetName = normalize(rawWatchedName);

                const contentInner = element.querySelector('.table-content-inner');
                if (!contentInner) return;
                contentInner.innerHTML = '';

                let allPaired = table.boards.length > 0;
                let hasVisibleBoards = false;
                let tableIsHighlight = false; // Pour savoir si on allume toute la table

                table.boards.forEach((board) => {
                    const isInverted = (table.rotation === 180 && !board.flipped) || (table.rotation !== 180 && board.flipped);
                    if (board.players === null) allPaired = false;
                    const boardNumForEvent = (typeof board.boardNumber === 'string') ? `'${board.boardNumber.replace(/'/g, "\\'")}'` : board.boardNumber;
                    let playersHTML = '';
                    let boardHasPlayers = false;

                    // === DÉTECTION DU JOUEUR SUR CET ÉCHIQUIER ===
                    let isBoardHighlight = false;
                    if (targetName && board.players) {
                        const pWhite = normalize(board.players.white.name);
                        const pBlack = normalize(board.players.black.name);
                        
                        // On vérifie si le nom suivi est contenu dans le nom du joueur (ex: "Dupont" dans "DUPONT Jean")
                        if ((pWhite && pWhite.includes(targetName)) || (pBlack && pBlack.includes(targetName))) {
                            isBoardHighlight = true;
                            tableIsHighlight = true;
                        }
                    }

                    if (board.players) {
                        boardHasPlayers = true;
                        const buildPlayerHTML = (player, color, score) => {
                            if (!player) return '';
                            let displayNameHTML = (!player.name || player.name.trim() === "") 
                                ? `<span style="color: #999; font-style: italic;">${color === 'white' ? 'Blancs' : 'Noirs'}</span>` 
                                : formatPlayerName(player.name);
                            
                            return `
                                <div class="player" data-color="${color}">
                                    <div class="player-color ${color}"></div>
                                    <div class="player-info">
                                        <div class="player-name" onclick="event.stopPropagation(); editPlayerComment(${boardNumForEvent}, '${color}')">${displayNameHTML}</div>
                                        <div class="player-elo">${player.elo || '----'}</div>
                                    </div>
                                    <div class="player-score" onclick="event.stopPropagation(); editScore(${boardNumForEvent})">${score || '...'}</div>
                                </div>`;
                        };
                        const whiteHTML = buildPlayerHTML(board.players.white, 'white', board.score.white);
                        const blackHTML = buildPlayerHTML(board.players.black, 'black', board.score.black);
                        playersHTML = isInverted ? (blackHTML + whiteHTML) : (whiteHTML + blackHTML);
                    } else {
                        // ... (Code placeholder identique) ...
                        playersHTML = `<div class="player" style="opacity:0.5">...</div>`; 
                    }

                    const hasScore = (board.score && (board.score.white !== '' || board.score.black !== ''));
                    if (!isPlayerMode || !document.body.classList.contains('player-plan-view-mode') || !hasScore) hasVisibleBoards = true;

                    // === APPLICATION DU STYLE JAUNE DIRECTEMENT ICI ===
                    const highlightStyle = isBoardHighlight ? 
                        'background-color: #fff59d !important; border: 3px solid #ff6f00 !important; box-shadow: 0 0 15px #ff6f00 !important;' : '';

                    const boardHTML = `
                        <div class="board-container ${hasScore ? 'board-scored' : ''} ${boardHasPlayers ? 'has-players' : ''}" 
                             data-board-number="${board.boardNumber}"
                             style="${highlightStyle}">
                            <button class="flip-btn-single" onclick="event.stopPropagation(); flipSingleBoard(${boardNumForEvent})">🔄</button>
                            <div class="board-number board-number-display" onDblClick="event.stopPropagation(); editBoardNumber(${boardNumForEvent})">${board.boardNumber}</div>
                            <div class="players-container">${playersHTML}</div>
                        </div>`;

                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = boardHTML;
                    const boardContainer = tempDiv.firstElementChild;
                    
                    // Listeners (identiques)
                    boardContainer.addEventListener('click', function (e) {
                        if (isPlayerMode && document.body.classList.contains('player-plan-view-mode') && boardHasPlayers) {
                            e.stopPropagation(); editScore(board.boardNumber);
                        }
                    });
                    boardContainer.addEventListener('mousedown', (e) => {
                         if (currentTool === 'moveboard' && !isPlayerMode) { e.stopPropagation(); startMoveBoard(e, board.boardNumber, table.id); }
                    });

                    contentInner.appendChild(boardContainer);
                });

                element.style.display = (isPlayerMode && document.body.classList.contains('player-plan-view-mode') && !hasVisibleBoards) ? 'none' : 'block';
                if (allPaired) element.classList.add('has-pairing'); else element.classList.remove('has-pairing');

                // Si un des échiquiers est allumé, on met la table en avant plan
                if (tableIsHighlight) {
                    element.style.zIndex = '9999';
                    element.classList.add('highlight-player'); // Pour le style global
                } else {
                    element.classList.remove('highlight-player');
                }

            } catch (error) { console.error(`Erreur updateTableDisplay ${tableId}:`, error); }
        }

        // --- Rotation ---
        function rotateTable(tableId, addToHistory = true) {
            // CORRECTION: Sauvegarde gérée par rotateSelected ou appelée après modification
            try {
                const table = physicalTables.find(t => t.id === tableId);
                if (table) {
                    table.rotation = (table.rotation === 0) ? 90 : 0;

                    const element = document.getElementById(`phys-table-${tableId}`);
                    if (element) {
                        element.className = element.className.replace(/rotate-\d+/, `rotate-${table.rotation}`);
                        element.style.setProperty('--rotation', `${table.rotation}deg`);

                        element.classList.remove('vertical-layout');

                        const contentInner = element.querySelector('.table-content-inner');
                        if (contentInner) {
                            contentInner.style.transform = 'rotate(0deg)';
                        }
                    }

                    if (addToHistory) {
                        saveHistoryState(); // Sauvegarder APRÈS
                    }
                }
            } catch (error) { console.error('Error in rotateTable:', error); }
        }


        // --- Redimensionnement ---
        function startResize(e, tableId, handleSide) {
            isResizing = true;
            const table = physicalTables.find(t => t.id === tableId);
            const element = document.getElementById(`phys-table-${tableId}`);

            const startX = e.clientX;
            const startY = e.clientY;
            const startWidth = table.width || defaultTableWidth;
            const startXPos = table.x;
            const startYPos = table.y;

            function onMouseMove(e) {
                if (!isResizing) return;

                const deltaX = (e.clientX - startX) / currentZoom;
                const deltaY = (e.clientY - startY) / currentZoom;

                let delta = 0;

                switch (table.rotation) {
                    case 0: delta = (handleSide === 'left') ? -deltaX : deltaX; break;
                    case 90: delta = (handleSide === 'left') ? -deltaY : deltaY; break;
                    case 180: delta = (handleSide === 'left') ? deltaX : -deltaX; break;
                    case 270: delta = (handleSide === 'left') ? deltaY : -deltaY; break;
                }

                let newWidth = startWidth + delta;
                const minWidth = (table.boards.length * 150);
                newWidth = Math.max(minWidth, Math.min(2000, newWidth));

                const widthChange = newWidth - startWidth;

                table.width = newWidth;
                element.style.width = newWidth + 'px';

                if (handleSide === 'left') {
                    const radians = table.rotation * Math.PI / 180;
                    const cos = Math.cos(radians);
                    const sin = Math.sin(radians);

                    table.x = startXPos - (widthChange * cos);
                    table.y = startYPos - (widthChange * sin);

                    element.style.left = table.x + 'px';
                    element.style.top = table.y + 'px';
                }
            }

            function onMouseUp() {
                if (isResizing) {
                    if (table.width !== startWidth || table.x !== startXPos || table.y !== startYPos) {
                        saveHistoryState(); // Sauvegarder APRÈS
                    }
                }
                isResizing = false;
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }

            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            e.preventDefault();
        }

        function duplicateSelected() {
            if (selectedTables.length === 0) return;
            try {
                const newTables = [];
                selectedTables.forEach(id => {
                    const original = physicalTables.find(t => t.id === id);
                    if (original) {
                        const newTable = JSON.parse(JSON.stringify(original));
                        newTable.id = nextPhysicalTableId++;
                        newTable.x = original.x + 50;
                        newTable.y = original.y + 50;
                        newTable.boards.forEach(board => {
                            board.boardNumber = nextBoardNumber++;
                        });
                        physicalTables.push(newTable);
                        newTables.push(newTable.id);
                        createTableElement(newTable);
                    }
                });
                clearSelection();
                newTables.forEach(id => selectTable(id));
                updateStats();
                saveHistoryState(); // Sauvegarder APRÈS
            } catch (error) { console.error('Error in duplicateSelected:', error); }
        }

        function autoArrangeTables() {
            if (physicalTables.length === 0) {
                alert("Il n'y a aucune table à réorganiser. Chargez d'abord les appariements ou ajoutez des tables vierges.");
                return;
            }
            if (!confirm("Voulez-vous vraiment réorganiser toutes les tables en fonction des paramètres actuels ? Les positions et rotations manuelles seront perdues.")) {
                return;
            }

            try {
                const boardsPerTable = parseInt(document.getElementById('boardsPerTable').value) || 1;
                const physicalTablesPerRow = parseInt(document.getElementById('physicalTablesPerRow').value) || 10;
                const tableLengthCm = parseInt(document.getElementById('tableLength').value) || 180;

                let allBoards = [];
                physicalTables.forEach(pt => {
                    allBoards.push(...pt.boards);
                });

                allBoards.sort((a, b) => {
                    let numA = parseFloat(a.boardNumber);
                    let numB = parseFloat(b.boardNumber);
                    if (isNaN(numA)) numA = Infinity;
                    if (isNaN(numB)) numB = Infinity;
                    if (numA !== numB) return numA - numB;
                    return String(a.boardNumber).localeCompare(String(b.boardNumber));
                });

                physicalTables = [];
                document.getElementById('canvas').innerHTML = '';
                renderAllRooms(); // <-- S'assurer que les salles sont re-rendues
                nextPhysicalTableId = 1;

                const layout = getLayoutConfig();
                let currentX = layout.startX;
                let currentY = layout.startY;
                const xDir = layout.xDir;
                const yDir = layout.yDir;
                const spacingY = 160 * yDir;
                const minWidthPerBoard = 150;
                let col = 0;

                for (let i = 0; i < allBoards.length; i += boardsPerTable) {
                    const boardsForThisTable = allBoards.slice(i, i + boardsPerTable);

                    const tableWidth = Math.max(tableLengthCm * 1.2, minWidthPerBoard * boardsForThisTable.length);

                    if (col === 0) {
                        currentX = layout.startX;
                    }

                    const tableX = (xDir === 1) ? currentX : currentX - tableWidth;
                    const tableY = (yDir === 1) ? currentY : currentY - 160;

                    const physicalTable = {
                        id: nextPhysicalTableId++,
                        x: tableX,
                        y: tableY,
                        rotation: 0,
                        width: tableWidth,
                        arbiterComment: { text: "", flag: "none" },
                        boards: boardsForThisTable
                    };

                    physicalTables.push(physicalTable);

                    currentX += (tableWidth + 30) * xDir;
                    col++;
                    if (col >= physicalTablesPerRow) {
                        col = 0;
                        currentY += spacingY;
                    }
                }

                renderAllTables();
                updateStats();
                saveHistoryState(); // Sauvegarder APRÈS
                setTimeout(fitAllTables, 100);

            } catch (e) {
                console.error("Error during autoArrange:", e);
                alert("Une erreur est survenue lors de la réorganisation.");
            }
        }

        // --- NOUVELLES FONCTIONS SALLES / MURS (MODIFIÉES) ---

        function addRoom() {
            const name = document.getElementById('roomNameInput').value.trim() || "Nouvelle Salle";

            const newRoom = {
                id: nextRoomId++,
                name: name,
                x: 100,
                y: 100,
                width: 500,
                height: 500
            };

            // --- NOUVEAU: Calculer la bounding box de toutes les tables ---
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

            if (physicalTables.length > 0) {
                physicalTables.forEach(t => {
                    minX = Math.min(minX, t.x);
                    minY = Math.min(minY, t.y);
                    maxX = Math.max(maxX, t.x + (t.width || defaultTableWidth));
                    maxY = Math.max(maxY, t.y + 160); // Hauteur approx d'une table
                });

                // Marges
                const padding = 50;
                const topMargin = 80; // Un peu plus haut pour le titre

                newRoom.x = minX - padding;
                newRoom.y = minY - topMargin;
                newRoom.width = (maxX - minX) + (padding * 2);
                newRoom.height = (maxY - minY) + (padding * 2);
            } else {
                // Valeurs par défaut si pas de tables
                newRoom.x = 100;
                newRoom.y = 100;
                newRoom.width = 500;
                newRoom.height = 500;
            }

            rooms.push(newRoom);
            createRoomElement(newRoom);
            document.getElementById('roomNameInput').value = '';

            saveHistoryState(); // Sauvegarder APRÈS
        }

        function createRoomElement(room) {
            const canvas = document.getElementById('canvas');
            const element = document.createElement('div');
            element.className = 'room-element';
            element.id = `room-${room.id}`;
            element.style.left = room.x + 'px';
            element.style.top = room.y + 'px';
            element.style.width = room.width + 'px';
            element.style.height = room.height + 'px';
            element.dataset.roomId = room.id;

            element.innerHTML = `
                <div class="room-title" ondblclick="event.stopPropagation(); renameRoom(${room.id})" title="Double-cliquez pour renommer">
                    ${room.name}
                </div>
                <div class="room-delete-btn" onclick="event.stopPropagation(); deleteRoom(${room.id})">×</div>
                <div class="room-resize-handle tl" onmousedown="event.stopPropagation(); startRoomResize(event, ${room.id}, 'tl')"></div>
                <div class="room-resize-handle tr" onmousedown="event.stopPropagation(); startRoomResize(event, ${room.id}, 'tr')"></div>
                <div class="room-resize-handle bl" onmousedown="event.stopPropagation(); startRoomResize(event, ${room.id}, 'bl')"></div>
                <div class="room-resize-handle br" onmousedown="event.stopPropagation(); startRoomResize(event, ${room.id}, 'br')"></div>
            `;

            element.addEventListener('mousedown', (e) => handleRoomMouseDown(e, room.id));

            // Placer avant les tables (qui ont un z-index >= 10)
            canvas.prepend(element);
        }

        function renameRoom(roomId) {
            const room = rooms.find(r => r.id === roomId);
            if (!room) return;

            const newName = prompt("Nouveau nom pour la salle :", room.name);
            if (newName !== null && newName.trim() !== "") {
                room.name = newName.trim();
                const element = document.getElementById(`room-${roomId}`);
                if (element) {
                    element.querySelector('.room-title').textContent = room.name;
                }
                saveHistoryState(); // Sauvegarder APRÈS
            }
        }

        function deleteRoom(roomId, addToHistory = true) {
            const index = rooms.findIndex(r => r.id === roomId);
            if (index > -1) {
                rooms.splice(index, 1);
                const element = document.getElementById(`room-${roomId}`);
                if (element) {
                    element.remove();
                }

                if (addToHistory) {
                    saveHistoryState(); // Sauvegarder APRÈS
                }
            }
        }

        function renderAllRooms() {
            // D'abord, supprimer les anciens éléments de salle
            document.querySelectorAll('.room-element').forEach(el => el.remove());
            // Puis, recréer
            rooms.forEach(room => createRoomElement(room));
        }

        function handleRoomMouseDown(e, roomId) {
            if (e.target.classList.contains('room-resize-handle') || e.target.classList.contains('room-delete-btn')) return;
            if (currentTool !== 'select') return;

            clearSelection(); // Désélectionner les tables
            document.querySelectorAll('.room-element.selected').forEach(el => el.classList.remove('selected'));

            const element = document.getElementById(`room-${roomId}`);
            element.classList.add('selected');

            isDragging = true;
            const room = rooms.find(r => r.id === roomId);

            dragContext = {
                isRoom: true,
                room,
                element,
                initialX: room.x,
                initialY: room.y,
                startX: e.clientX,
                startY: e.clientY
            };

            element.style.zIndex = '5';
            e.preventDefault();
            e.stopPropagation();
        }

        function startRoomResize(e, roomId, handle) {
            isResizing = true;
            const room = rooms.find(r => r.id === roomId);
            const element = document.getElementById(`room-${roomId}`);

            const startX = e.clientX;
            const startY = e.clientY;
            const startWidth = room.width;
            const startHeight = room.height;
            const startXPos = room.x;
            const startYPos = room.y;

            function onMouseMove(e) {
                if (!isResizing) return;

                const deltaX = (e.clientX - startX) / currentZoom;
                const deltaY = (e.clientY - startY) / currentZoom;

                if (handle.includes('r')) {
                    room.width = Math.max(100, startWidth + deltaX);
                    element.style.width = room.width + 'px';
                }
                if (handle.includes('b')) {
                    room.height = Math.max(100, startHeight + deltaY);
                    element.style.height = room.height + 'px';
                }
                if (handle.includes('l')) {
                    room.width = Math.max(100, startWidth - deltaX);
                    room.x = startXPos + deltaX;
                    element.style.width = room.width + 'px';
                    element.style.left = room.x + 'px';
                }
                if (handle.includes('t')) {
                    room.height = Math.max(100, startHeight - deltaY);
                    room.y = startYPos + deltaY;
                    element.style.height = room.height + 'px';
                    element.style.top = room.y + 'px';
                }
            }

            function onMouseUp() {
                if (isResizing) {
                    saveHistoryState(); // Sauvegarder APRÈS
                }
                isResizing = false;
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }

            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            e.preventDefault();
        }


        // --- Appariements, CSV, Recherche ---

        function loadPapiFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (physicalTables.length > 0) {
                if (!confirm("Charger ce fichier PAPI remplacera les appariements de la ronde actuelle. Continuer ?")) {
                    event.target.value = '';
                    return;
                }
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    parsePapiFile(e.target.result);
                } catch (error) {
                    console.error('Error parsing PAPI file:', error);
                    alert('Erreur lors du traitement du fichier HTML: ' + error.message);
                }
            };
            reader.readAsText(file, 'ISO-8859-1');
            event.target.value = '';
        }

        function parsePapiFile(htmlContent) {
            // CORRECTION: Sauvegarde déplacée à la fin

            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlContent, 'text/html');
            const rows = doc.querySelectorAll('tr[class^="papi_small_"]');
            const pairings = {};
            let maxBoardNum = 0;

            rows.forEach(row => {
                try {
                    if (row.children.length < 10) return;

                    const player1Name = row.children[1].textContent.trim();
                    const player1Elo = row.children[2].textContent.trim().replace(/\s/g, ' ');
                    const tableInfo = row.children[5].textContent.trim();
                    const colorInfo = row.children[6].textContent.trim();
                    const player2Name = row.children[8].textContent.trim();
                    const player2Elo = row.children[9].textContent.trim().replace(/\s/g, ' ');

                    if (!tableInfo.startsWith('TABLE')) return;

                    const boardNumStr = tableInfo.replace('TABLE', '').trim();
                    const boardNum = parseInt(boardNumStr);

                    if (isNaN(boardNum) || boardNum <= 0) {
                        return;
                    }

                    if (!pairings[boardNum]) {
                        let papiWhite, papiBlack, papiWhiteElo, papiBlackElo;
                        if (colorInfo.includes('blancs')) {
                            papiWhite = player1Name;
                            papiWhiteElo = player1Elo;
                            papiBlack = player2Name;
                            papiBlackElo = player2Elo;
                        } else {
                            papiWhite = player2Name;
                            papiWhiteElo = player2Elo;
                            papiBlack = player1Name;
                            papiBlackElo = player1Elo;
                        }

                        // On stocke les joueurs selon le fichier PAPI, pas l'assignation finale
                        pairings[boardNum] = {
                            papiW: { name: papiWhite, elo: papiWhiteElo, comment: "" },
                            papiB: { name: papiBlack, elo: papiBlackElo, comment: "" }
                        };

                        if (boardNum > maxBoardNum) maxBoardNum = boardNum;
                    }
                } catch (e) {
                    console.warn('Skipped a row during PAPI parse:', e);
                }
            });

            const boardNumbers = Object.keys(pairings).map(Number).sort((a, b) => a - b);

            if (boardNumbers.length === 0) {
                alert('Aucun appariement valide trouvé dans le fichier.');
                return;
            }

            // Si la disposition est vide, on la crée
            if (physicalTables.length === 0) {
                physicalTables = [];
                document.getElementById('canvas').innerHTML = '';
                renderAllRooms(); // <-- S'assurer que les salles sont re-rendues
                nextPhysicalTableId = 1;
                nextBoardNumber = maxBoardNum + 1;

                const boardsPerTable = parseInt(document.getElementById('boardsPerTable').value) || 1;
                const physicalTablesPerRow = parseInt(document.getElementById('physicalTablesPerRow').value) || 10;
                const tableLengthCm = parseInt(document.getElementById('tableLength').value) || 180;

                const minWidthPerBoard = 150;

                const layout = getLayoutConfig();
                let currentX = layout.startX;
                let currentY = layout.startY;
                const xDir = layout.xDir;
                const yDir = layout.yDir;

                const spacingY = 160 * yDir;
                let col = 0;

                for (let i = 0; i < boardNumbers.length; i += boardsPerTable) {
                    const boardsForThisTable = boardNumbers.slice(i, i + boardsPerTable);
                    const tableWidth = Math.max(tableLengthCm * 1.2, minWidthPerBoard * boardsForThisTable.length);

                    if (col === 0) {
                        currentX = layout.startX;
                    }

                    const tableX = (xDir === 1) ? currentX : currentX - tableWidth;
                    const tableY = (yDir === 1) ? currentY : currentY - 160;

                    const physicalTable = {
                        id: nextPhysicalTableId++,
                        x: tableX,
                        y: tableY,
                        rotation: 0,
                        width: tableWidth,
                        arbiterComment: { text: "", flag: "none" },
                        boards: []
                    };

                    boardsForThisTable.forEach(boardNum => {
                        const pairingData = pairings[boardNum];

                        // Pour une nouvelle disposition, on assigne PAPI-Blanc -> Blanc
                        const finalPlayers = {
                            white: pairingData.papiW,
                            black: pairingData.papiB
                        };

                        physicalTable.boards.push({
                            boardNumber: boardNum,
                            players: finalPlayers,
                            flipped: false, // Correct, c'est un nouveau plan
                            score: { white: "", black: "" }
                        });
                    });

                    physicalTables.push(physicalTable);

                    currentX += (tableWidth + 30) * xDir;
                    col++;
                    if (col >= physicalTablesPerRow) {
                        col = 0;
                        currentY += spacingY;
                    }
                }
                setTimeout(fitAllTables, 100);

            } else {
                // La disposition existe, on fusionne les appariements
                physicalTables.forEach(pt => {
                    pt.boards.forEach(b => {
                        const pairingData = pairings[b.boardNumber];

                        if (pairingData) {
                            // --- LOGIQUE CORRIGÉE ---
                            // On assigne STRICTEMENT selon l'appariement (Blanc = Blanc)
                            // L'état 'b.flipped' ne change que l'affichage visuel, pas les données.
                            b.players = {
                                white: pairingData.papiW,
                                black: pairingData.papiB
                            };

                            // On conserve l'état 'flipped' existant pour l'affichage
                            // (on ne touche pas à b.flipped)

                            b.score = { white: "", black: "" };
                        }
                    });
                });
            }


            renderAllTables();
            updateStats();

            saveHistoryState(); // Sauvegarder APRÈS

            alert(`${boardNumbers.length} appariements chargés dans la ronde actuelle !`);
        }


        function clearPairings() {
            physicalTables.forEach(t => {
                t.boards.forEach(b => {
                    // Réinitialiser avec structure vide (Table Verte)
                    b.players = {
                        white: { name: "", elo: "", comment: "" },
                        black: { name: "", elo: "", comment: "" }
                    };
                });
            });

            renderAllTables();
            updateStats();

            saveHistoryState(); // Sauvegarder APRÈS
        }

        function searchTables() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase().trim();
            const suggestionsList = document.getElementById('search-suggestions');
            suggestionsList.innerHTML = '';

            document.querySelectorAll('.table-element').forEach(el => {
                el.style.opacity = '1';
                el.style.transform = el.style.transform.replace(/scale\([^)]*\)/, '');
                el.style.zIndex = '10'; // Retour au z-index de base
            });

            if (!searchTerm) return;

            let foundTable = null;
            const addedSuggestions = new Set(); // NOUVEAU: Éviter les doublons

            physicalTables.forEach(table => {
                const element = document.getElementById(`phys-table-${table.id}`);
                let tableMatches = false;
                table.boards.forEach(board => {
                    let matches = false;
                    let matchValue = '';
                    if (board.boardNumber.toString().toLowerCase().includes(searchTerm)) {
                        matches = true;
                        matchValue = `Échiquier ${board.boardNumber}`;
                    }
                    if (board.players) {
                        if (board.players.white.name.toLowerCase().includes(searchTerm)) {
                            matches = true;
                            matchValue = getSimplePlayerName(board.players.white.name); // MODIFIÉ
                        } else if (board.players.black.name.toLowerCase().includes(searchTerm)) {
                            matches = true;
                            matchValue = getSimplePlayerName(board.players.black.name); // MODIFIÉ
                        }
                    }
                    if (matches) {
                        tableMatches = true;
                        // MODIFIÉ: Gérer les doublons
                        if (matchValue && !addedSuggestions.has(matchValue)) {
                            const option = document.createElement('option');
                            option.value = matchValue;
                            suggestionsList.appendChild(option);
                            addedSuggestions.add(matchValue);
                        }
                    }
                });
                if (tableMatches) {
                    if (!foundTable) foundTable = table;
                    element.style.transform = 'scale(1.1)';
                    element.style.zIndex = '999';
                } else {
                    element.style.opacity = '0.3';
                }
            });
            if (foundTable) scrollToTable(foundTable);
        }
        function scrollToTable(table) {
            if (!table) return;
            const container = document.getElementById('canvasContainer');
            const containerWidth = container.clientWidth, containerHeight = container.clientHeight;
            const tableWidth = table.width || defaultTableWidth;
            const tableCenterX = (table.x + tableWidth / 2) * currentZoom;
            const tableCenterY = (table.y + 160 / 2) * currentZoom;
            container.scrollLeft = tableCenterX - containerWidth / 2;
            container.scrollTop = tableCenterY - containerHeight / 2;
        }

        // --- Sauvegarde, Chargement, PDF ---
        function clearAll() {
            if (confirm('Êtes-vous sûr de vouloir effacer TOUT le tournoi (toutes les rondes) ?')) {
                localStorage.removeItem(SAVE_KEY);
                localStorage.removeItem(SAVE_KEY_TIMESTAMP);

                physicalTables = [];
                rooms = [];
                nextPhysicalTableId = 1;
                nextRoomId = 1;
                nextBoardNumber = 1;
                historyStack = [];
                redoStack = [];

                roundsStore = {};
                currentRoundKey = 'ronde1';
                loadStateFromStore('ronde1');
                updateRoundSelector();

                document.getElementById('canvas').innerHTML = '';
                updateStats();
                saveHistoryState(); // Sauvegarder l'état vide
            }
        }

        function saveLayout() {
            saveCurrentStateToStore();
            const data = {
                roundsStore: JSON.parse(JSON.stringify(roundsStore)),
                currentRoundKey: currentRoundKey,
                arbiterPassword: arbiterPassword
            };

            Object.values(data.roundsStore).forEach(roundState => {
                if (roundState.physicalTables) {
                    roundState.physicalTables.forEach(t => {
                        delete t.mouseDownHandler;
                    });
                }
            });

            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `tournoi-plan-salles-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function loadLayout() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);

                        if (data.physicalTables) {
                            roundsStore = {
                                'ronde1': {
                                    physicalTables: data.physicalTables,
                                    rooms: data.rooms || [],
                                    nextPhysicalTableId: data.nextPhysicalTableId,
                                    nextRoomId: data.nextRoomId || 1,
                                    nextBoardNumber: data.nextBoardNumber,
                                    historyStack: [],
                                    redoStack: []
                                }
                            };
                            currentRoundKey = 'ronde1';
                            alert('Ancien fichier de plan détecté, chargé comme "Ronde 1".');
                        } else if (data.roundsStore && typeof data.roundsStore === 'object' && !Array.isArray(data.roundsStore)) {
                            roundsStore = data.roundsStore;
                            currentRoundKey = data.currentRoundKey || 'ronde1';
                            arbiterPassword = data.arbiterPassword || null;
                        } else {
                            throw new Error("Format de fichier non reconnu.");
                        }

                        // Migration
                        Object.values(roundsStore).forEach(roundState => {
                            if (!roundState.physicalTables) roundState.physicalTables = [];
                            if (!roundState.rooms) roundState.rooms = [];
                            if (!roundState.nextRoomId) roundState.nextRoomId = 1;
                            roundState.physicalTables.forEach(pt => {
                                if (!pt.arbiterComment) pt.arbiterComment = { text: "", flag: "none" };
                                pt.boards.forEach(b => {
                                    if (b.score === undefined) b.score = { white: "", black: "" };
                                    // Correction migration
                                    if (b.players && b.players.white && typeof b.players.white === 'string') {
                                        b.players = {
                                            white: { name: b.players.white, elo: (b.players.white_elo || ""), comment: "" },
                                            black: { name: b.players.black, elo: (b.players.black_elo || ""), comment: "" }
                                        };
                                    } else if (b.players) {
                                        if (b.players.white && !b.players.white.elo) b.players.white.elo = "";
                                        if (b.players.white && !b.players.white.comment) b.players.white.comment = "";
                                        if (b.players.black && !b.players.black.elo) b.players.black.elo = "";
                                        if (b.players.black && !b.players.black.comment) b.players.black.comment = "";
                                    }
                                });
                            });
                            if (!roundState.historyStack) roundState.historyStack = [];
                            if (!roundState.redoStack) roundState.redoStack = [];
                        });

                        updateRoundSelector();
                        loadStateFromStore(currentRoundKey);
                        autoSaveToLocalStorage();
                        saveHistoryState(); // Sauvegarder l'état chargé

                        alert('Tournoi chargé avec succès !');
                    } catch (error) {
                        alert('Erreur lors du chargement du fichier: ' + error.message);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        function renderAllTables() {
            document.querySelectorAll('.table-element').forEach(el => el.remove());
            physicalTables.forEach(table => createTableElement(table));
            if (typeof checkAndRedirectPlayer === 'function') {
                checkAndRedirectPlayer();
            }
        }
        

        function exportToPDF() {
            if (physicalTables.length === 0) {
                alert('Aucune table à exporter');
                return;
            }
            const totalBoards = physicalTables.reduce((acc, p) => acc + p.boards.length, 0);
            let content = `
                <html><head><title>Liste des Appariements - ${currentRoundKey.replace('r', 'R')}</title>
                    <style>
                        @media print { @page { size: A4 portrait; margin: 1cm; } }
                        body { font-family: Arial, sans-serif; padding: 20px; }
                        h1 { text-align: center; color: #2c3e50; }
                        .elo { color: #666; font-size: 0.9em; margin-left: 5px; }
                        .score { font-weight: bold; color: #c00; }
                        .lastname { font-weight: bold; text-transform: uppercase; }
                    </style>
                </head><body>
                    <h1>♟️ Appariements - ${currentRoundKey.replace('r', 'R')}</h1>
                    <p style="text-align: center; color: #666;">Nombre d'échiquiers: ${totalBoards}</p>
                    
                    <div class="pairing-list">
                        <table style="width: 100%; border-collapse: collapse; margin-top: 20px;">
                            <thead><tr style="background: #f0f0f0;">
                                <th style="border: 1px solid #ddd; padding: 8px;">Éch.</th>
                                <th style="border: 1px solid #ddd; padding: 8px;">Joueur Blancs</th>
                                <th style="border: 1px solid #ddd; padding: 8px;">Score</th>
                                <th style="border: 1px solid #ddd; padding: 8px;">Joueur Noirs</th>
                                <th style="border: 1px solid #ddd; padding: 8px;">Score</th>
                            </tr></thead><tbody>`;
            const allBoards = [];
            physicalTables.forEach(t => t.boards.forEach(b => allBoards.push(b)));
            allBoards.sort((a, b) => {
                let numA = parseFloat(a.boardNumber);
                let numB = parseFloat(b.boardNumber);
                if (isNaN(numA)) numA = Infinity;
                if (isNaN(numB)) numB = Infinity;
                if (numA !== numB) return numA - numB;
                return String(a.boardNumber).localeCompare(String(b.boardNumber));
            });

            allBoards.forEach(board => {
                const whiteName = board.players ? formatPlayerName(board.players.white.name) : '-';
                const whiteElo = board.players ? board.players.white.elo : '';
                const blackName = board.players ? formatPlayerName(board.players.black.name) : '-';
                const blackElo = board.players ? board.players.black.elo : '';
                const whiteScore = board.score ? board.score.white : '';
                const blackScore = board.score ? board.score.black : '';

                content += `<tr>
                        <td style="border: 1px solid #ddd; padding: 8px; text-align: center; font-weight: bold;">${board.boardNumber}</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">
                            ${whiteName} <span class="elo">(${whiteElo})</span>
                        </td>
                        <td style="border: 1px solid #ddd; padding: 8px; text-align: center; font-weight: bold;">${whiteScore}</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">
                            ${blackName} <span class="elo">(${blackElo})</span>
                        </td>
                        <td style="border: 1px solid #ddd; padding: 8px; text-align: center; font-weight: bold;">${blackScore}</td>
                    </tr>`;
            });
            content += `</tbody></table></div></body></html>`;
            const printWindow = window.open('', '', 'height=800,width=1000');
            printWindow.document.write(content);
            printWindow.document.close();
            printWindow.focus();
            // MODIFIÉ: Ligne d'impression automatique supprimée
            // setTimeout(() => { printWindow.print(); }, 250); 
        }

        // --- EXPORT PDF VISUEL (CORRIGÉ POUR HAUTE RÉSOLUTION / MULTI-PAGE) ---
        function showLoading(isLoading) {
            const overlay = document.getElementById('loadingOverlay');
            overlay.style.display = isLoading ? 'flex' : 'none';
        }

        async function exportVisualPDF() {
            let jsPDF;
            try {
                jsPDF = window.jspdf.jsPDF;
            } catch (e) {
                console.error("Erreur: La bibliothèque jsPDF n'a pas pu être chargée.", e);
                alert("Erreur: La bibliothèque jsPDF n'a pas pu être chargée. Vérifiez votre connexion internet ou un bloqueur de publicité.");
                return;
            }

            if (physicalTables.length === 0 && rooms.length === 0) {
                alert('Rien à exporter');
                return;
            }

            showLoading(true);
            clearSelection();
            document.querySelectorAll('.room-element.selected').forEach(el => el.classList.remove('selected'));

            const orientation = document.getElementById('pdfOrientation').value;
            const canvasElement = document.getElementById('canvas');

            // MODIFIÉ: Sauvegarder le transform (zoom) actuel
            const originalTransform = canvasElement.style.transform;

            // MODIFIÉ: Réinitialiser le zoom pour la capture
            canvasElement.style.transform = 'scale(1)';

            await new Promise(resolve => setTimeout(resolve, 50)); // Attendre que le style s'applique

            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

            physicalTables.forEach(t => {
                minX = Math.min(minX, t.x);
                minY = Math.min(minY, t.y);

                const radians = t.rotation * Math.PI / 180;
                const cos = Math.cos(radians);
                const sin = Math.sin(radians);
                const width = t.width || defaultTableWidth;
                const height = 160;

                const xCoords = [t.x, t.x + width * cos, t.x - height * sin, t.x + width * cos - height * sin];
                const yCoords = [t.y, t.y + width * sin, t.y + height * cos, t.y + width * sin + height * cos];

                maxX = Math.max(maxX, ...xCoords);
                maxY = Math.max(maxY, ...yCoords);
            });

            rooms.forEach(r => {
                minX = Math.min(minX, r.x);
                minY = Math.min(minY, r.y);
                maxX = Math.max(maxX, r.x + r.width);
                maxY = Math.max(maxY, r.y + r.height);
            });


            if (minX === Infinity) {
                showLoading(false);
                canvasElement.style.transform = originalTransform; // Restaurer
                return;
            }

            const padding = 50;
            const contentWidth = (maxX - minX) + (padding * 2);
            const contentHeight = (maxY - minY) + (padding * 2);

            html2canvas(canvasElement, {
                logging: false,
                useCORS: true,
                width: contentWidth,
                height: contentHeight,
                x: minX - padding,
                y: minY - padding,
                scale: 2, // Garder une bonne résolution
                backgroundColor: '#ecf0f1', // Fond du canvas
                removeContainer: true
            }).then(canvasImage => {
                const imgData = canvasImage.toDataURL('image/png');

                const pdf = new jsPDF({
                    orientation: orientation,
                    unit: 'mm',
                    format: 'a4'
                });

                const margin = 10;

                const pageFormats = {
                    'a4': { 'p': { w: 210, h: 297 }, 'l': { w: 297, h: 210 } }
                };

                // MODIFIÉ: Calcul des dimensions de la page
                const pageW_mm = pageFormats['a4'][orientation].w;
                const pageH_mm = pageFormats['a4'][orientation].h;
                const innerPageW_mm = pageW_mm - (margin * 2);
                const innerPageH_mm = pageH_mm - (margin * 2);

                const imgW_px = canvasImage.width;
                const imgH_px = canvasImage.height;

                // MODIFIÉ: Calcul de l'échelle et centrage
                const imgRatio = imgW_px / imgH_px;
                const pageRatio = innerPageW_mm / innerPageH_mm;

                let finalImgW_mm, finalImgH_mm;
                if (imgRatio > pageRatio) {
                    // L'image est plus large que la page
                    finalImgW_mm = innerPageW_mm;
                    finalImgH_mm = innerPageW_mm / imgRatio;
                } else {
                    // L'image est plus haute que la page
                    finalImgH_mm = innerPageH_mm;
                    finalImgW_mm = innerPageH_mm * imgRatio;
                }

                // Calcul du centrage
                const posX = margin + (innerPageW_mm - finalImgW_mm) / 2;
                const posY = margin + (innerPageH_mm - finalImgH_mm) / 2;

                pdf.addImage(imgData, 'PNG', posX, posY, finalImgW_mm, finalImgH_mm);

                pdf.save(`plan-de-salle-${currentRoundKey}-${Date.now()}.pdf`);

            }).catch(err => {
                console.error('Erreur lors de la génération du PDF:', err);
                alert('Une erreur est survenue lors de la création du PDF visuel.');
            }).finally(() => {
                showLoading(false);
                // MODIFIÉ: Restaurer le zoom
                canvasElement.style.transform = originalTransform;
            });
        }

        // ... (après la fonction syncWithPAPI)

        /**
         * Exporte TOUT le tournoi (toutes les rondes) au format TRF 1.1 de la FIDE.
         * Ce format est un fichier texte à largeur fixe.
         */
        function exportToTRF() {
            if (Object.keys(roundsStore).length === 0) {
                alert("Aucune donnée de tournoi à exporter.");
                return;
            }

            // --- 1. Collecter tous les joueurs et toutes les rondes ---
            const masterPlayerList = {}; // { "NOM Prénom": { id: 0, name: "", elo: 0, points: 0, games: [] } }
            const playerMap = new Map(); // Map<"NOM Prénom", id>
            const allRoundKeys = Object.keys(roundsStore).sort((a, b) => {
                return parseInt(a.replace('ronde', '')) - parseInt(b.replace('ronde', ''));
            });
            const numRounds = allRoundKeys.length;

            // Fonction pour normaliser le nom (pour servir de clé unique)
            const normalizeName = (name) => (name || "").trim().toUpperCase();

            // Première passe : découvrir tous les joueurs
            let playerIdCounter = 1;
            for (const roundKey of allRoundKeys) {
                const roundData = roundsStore[roundKey];
                if (!roundData.physicalTables) continue;

                for (const table of roundData.physicalTables) {
                    for (const board of table.boards) {
                        if (board.players) {
                            const pWhiteName = normalizeName(board.players.white.name);
                            const pBlackName = normalizeName(board.players.black.name);

                            if (pWhiteName && !playerMap.has(pWhiteName)) {
                                playerMap.set(pWhiteName, playerIdCounter);
                                masterPlayerList[pWhiteName] = {
                                    id: playerIdCounter++,
                                    name: board.players.white.name, // Garde le nom original
                                    elo: board.players.white.elo || 0,
                                    points: 0,
                                    games: [] // [ { round: 1, oppId: 2, color: 'w', result: '+' }, ... ]
                                };
                            }
                            if (pBlackName && !playerMap.has(pBlackName)) {
                                playerMap.set(pBlackName, playerIdCounter);
                                masterPlayerList[pBlackName] = {
                                    id: playerIdCounter++,
                                    name: board.players.black.name, // Garde le nom original
                                    elo: board.players.black.elo || 0,
                                    points: 0,
                                    games: []
                                };
                            }
                        }
                    }
                }
            }

            const numPlayers = playerMap.size;
            if (numPlayers === 0) {
                alert("Aucun joueur apparié trouvé dans le tournoi.");
                return;
            }

            // --- 2. Seconde passe : collecter tous les résultats et calculer les points ---
            let roundCounter = 1;
            for (const roundKey of allRoundKeys) {
                const roundData = roundsStore[roundKey];
                if (!roundData.physicalTables) continue;

                for (const table of roundData.physicalTables) {
                    for (const board of table.boards) {
                        if (board.players) {
                            const pWhiteName = normalizeName(board.players.white.name);
                            const pBlackName = normalizeName(board.players.black.name);
                            const pWhiteId = playerMap.get(pWhiteName);
                            const pBlackId = playerMap.get(pBlackName);

                            let whiteResultChar = ' ';
                            let blackResultChar = ' ';
                            let whitePoints = 0;
                            let blackPoints = 0;

                            const sWhite = board.score.white;
                            const sBlack = board.score.black;

                            if (sWhite === '1') { whiteResultChar = '+'; whitePoints = 1; }
                            if (sBlack === '1') { blackResultChar = '+'; blackPoints = 1; }
                            if (sWhite === '0') { whiteResultChar = '-'; }
                            if (sBlack === '0') { blackResultChar = '-'; }
                            if (sWhite === '1/2' || sBlack === '1/2') {
                                whiteResultChar = '='; whitePoints = 0.5;
                                blackResultChar = '='; blackPoints = 0.5;
                            }
                            // Gérer les forfaits (PAPI F-1 vs TRF -)
                            if (sWhite === 'F') { whiteResultChar = '-'; }
                            if (sBlack === 'F') { blackResultChar = '-'; }
                            if (sWhite === '1' && sBlack === 'F') { blackResultChar = '-'; } // F-1
                            if (sBlack === '1' && sWhite === 'F') { whiteResultChar = '-'; } // 1-F

                            // TRF n'a pas de 0-0, c'est F-F (double -)
                            if (sWhite === '0' && sBlack === '0') {
                                whiteResultChar = '-'; blackResultChar = '-';
                            }

                            if (masterPlayerList[pWhiteName]) {
                                masterPlayerList[pWhiteName].points += whitePoints;
                                masterPlayerList[pWhiteName].games[roundCounter - 1] = {
                                    oppId: pBlackId,
                                    color: 'w',
                                    result: whiteResultChar
                                };
                            }
                            if (masterPlayerList[pBlackName]) {
                                masterPlayerList[pBlackName].points += blackPoints;
                                masterPlayerList[pBlackName].games[roundCounter - 1] = {
                                    oppId: pWhiteId,
                                    color: 'b',
                                    result: blackResultChar
                                };
                            }
                        }
                    }
                }
                roundCounter++;
            }

            // --- 3. Trier les joueurs (par points DESC, puis nom ASC) ---
            const sortedPlayers = Object.values(masterPlayerList).sort((a, b) => {
                if (b.points !== a.points) {
                    return b.points - a.points;
                }
                return a.name.localeCompare(b.name);
            });

            // --- 4. Construire le fichier TRF ---
            let trfContent = "";
            const today = new Date().toISOString().split('T')[0].replace(/-/g, '.');

            // En-têtes (0xx)
            // MODIF: Utiliser une valeur par défaut si tournamentName n'existe plus
            trfContent += "001 " + ("Tournoi ChessRoom").padEnd(60) + "\n";
            trfContent += "010 Lieu Inconnu\n";
            trfContent += "011 FRA\n"; // Placeholder
            trfContent += "012 " + today + "\n"; // Placeholder date début
            trfContent += "013 " + today + "\n"; // Placeholder date fin
            trfContent += "014 " + numPlayers + "\n";
            trfContent += "015 " + numPlayers + "\n"; // Nb joueurs comptant ELO
            trfContent += "016 " + numRounds + "\n";
            trfContent += "021 Arbitre Principal\n"; // Placeholder
            trfContent += "031 10m+0s\n"; // Placeholder
            trfContent += "112 FIDE-Official Rating list used\n";

            // Lignes des joueurs (format principal)
            sortedPlayers.forEach((player, index) => {
                let line = "";
                const rank = index + 1;
                const pointsStr = (player.points % 1 === 0) ? `${player.points}.0` : `${player.points}`;

                line += String(rank).padStart(4) + " ";             // Rang
                line += " ";                                       // Sexe (placeholder)
                line += player.name.padEnd(33) + " ";              // Nom
                line += String(player.elo || 0).padStart(4) + " "; // ELO
                line += "FRA ";                                    // Féd (placeholder)
                line += pointsStr.padStart(4) + " ";               // Points
                line += String(rank).padStart(4) + "  ";           // Rang (bis)

                // Boucle des rondes
                for (let r = 0; r < numRounds; r++) {
                    const game = player.games[r];
                    if (game) {
                        // Ex: " 123 w +"
                        line += String(game.oppId || 0).padStart(5) + " ";
                        line += (game.color || " ") + " ";
                        line += (game.result || " ") + "  ";
                    } else {
                        // Pas de partie (bye, ou joueur absent)
                        // Placeholder pour un BYE 1pt
                        if (player.games.length < numRounds) {
                            line += "    0 w +  ";
                            // TODO: Améliorer la gestion du bye (il faudrait le stocker)
                        } else {
                            line += "             "; // Espace vide
                        }
                    }
                }
                trfContent += line.trimEnd() + "\n";
            });

            // --- 5. Télécharger le fichier ---
            const blob = new Blob([trfContent], { type: 'text/plain;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);

            link.setAttribute("href", url);
            link.setAttribute("download", "tournoi.trf");
            link.style.visibility = 'hidden';
            document.body.appendChild(link);

            link.click();

            document.body.removeChild(link);

            showNotification('Export TRF (FIDE) terminé !', 'success');
        }

        // --- Stats, Zoom, etc. ---
        function updateStats() {
            let totalBoards = 0, pairedBoards = 0, remainingBoards = 0;

            physicalTables.forEach(t => {
                totalBoards += t.boards.length;
                t.boards.forEach(b => {
                    // CORRECTION: On ne compte que si un nom est présent
                    if (b.players && (b.players.white.name || b.players.black.name)) {
                        pairedBoards++;

                        if (b.score.white === '' && b.score.black === '') {
                            remainingBoards++;
                        }
                    }
                });
            });

            document.getElementById('totalBoards').textContent = totalBoards;
            document.getElementById('pairedBoards').textContent = pairedBoards;
            document.getElementById('totalPlayers').textContent = pairedBoards * 2;
            document.getElementById('remainingBoards').textContent = remainingBoards;
        }

        function resetZoom() { applyZoom(1); }
        function fitAllTables() {
            if (physicalTables.length === 0 && rooms.length === 0) return resetZoom();
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

            physicalTables.forEach(t => {
                minX = Math.min(minX, t.x); minY = Math.min(minY, t.y);
                maxX = Math.max(maxX, t.x + (t.width || defaultTableWidth));
                maxY = Math.max(maxY, t.y + 160);
            });

            rooms.forEach(r => {
                minX = Math.min(minX, r.x); minY = Math.min(minY, r.y);
                maxX = Math.max(maxX, r.x + r.width);
                maxY = Math.max(maxY, r.y + r.height);
            });

            if (minX === Infinity) return resetZoom();

            const container = document.getElementById('canvasContainer');
            const cWidth = container.clientWidth, cHeight = container.clientHeight;
            const contentWidth = maxX - minX, contentHeight = maxY - minY;
            const padding = 50;
            const zoomX = (cWidth - padding * 2) / contentWidth;
            const zoomY = (cHeight - padding * 2) / contentHeight;
            let newZoom = Math.min(zoomX, zoomY);
            newZoom = Math.max(0.1, Math.min(2.0, newZoom));
            applyZoom(newZoom);
            const contentCenterX = (minX + maxX) / 2, contentCenterY = (minY + maxY) / 2;
            container.scrollLeft = (contentCenterX * currentZoom) - (cWidth / 2);
            container.scrollTop = (contentCenterY * currentZoom) - (cHeight / 2);
        }
        function applyZoom(newZoom) {
            if (newZoom) {
                currentZoom = newZoom;
            }
            currentZoom = Math.max(0.1, Math.min(2.0, currentZoom));

            const canvas = document.getElementById('canvas');
            canvas.style.transform = `scale(${currentZoom})`;

            document.getElementById('zoomLevel').textContent = Math.round(currentZoom * 100) + '%';
            document.getElementById('zoomSlider').value = currentZoom * 100;
        }

        // --- Écouteurs Globaux (Souris, Clavier) ---
        document.addEventListener('mousemove', (e) => {
            if (movingBoard) {
                moveGhost(e);
            }
            if (isDragging && dragContext.isRoom) {
                const dx = (e.clientX - dragContext.startX) / currentZoom;
                const dy = (e.clientY - dragContext.startY) / currentZoom;

                const newX = Math.max(0, dragContext.initialX + dx);
                const newY = Math.max(0, dragContext.initialY + dy);

                dragContext.room.x = newX;
                dragContext.room.y = newY;
                dragContext.element.style.left = newX + 'px';
                dragContext.element.style.top = newY + 'px';
            }
            else if (isDragging && currentTool === 'select' && !isResizing && dragContext.tables) {
                const dx = (e.clientX - dragContext.startX) / currentZoom;
                const dy = (e.clientY - dragContext.startY) / currentZoom;
                dragContext.tables.forEach(item => {
                    const newX = Math.max(0, item.initialX + dx);
                    const newY = Math.max(0, item.initialY + dy);
                    item.table.x = newX;
                    item.table.y = newY;
                    item.element.style.left = newX + 'px';
                    item.element.style.top = newY + 'px';
                });
            }
            if (selectionBox.active && currentTool === 'multiselect') {
                const container = document.getElementById('canvasContainer');
                const containerRect = container.getBoundingClientRect();
                const currentX = (e.clientX - containerRect.left + container.scrollLeft) / currentZoom;
                const currentY = (e.clientY - containerRect.top + container.scrollTop) / currentZoom;
                const x = Math.min(selectionBox.startX, currentX);
                const y = Math.min(selectionBox.startY, currentY);
                const width = Math.abs(currentX - selectionBox.startX);
                const height = Math.abs(currentY - selectionBox.startY);
                if (selectionBox.element) {
                    selectionBox.element.style.left = x + 'px';
                    selectionBox.element.style.top = y + 'px';
                    selectionBox.element.style.width = width + 'px';
                    selectionBox.element.style.height = height + 'px';
                }
                if (!e.ctrlKey && !e.metaKey) clearSelection();
                physicalTables.forEach(table => {
                    const tableWidth = table.width || defaultTableWidth;
                    if (table.x < x + width && table.x + tableWidth > x &&
                        table.y < y + height && table.y + 180 > y) {
                        selectTable(table.id);
                    }
                });
            }
            if (canvasDrag.active && currentTool === 'pan') {
                const container = document.getElementById('canvasContainer');
                const dx = e.clientX - canvasDrag.startX;
                const dy = e.clientY - canvasDrag.startY;
                container.scrollLeft = canvasDrag.scrollLeft - dx;
                container.scrollTop = canvasDrag.scrollTop - dy;
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (movingBoard) {
                let dropTargetTableEl = e.target.closest('.table-element');
                if (dropTargetTableEl) {
                    const targetTableId = parseInt(dropTargetTableEl.dataset.tableId);
                    const targetTable = physicalTables.find(t => t.id === targetTableId);

                    const { board: movedBoard, physicalTable: originalTable } = findBoard(movingBoard.boardNumber);
                    if (movedBoard && originalTable) {
                        const originalIndex = originalTable.boards.findIndex(b => b.boardNumber.toString() === movingBoard.boardNumber.toString());

                        if (originalIndex > -1) {
                            const [boardToMove] = originalTable.boards.splice(originalIndex, 1);

                            const targetBoardEl = e.target.closest('.board-container');
                            let targetIndex = targetTable.boards.length;

                            if (targetBoardEl && targetTableId === parseInt(targetBoardEl.closest('.table-element').dataset.tableId)) {
                                const targetBoardNumStr = targetBoardEl.dataset.boardNumber;
                                targetIndex = targetTable.boards.findIndex(b => b.boardNumber.toString() === targetBoardNumStr);
                                if (targetIndex === -1) targetIndex = targetTable.boards.length;
                            }

                            targetTable.boards.splice(targetIndex, 0, boardToMove);

                            if (originalTable.id !== targetTable.id) {
                                updateTableDisplay(originalTable.id);
                            }
                            updateTableDisplay(targetTable.id);
                            updateStats();

                            saveHistoryState(); // Sauvegarder APRÈS
                        }
                    }
                }

                if (movingBoard.element) {
                    document.body.removeChild(movingBoard.element);
                }
                movingBoard = null;
                isDragging = false;
                document.querySelectorAll('.table-element, .board-container').forEach(el => {
                    el.removeEventListener('mouseenter', handleTableDropEnter);
                    el.removeEventListener('mouseleave', handleTableDropLeave);
                    el.classList.remove('over');
                    if (el.classList.contains('table-element') && !selectedTables.includes(parseInt(el.dataset.tableId))) {
                        el.classList.remove('selected');
                    }
                });
            }
            if (isDragging) {
                if (dragContext.isRoom) {
                    if (dragContext.room.x !== dragContext.initialX || dragContext.room.y !== dragContext.initialY) {
                        saveHistoryState(); // Sauvegarder APRÈS
                    }
                    dragContext.element.style.zIndex = '5';
                }
                else {
                    const moved = dragContext.tables && dragContext.tables.some(item =>
                        item.table.x !== item.initialX || item.table.y !== item.initialY
                    );
                    if (moved) {
                        saveHistoryState(); // Sauvegarder APRÈS
                    }
                    if (dragContext.tables) {
                        dragContext.tables.forEach(item => {
                            if (item.element) item.element.style.zIndex = '10';
                        });
                    }
                }
                dragContext = {};
            }
            isDragging = false;
            canvasDrag.active = false;
            if (selectionBox.active) {
                if (selectionBox.element) selectionBox.element.remove();
                selectionBox.element = null;
                selectionBox.active = false;
            }
        });

        document.getElementById('canvas').addEventListener('mousedown', (e) => {
            if (e.target.id === 'canvas' || e.target.classList.contains('canvas')) {
                // MODIFIÉ: Autoriser le 'pan' en mode plan joueur
                if (currentTool === 'pan') {
                    canvasDrag.active = true;
                    canvasDrag.startX = e.clientX;
                    canvasDrag.startY = e.clientY;
                    const container = document.getElementById('canvasContainer');
                    canvasDrag.scrollLeft = container.scrollLeft;
                    canvasDrag.scrollTop = container.scrollTop;
                    e.preventDefault();
                } else if (currentTool === 'multiselect' && !isPlayerMode) { // Désactiver en mode joueur
                    const container = document.getElementById('canvasContainer');
                    const containerRect = container.getBoundingClientRect();
                    const canvas = document.getElementById('canvas');
                    selectionBox.active = true;
                    selectionBox.startX = (e.clientX - containerRect.left + container.scrollLeft) / currentZoom;
                    selectionBox.startY = (e.clientY - containerRect.top + container.scrollTop) / currentZoom;
                    const box = document.createElement('div');
                    box.className = 'selection-box';
                    box.style.left = selectionBox.startX + 'px';
                    box.style.top = selectionBox.startY + 'px';
                    box.style.width = '0px';
                    box.style.height = '0px';
                    canvas.appendChild(box);
                    selectionBox.element = box;
                    e.preventDefault();
                }
            }
        });

        document.getElementById('canvas').addEventListener('click', (e) => {
            if ((e.target.id === 'canvas' || e.target.classList.contains('canvas-container')) && currentTool !== 'multiselect') {
                clearSelection();
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.target.tagName.toLowerCase() === 'input' || e.target.tagName.toLowerCase() === 'textarea' || e.target.tagName.toLowerCase() === 'select') return;

            // MODIFIÉ: Gestion Echap améliorée
            if (e.key === 'Escape') {
                if (document.getElementById('simplifiedScoreModal').style.display === 'flex') {
                    closeSimplifiedScoreModal();
                } else if (isPlayerMode && document.body.classList.contains('player-plan-view-mode')) {
                    returnToPlayerHome();
                } else if (document.querySelector('.modal-overlay[style*="display: flex"]')) {
                    hideScoreModal();
                    cancelQRValidation();
                    stopQRScanner();
                    document.getElementById('arbiterPassModal').style.display = 'none';
                    document.getElementById('playerLoginModal').style.display = 'none';
                    closePlayerLogoutConfirm();
                    closePlayerTextSearch();
                    closePlayerListSearch();
                } else {
                    clearSelection();
                }
                return;
            }

            // NOUVEAU: Désactiver les raccourcis en mode joueur
            if (isPlayerMode || (window.currentSaveMode && window.currentSaveMode === 'spectator')) return;

            if (document.getElementById('scoreModal').style.display === 'flex') return;

            if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); }
            if ((e.ctrlKey || e.metaKey) && e.key === 'y') { e.preventDefault(); redo(); }

            if ((e.key === 'Delete' || e.key === 'Backspace')) {
                const selectedRoom = document.querySelector('.room-element.selected');

                if (selectedTables.length > 0) {
                    e.preventDefault();
                    deleteSelected();
                } else if (selectedRoom) {
                    e.preventDefault();
                    deleteRoom(parseInt(selectedRoom.dataset.roomId));
                }
            }

            if (e.key === 'd' && (e.ctrlKey || e.metaKey) && selectedTables.length > 0) { e.preventDefault(); duplicateSelected(); }
            if (e.key === 'r' && selectedTables.length > 0) rotateSelected();
            if (e.key === 'p') setTool('pan');
            if (e.key === 's' && !e.ctrlKey && !e.metaKey) setTool('select');
            if (e.key === 'm') setTool('multiselect');
            if (e.key === 'a' && (e.ctrlKey || e.metaKey)) { e.preventDefault(); clearSelection(); physicalTables.forEach(t => selectTable(t.id)); }
        });

        // =====================================================
        //  LOGIQUE QR CODE INTÉGRÉE
        // =====================================================

        // --- Variables globales pour le scanner ---
        let qrStream = null;
        let qrScanInterval = null;
        let qrStagedResult = null; // Résultat en attente de validation
        // CORRECTION: Distinguer le type de scan
        let currentScanMode = 'RESULT'; // 'RESULT' ou 'PLAYER_ID'

        // --- Fonction de Notification ---
        function showNotification(message, type = 'success') {
            const notif = document.getElementById('notification');
            if (!notif) return;
            notif.textContent = message;
            notif.className = `notification ${type} show`;
            setTimeout(() => notif.classList.remove('show'), 3000);
        }

        // --- Fonction de formatage (utilitaire) ---
        function formatResult(result) {
            return result === 'DRAW' ? '½-½' : result;
        }

        // --- 1. Logique de GÉNÉRATION de fiches QR ---

        function generateQRFiches() {
            const num = parseInt(document.getElementById('qrNumTables').value);
            if (isNaN(num) || num < 1 || num > 2000) {
                showNotification('Nombre invalide (1-2000)', 'error');
                return;
            }

            const results = ['1-0', 'DRAW', '0-1'];
            const labels = ['✅ Blancs gagnent', '⚖️ Nulle', '❌ Noirs gagnent'];
            let htmlContent = `
                <!DOCTYPE html><html lang="fr"><head><meta charset="UTF-8">
                <title>Fiches QR - ${num} tables</title>
                <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"><\/script>
                <style>
                    body { font-family: sans-serif; }
                    .qr-set { 
                        border: 3px solid #333; border-radius: 12px; 
                        padding: 20px; margin: 20px; 
                        page-break-inside: avoid; 
                    }
                    .qr-set h3 { text-align: center; font-size: 24px; margin: 0 0 20px 0; padding-bottom: 10px; border-bottom: 2px solid #ddd; }
                    .qr-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; text-align: center; }
                    .qr-item p { font-weight: 600; margin-top: 10px; }
                    @media print {
                        body { margin: 0; }
                        .qr-set { margin: 10px; }
                    }
                </style>
                </head><body>
            `;

            // Générer la structure HTML
            for (let i = 1; i <= num; i++) {
                htmlContent += `
                    <div class="qr-set">
                        <h3>Table ${i}</h3>
                        <div class="qr-grid">`;
                results.forEach((result, idx) => {
                    htmlContent += `
                        <div class="qr-item">
                            <div id="qr-${i}-${idx}"></div> 
                            <p>${labels[idx]}</p>
                        </div>`;
                });
                htmlContent += `</div></div>`;
            }

            // Ajouter le script qui va générer les QR codes au chargement de la page d'impression
            htmlContent += `
                <script>
                    window.onload = () => {
                        for (let i = 1; i <= ${num}; i++) {
                            const results = ['1-0', 'DRAW', '0-1'];
                            results.forEach((result, idx) => {
                                const qrData = JSON.stringify({ type: 'result', table: i, result });
                                try {
                                    new QRCode(document.getElementById(\`qr-\${i}-\${idx}\`), {
                                        text: qrData,
                                        width: 128,
                                        height: 128,
                                        colorDark: "#333"
                                    });
                                } catch(e) { console.error(e); }
                            });
                        }
                        
                        // Lancer l'impression
                        setTimeout(() => window.print(), 500);
                    };
                <\/script>
            `;

            htmlContent += `</body></html>`;

            // Ouvrir dans une nouvelle fenêtre
            const printWindow = window.open('', '_blank');
            printWindow.document.write(htmlContent);
            printWindow.document.close();
            showNotification(`${num} fiches générées`, 'success');
        }

        // --- NOUVELLE FONCTION: Générer les QR-codes d'identification des joueurs ---
        function generatePlayerQRCodes() {

            // Récupérer tous les joueurs de la ronde 1
            if (!roundsStore['ronde1']) {
                showNotification('Aucune ronde 1 trouvée. Importez d\'abord les appariements.', 'error');
                return;
            }

            const ronde1State = roundsStore['ronde1'];
            const players = [];

            // Parcourir tous les échiquiers de la ronde 1 pour extraire les joueurs
            ronde1State.physicalTables.forEach(pt => {
                pt.boards.forEach(board => {
                    if (board.players) {
                        // Ajouter le joueur blanc
                        if (board.players.white && board.players.white.name) {
                            const whiteName = board.players.white.name.trim();
                            const whiteElo = board.players.white.elo || '';
                            if (!players.find(p => p.name === whiteName)) {
                                players.push({ name: whiteName, elo: whiteElo });
                            }
                        }
                        // Ajouter le joueur noir
                        if (board.players.black && board.players.black.name) {
                            const blackName = board.players.black.name.trim();
                            const blackElo = board.players.black.elo || '';
                            if (!players.find(p => p.name === blackName)) {
                                players.push({ name: blackName, elo: blackElo });
                            }
                        }
                    }
                });
            });

            if (players.length === 0) {
                showNotification('Aucun joueur trouvé dans la ronde 1. Importez d\'abord les appariements.', 'error');
                return;
            }

            // Trier les joueurs par nom
            players.sort((a, b) => a.name.localeCompare(b.name));

            // Créer le HTML pour l'impression
            let htmlContent = `
                <!DOCTYPE html><html lang="fr"><head><meta charset="UTF-8">
                <title>QR-codes Joueurs - ${players.length} joueurs</title>
                <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"><\/script>
                <style>
                    body { 
                        font-family: Arial, sans-serif; 
                        padding: 20px;
                    }
                    .qr-grid { 
                        display: grid; 
                        grid-template-columns: repeat(4, 1fr); 
                        gap: 15px;
                        page-break-inside: avoid;
                    }
                    .qr-item { 
                        border: 2px dashed #333; 
                        padding: 15px; 
                        text-align: center;
                        page-break-inside: avoid;
                        background: white;
                    }
                    .qr-item h4 { 
                        margin: 10px 0 5px 0; 
                        font-size: 14px;
                        word-wrap: break-word;
                    }
                    .qr-item .elo { 
                        font-size: 12px; 
                        color: #666; 
                        margin: 5px 0;
                    }
                    .qr-item .instructions {
                        font-size: 10px;
                        color: #999;
                        margin-top: 5px;
                        font-style: italic;
                    }
                    h1 {
                        text-align: center;
                        margin-bottom: 30px;
                        color: #2c3e50;
                    }
                    @media print {
                        body { margin: 10mm; }
                        .qr-grid { gap: 10px; }
                        .qr-item { padding: 10px; }
                    }
                </style>
                </head><body>
                <h1>🎫 QR-codes d'Identification des Joueurs</h1>
                <p style="text-align: center; margin-bottom: 20px; color: #666;">
                    Découpez et distribuez ces QR-codes aux joueurs pour qu'ils puissent rapidement trouver leur table.
                </p>
                <div class="qr-grid">
            `;

            // Générer un QR-code pour chaque joueur
            players.forEach((player, index) => {
                const qrData = JSON.stringify({
                    type: 'player',
                    name: player.name,
                    elo: player.elo
                });

                htmlContent += `
                    <div class="qr-item">
                        <div id="player-qr-${index}"></div>
                        <h4>${escapeHtml(player.name)}</h4>
                        ${player.elo ? `<div class="elo">Élo: ${player.elo}</div>` : ''}
                        <div class="instructions">Scanner pour trouver ma table</div>
                    </div>
                `;
            });

            htmlContent += `
                </div>
                <script>
                    window.onload = () => {
                        const players = ${JSON.stringify(players)};
                        players.forEach((player, index) => {
                            const qrData = JSON.stringify({ 
                                type: 'player', 
                                name: player.name,
                                elo: player.elo 
                            });
                            try {
                                new QRCode(document.getElementById(\`player-qr-\${index}\`), {
                                    text: qrData,
                                    width: 100,
                                    height: 100,
                                    colorDark: "#000000",
                                    colorLight: "#ffffff"
                                });
                            } catch(e) { 
                                console.error('Erreur QR-code:', e); 
                            }
                        });
                        
                        // Lancer l'impression après génération
                        setTimeout(() => window.print(), 1000);
                    };
                <\/script>
            </body></html>`;

            // Ouvrir dans une nouvelle fenêtre
            const printWindow = window.open('', '_blank');
            printWindow.document.write(htmlContent);
            printWindow.document.close();
            showNotification(`${players.length} QR-codes joueurs générés`, 'success');
        }

        // Fonction helper pour échapper le HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }


        // --- 2. Logique de SCAN de QR Code ---

        // CORRECTION: Fonction unifiée pour démarrer le scanner
        async function startGenericQRScanner(scanMode) {
            // scanMode: 'RESULT' (défaut) ou 'PLAYER_ID'
            currentScanMode = scanMode || 'RESULT';

            if (isPlayerMode) {
                document.getElementById('playerHomeModal').style.display = 'none';
            }

            const modal = document.getElementById('qrScannerModal');
            modal.style.display = 'flex';

            const video = document.getElementById('qrVideo');

            try {
                qrStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: { ideal: "environment" },
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    }
                });

                video.srcObject = qrStream;
                await video.play();

                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');

                qrScanInterval = setInterval(() => {
                    if (video.readyState === video.HAVE_ENOUGH_DATA) {
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        context.drawImage(video, 0, 0, canvas.width, canvas.height);

                        const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
                        const code = jsQR(imageData.data, imageData.width, imageData.height);

                        if (code && code.data) {
                            clearInterval(qrScanInterval);
                            onScanSuccess(code.data); // La gestion se fait dans onScanSuccess
                        }
                    }
                }, 300);

            } catch (err) {
                console.error('Erreur caméra:', err);
                showNotification("Erreur caméra. Autorisez l'accès.", 'error');
                stopQRScanner();
            }
        }

        // Wrapper pour l'ancien bouton "Scanner QR Code (résultat)"
        function startQRScanner() {
            startGenericQRScanner('RESULT');
        }

        // Wrapper pour le nouveau bouton "Scanner mon QR-code" (pour trouver sa table)
        function startPlayerQRScanner() {
            startGenericQRScanner('PLAYER_ID');
        }


        function stopQRScanner() {
            if (qrStream) {
                qrStream.getTracks().forEach(track => track.stop());
                qrStream = null;
            }
            if (qrScanInterval) {
                clearInterval(qrScanInterval);
                qrScanInterval = null;
            }
            document.getElementById('qrScannerModal').style.display = 'none';

            // NOUVEAU: Ré-afficher la modale d'accueil si on annule
            if (isPlayerMode && !qrStagedResult) { // Ne pas ré-afficher si on va valider
                document.getElementById('playerHomeModal').style.display = 'flex';
            }
        }

        function onScanSuccess(data) {
            stopQRScanner();

            try {
                const parsed = JSON.parse(data);

                // --- GESTION DU SCAN ---

                // CAS 1: On a scanné un QR JOUEUR ('player')
                if (parsed.type === 'player' && parsed.name) {

                    // CAS 1a: On voulait trouver sa table (mode PLAYER_ID)
                    if (currentScanMode === 'PLAYER_ID') {
                        findPlayerTable(parsed.name, parsed.elo);
                    }
                    // CAS 1b: On voulait scanner un RÉSULTAT (mode RESULT)
                    else {
                        // Si on est arbitre, on cherche la table pour la montrer
                        if (!isPlayerMode) {
                            findPlayerTable(parsed.name, parsed.elo);
                        }
                        // Si on est joueur, on cherche la partie pour l'ENCODER
                        else {
                            findPlayerByName(parsed.name, true); // true = bypass alert
                        }
                    }
                    return;
                }

                // CAS 2: On a scanné un QR RÉSULTAT ('result')
                if (parsed.type === 'result' && parsed.table && parsed.result) {

                    // On ne peut scanner un résultat que si on est en mode 'RESULT'
                    // (ou en mode 'PLAYER_ID' si on est arbitre, par flexibilité)
                    if (currentScanMode === 'PLAYER_ID' && isPlayerMode) {
                        showNotification('Scan annulé. Vous devez scanner votre QR-code joueur, pas un résultat.', 'error');
                        if (isPlayerMode) document.getElementById('playerHomeModal').style.display = 'flex';
                        return;
                    }

                    // Logique de validation du résultat (code existant)
                    qrStagedResult = parsed;
                    const { board } = findBoard(parsed.table);

                    const boardNum = parsed.table;
                    const resultStr = formatResult(parsed.result);
                    let whiteName = "N/A";
                    let blackName = "N/A";

                    if (board && (board.score.white !== '' || board.score.black !== '') && isPlayerMode) {
                        showNotification("Ce résultat a déjà été saisi.", "info");
                        cancelQRValidation();
                        return;
                    }

                    if (board) {
                        whiteName = getSimplePlayerName(board.players.white.name);
                        blackName = getSimplePlayerName(board.players.black.name);
                    } else if (board) {
                        whiteName = "(Table non appariée)";
                        blackName = "(Table non appariée)";
                    } else {
                        whiteName = "(Échiquier non trouvé)";
                        blackName = "(Échiquier non trouvé)";
                    }

                    document.getElementById('qrValidateBoard').textContent = boardNum;
                    document.getElementById('qrValidateWhite').textContent = whiteName;
                    document.getElementById('qrValidateBlack').textContent = blackName;
                    document.getElementById('qrValidateResult').textContent = resultStr;

                    document.getElementById('qrValidationModal').style.display = 'flex';

                } else {
                    showNotification('QR Code invalide ou non reconnu', 'error');
                    if (isPlayerMode) document.getElementById('playerHomeModal').style.display = 'flex';
                }
            } catch (e) {
                showNotification('QR Code illisible', 'error');
                if (isPlayerMode) document.getElementById('playerHomeModal').style.display = 'flex';
            }
        }

        function cancelQRValidation() {
            document.getElementById('qrValidationModal').style.display = 'none';
            qrStagedResult = null;
            // NOUVEAU: Retour à l'accueil joueur
            if (isPlayerMode) {
                document.getElementById('playerHomeModal').style.display = 'flex';
            }
        }


        // --- 3. LA FONCTION DE CONNEXION PRINCIPALE ---
        function validateQRResult() {
            if (!qrStagedResult) return;

            const tableNum = qrStagedResult.table;
            const result = qrStagedResult.result;

            const { board, physicalTable } = findBoard(tableNum);

            if (!board) {
                showNotification(`Échiquier ${tableNum} non trouvé dans cette ronde.`, 'error');
                cancelQRValidation();
                return;
            }

            // CORRECTION: Modifier AVANT de sauvegarder
            if (result === "1-0") {
                board.score.white = "1";
                board.score.black = "0";
            } else if (result === "0-1") {
                board.score.white = "0";
                board.score.black = "1";
            } else if (result === "DRAW") {
                board.score.white = "1/2";
                board.score.black = "1/2";
            }

            updateTableDisplay(physicalTable.id);
            updateStats();

            saveHistoryState(); // Sauvegarder APRÈS

            showNotification(`Table ${tableNum} : ${formatResult(result)} enregistré !`, 'success');
            cancelQRValidation(); // Retourne à l'accueil joueur
        }

        // --- NOUVELLES FONCTIONS MODE JOUEUR ---

        window.arbiterPassword = null;
        let isPlayerMode = false;

        function showArbiterPasswordModal() {
            document.getElementById('arbiterPassInput').value = arbiterPassword || '';
            document.getElementById('arbiterPassModal').style.display = 'flex';
        }

        function setArbiterPassword() {
            const pass = document.getElementById('arbiterPassInput').value;
            if (pass.length > 0 && pass.length < 4) {
                alert("Le mot de passe doit faire au moins 4 caractères.");
                return;
            }
            arbiterPassword = pass.length > 0 ? pass : null;
            document.getElementById('arbiterPassModal').style.display = 'none';

            if (arbiterPassword) {
                showNotification("Mot de passe arbitre enregistré.", "success");

                // --- CORRECTION AJOUTÉE ---
                // Basculer automatiquement en mode Arbitre
                if (window.ChessRoomSave && typeof window.ChessRoomSave.setMode === 'function') {
                    window.ChessRoomSave.setMode('arbiter');
                }
                // --- FIN CORRECTION ---

            } else {
                showNotification("Mot de passe arbitre désactivé.", "info");

                // --- CORRECTION AJOUTÉE ---
                // (Sécurité) Si le mdp est supprimé, forcer le mode spectateur
                if (window.ChessRoomSave && typeof window.ChessRoomSave.setMode === 'function') {
                    window.ChessRoomSave.setMode('spectator');
                }
                // --- FIN CORRECTION ---
            }
            autoSaveToLocalStorage();
        }

        function showPlayerLoginModal() {
            if (!arbiterPassword) {
                alert("Aucun mot de passe arbitre n'a été défini. Veuillez d'abord en créer un.");
                return;
            }
            document.getElementById('playerPassInput').value = '';
            document.getElementById('playerLoginError').style.display = 'none';
            document.getElementById('playerLoginModal').style.display = 'flex';
        }

        function loginAsPlayer() {
            const pass = document.getElementById('playerPassInput').value;
            if (pass === arbiterPassword) {
                isPlayerMode = true;
                document.getElementById('playerLoginModal').style.display = 'none';
                document.getElementById('playerHomeModal').style.display = 'flex';
                // Verrouiller les outils
                setTool('pan'); // Mettre dans un mode "sûr"
                document.querySelector('.sidebar').style.display = 'none';
                document.querySelector('.toolbar').style.display = 'none';
                document.querySelector('.shortcut-bar').style.display = 'none';
                document.querySelector('.main-content').classList.add('sidebar-collapsed');
                fitAllTables(); // Centrer le plan pour le joueur
            } else {
                document.getElementById('playerLoginError').style.display = 'block';
            }
        }

        function performPlayerLogout() {
            isPlayerMode = false;
            document.getElementById('playerHomeModal').style.display = 'none';
            document.getElementById('playerLogoutConfirmModal').style.display = 'none';
            // Déverrouiller les outils
            document.querySelector('.sidebar').style.display = 'flex';
            document.querySelector('.toolbar').style.display = 'flex';
            document.querySelector('.shortcut-bar').style.display = 'block';
            document.querySelector('.main-content').classList.remove('sidebar-collapsed');
            setTool('select');
        }

        function promptToLogoutPlayer() {
            document.getElementById('playerLogoutPassInput').value = '';
            document.getElementById('playerLogoutError').style.display = 'none';
            // MODIFIÉ: S'assurer que la modale d'accueil est cachée
            document.getElementById('playerHomeModal').style.display = 'none';
            document.getElementById('playerLogoutConfirmModal').style.display = 'flex';
        }

        // NOUVEAU: Fermer la modale de déconnexion et revenir
        function closePlayerLogoutConfirm() {
            document.getElementById('playerLogoutConfirmModal').style.display = 'none';
            document.getElementById('playerHomeModal').style.display = 'flex';
        }

        function attemptPlayerLogout() {
            const pass = document.getElementById('playerLogoutPassInput').value;
            if (pass === arbiterPassword) {
                performPlayerLogout();
            } else {
                document.getElementById('playerLogoutError').style.display = 'block';
            }
        }

        // --- NOUVEAU: Gestion Saisie sur Plan ---
        function showPlayerPlanView() {
            document.getElementById('playerHomeModal').style.display = 'none';
            document.body.classList.add('player-plan-view-mode');
            setTool('pan'); // Activer le mode 'pan' pour le déplacement
            renderAllTables(); // NOUVEAU: Re-rendre pour cacher les tables terminées
            fitAllTables();
        }

        function returnToPlayerHome() {
            document.body.classList.remove('player-plan-view-mode');
            document.getElementById('playerHomeModal').style.display = 'flex';
            renderAllTables(); // Re-rendre pour afficher normalement
        }

        // --- NOUVEAU: Gestion Recherche Joueur (Texte) ---
        function showPlayerTextSearch(mode = 'ENCODE') {
            document.getElementById('playerHomeModal').style.display = 'none';
            document.getElementById('playerSearchInput').value = '';
            populatePlayerSearchSuggestions(); // Pré-remplir
            document.getElementById('playerTextSearchModal').dataset.mode = mode;
            document.getElementById('playerTextSearchModal').style.display = 'flex';
            document.getElementById('playerSearchInput').focus();
        }

        function closePlayerTextSearch() {
            document.getElementById('playerTextSearchModal').style.display = 'none';
            document.getElementById('playerHomeModal').style.display = 'flex';
        }

        function populatePlayerSearchSuggestions() {
            const input = document.getElementById('playerSearchInput');
            const suggestionsList = document.getElementById('player-search-suggestions');
            const searchTerm = input.value.toLowerCase();

            suggestionsList.innerHTML = '';
            const addedSuggestions = new Set();
            let matchingOptions = [];

            physicalTables.forEach(table => {
                table.boards.forEach(board => {
                    // NOUVEAU: Filtre
                    if (board.players && (board.score.white === '' && board.score.black === '')) {
                        const wName = getSimplePlayerName(board.players.white.name);
                        const bName = getSimplePlayerName(board.players.black.name);

                        if (wName !== 'N/A' && !addedSuggestions.has(wName)) {
                            addedSuggestions.add(wName);
                            if (wName.toLowerCase().includes(searchTerm)) {
                                matchingOptions.push(wName);
                            }
                        }
                        if (bName !== 'N/A' && !addedSuggestions.has(bName)) {
                            addedSuggestions.add(bName);
                            if (bName.toLowerCase().includes(searchTerm)) {
                                matchingOptions.push(bName);
                            }
                        }
                    }
                });
            });

            // NOUVEAU: Logique d'auto-complétion améliorée
            if (matchingOptions.length === 1 && searchTerm.length > 2 && matchingOptions[0].toLowerCase() !== searchTerm) {
                input.value = matchingOptions[0]; // Auto-remplir
            } else {
                matchingOptions.forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    suggestionsList.appendChild(option);
                });
            }
        }

        function findPlayerFromTextSearch() {
            const mode = document.getElementById('playerTextSearchModal').dataset.mode || 'ENCODE'; // <-- AJOUTÉ
            const name = document.getElementById('playerSearchInput').value;
            document.getElementById('playerSearchInput').value = '';
            if (!name || name.trim().length < 2) {
                alert("Veuillez entrer un nom valide.");
                return;
            }

            // --- MODIFIÉ ---
            if (mode === 'VIEW') {
                findPlayerTable(name.trim());
            } else {
                findPlayerByName(name.trim());
            }
            // --- FIN MODIFICATION ---

            document.getElementById('playerTextSearchModal').style.display = 'none';
        }

        // --- NOUVEAU: Gestion Recherche Joueur (Liste) ---
        function showPlayerListSearch(mode = 'ENCODE') {
            document.getElementById('playerHomeModal').style.display = 'none';
            document.getElementById('playerListSearchModal').dataset.mode = mode;

            const select = document.getElementById('playerListSelect');
            select.innerHTML = '<option value="">-- Sélectionnez votre nom --</option>';
            const playerList = [];

            physicalTables.forEach(table => {
                table.boards.forEach(board => {
                    // NOUVEAU: Filtre (mode ENCODE)
                    if (mode === 'ENCODE' && board.players && (board.score.white === '' && board.score.black === '')) {
                        playerList.push({ name: getSimplePlayerName(board.players.white.name), board: board.boardNumber });
                        playerList.push({ name: getSimplePlayerName(board.players.black.name), board: board.boardNumber });
                    }
                    // NOUVEAU: Pas de filtre (mode VIEW)
                    else if (mode === 'VIEW' && board.players) {
                        playerList.push({ name: getSimplePlayerName(board.players.white.name), board: board.boardNumber });
                        playerList.push({ name: getSimplePlayerName(board.players.black.name), board: board.boardNumber });
                    }
                });
            });

            // Trier la liste par nom
            playerList.sort((a, b) => a.name.localeCompare(b.name));

            const addedNames = new Set(); // Éviter doublons si un joueur a 2 parties (rare)
            playerList.forEach(p => {
                if (p.name !== "N/A" && !addedNames.has(p.name)) {
                    const option = document.createElement('option');
                    option.value = p.name; // On utilise le nom pour la recherche
                    option.textContent = `${p.name} (Éch. ${p.board})`;
                    select.appendChild(option);
                    addedNames.add(p.name);
                }
            });

            document.getElementById('playerListSearchModal').style.display = 'flex';
        }

        function closePlayerListSearch() {
            document.getElementById('playerListSearchModal').style.display = 'none';
            document.getElementById('playerHomeModal').style.display = 'flex';
        }

        function findPlayerFromListSearch() {
            const mode = document.getElementById('playerListSearchModal').dataset.mode || 'ENCODE'; // <-- AJOUTÉ
            const name = document.getElementById('playerListSelect').value;
            if (!name) {
                alert("Veuillez sélectionner votre nom.");
                return;
            }

            // --- MODIFIÉ ---
            if (mode === 'VIEW') {
                findPlayerTable(name);
            } else {
                findPlayerByName(name);
            }
            document.getElementById('playerListSearchModal').style.display = 'none';
        }

        // --- NOUVEAU: Logique de recherche commune ---
        function findPlayerByName(name, fromQR = false) {
            const searchTerm = name.toLowerCase();
            let foundGame = null;

            for (const physicalTable of physicalTables) {
                for (const board of physicalTable.boards) {
                    // NOUVEAU: Filtre
                    if (board.players && (board.score.white === '' && board.score.black === '')) {
                        if ((board.players.white && getSimplePlayerName(board.players.white.name).toLowerCase() === searchTerm) ||
                            (board.players.black && getSimplePlayerName(board.players.black.name).toLowerCase() === searchTerm)) {

                            foundGame = { board, physicalTable };
                            break;
                        }
                    }
                }
                if (foundGame) break;
            }

            if (foundGame) {
                showSimplifiedScoreModal(foundGame.board, foundGame.physicalTable);
            } else {
                // CORRECTION: Ne pas alerter si on vient d'un scan QR (car on va chercher dans les tables terminées)
                if (!fromQR) {
                    alert(`Aucune partie non terminée trouvée pour "${name}" dans cette ronde.`);
                    document.getElementById('playerHomeModal').style.display = 'flex'; // Retour accueil
                }

                // CORRECTION: Si on vient d'un QR et qu'on n'a pas trouvé de partie non terminée,
                // c'est que le résultat est déjà saisi.
                if (fromQR) {
                    showNotification("Cette partie est déjà terminée.", "info");
                    document.getElementById('playerHomeModal').style.display = 'flex'; // Retour accueil
                }
            }
        }


        // --- NOUVELLE FONCTION: Trouver la table d'un joueur depuis son QR-code ---
        function findPlayerTable(playerName, playerElo) {
            const searchTerm = playerName.toLowerCase().trim();
            let foundGame = null;
            let playerColor = null;

            // Chercher le joueur dans la ronde actuelle
            for (const physicalTable of physicalTables) {
                for (const board of physicalTable.boards) {
                    if (board.players) {
                        const whiteName = board.players.white ? board.players.white.name.toLowerCase().trim() : '';
                        const blackName = board.players.black ? board.players.black.name.toLowerCase().trim() : '';

                        if (whiteName === searchTerm) {
                            foundGame = { board, physicalTable };
                            playerColor = 'white';
                            break;
                        } else if (blackName === searchTerm) {
                            foundGame = { board, physicalTable };
                            playerColor = 'black';
                            break;
                        }
                    }
                }
                if (foundGame) break;
            }

            if (foundGame) {
                // === MODIFICATION START ===

                // 1. Cacher toutes les modales (accueil, recherche)
                document.getElementById('playerHomeModal').style.display = 'none';
                document.getElementById('playerTextSearchModal').style.display = 'none';
                document.getElementById('playerListSearchModal').style.display = 'none';

                // 2. Passer en mode plan
                document.body.classList.add('player-plan-view-mode');
                setTool('pan');
                renderAllTables();

                // 3. Mettre en évidence et scroller
                highlightPlayerTable(foundGame.physicalTable, foundGame.board);

                // 4. Afficher le popup d'info
                showPlayerTableInfo(foundGame.board, foundGame.physicalTable, playerColor, playerName, playerElo);

                // === MODIFICATION END ===
            } else {
                showNotification(`Partie non trouvée pour "${playerName}" dans cette ronde.`, 'error');
                // Ré-afficher la modale d'accueil si non trouvé
                if (isPlayerMode) {
                    document.getElementById('playerHomeModal').style.display = 'flex';
                }
            }
        }

        function closePlayerTableInfo() {
            document.getElementById('playerTableInfoModal').style.display = 'none';

            // Enlever la surbrillance
            document.querySelectorAll('.table-element').forEach(el => {
                el.classList.remove('highlight-player');
            });

            // Revenir à l'accueil joueur (le hub central)
            if (isPlayerMode) {
                // Quitter le mode plan
                document.body.classList.remove('player-plan-view-mode');
                // Afficher le hub
                document.getElementById('playerHomeModal').style.display = 'flex';
            }
        }

        // MODIFIÉ: Version unique et corrigée de showPlayerTableInfo
        // MODIFIÉ: Le popup ne se ferme plus automatiquement
        function showPlayerTableInfo(board, physicalTable, playerColor, playerName, playerElo) {
            if (!board.players) return;

            // --- Récupération des infos ---
            const boardNum = board.boardNumber;
            const whitePlayer = board.players.white;
            const blackPlayer = board.players.black;

            let opponentName, opponentElo, colorText;
            if (playerColor === 'white') {
                opponentName = getSimplePlayerName(blackPlayer.name);
                opponentElo = blackPlayer.elo || '';
                colorText = '⚪ Blancs';
            } else {
                opponentName = getSimplePlayerName(whitePlayer.name);
                opponentElo = whitePlayer.elo || '';
                colorText = '⚫ Noirs';
            }

            const playerDisplayName = `${playerName}${playerElo ? ' (' + playerElo + ')' : ''}`;
            const opponentDisplayName = `${opponentName}${opponentElo ? ' (' + opponentElo + ')' : ''}`;

            // --- Mise à jour du DOM ---
            document.getElementById('playerTableInfoName').textContent = playerDisplayName;
            document.getElementById('playerTableInfoTable').textContent = boardNum;
            document.getElementById('playerTableInfoColor').textContent = colorText;
            document.getElementById('playerTableInfoOpponent').textContent = opponentDisplayName;

            // --- Affichage ---
            const modal = document.getElementById('playerTableInfoModal');
            modal.style.display = 'block';
            // On réactive les clics sur la modale pour pouvoir utiliser le bouton
            modal.style.pointerEvents = "auto"; 

            // --- Gestion Fermeture (Uniquement manuelle) ---
            const closeBtn = document.getElementById('closePlayerTableInfoBtn');
            
            // On supprime les anciens listeners pour éviter les doublons
            const newBtn = closeBtn.cloneNode(true);
            closeBtn.parentNode.replaceChild(newBtn, closeBtn);
            
            newBtn.onclick = () => {
                closePlayerTableInfo();
            };
        }

        // Fonction pour mettre en évidence la table du joueur sur le plan
        function highlightPlayerTable(physicalTable, board) {
            // Enlever toute mise en évidence précédente
            document.querySelectorAll('.table-element').forEach(el => {
                el.classList.remove('highlight-player');
            });

            // Trouver l'élément DOM de la table
            const tableElement = document.querySelector(`[data-table-id="${physicalTable.id}"]`);
            if (tableElement) {
                tableElement.classList.add('highlight-player');

                // Scroller vers la table si nécessaire
                tableElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }


        // Afficher la modale de saisie simplifiée
        function showSimplifiedScoreModal(board, physicalTable) {
            if (!board.players) return;

            const pWhite = getSimplePlayerName(board.players.white.name);
            const pBlack = getSimplePlayerName(board.players.black.name);
            const boardNum = board.boardNumber;

            document.getElementById('simplifiedBoardNum').textContent = boardNum;
            document.getElementById('simplifiedWhitePlayer').textContent = pWhite;
            document.getElementById('simplifiedBlackPlayer').textContent = pBlack;

            const btnWhite = document.getElementById('btnWinWhite');
            btnWhite.innerHTML = `<strong>1-0</strong><br>(${pWhite} gagne)`;
            btnWhite.onclick = () => saveSimplifiedScore(boardNum, '1-0');

            const btnDraw = document.getElementById('btnDraw');
            btnDraw.innerHTML = `<strong>½-½</strong><br>(Match Nul)`;
            btnDraw.onclick = () => saveSimplifiedScore(boardNum, '1/2-1/2');

            const btnBlack = document.getElementById('btnWinBlack');
            btnBlack.innerHTML = `<strong>0-1</strong><br>(${pBlack} gagne)`;
            btnBlack.onclick = () => saveSimplifiedScore(boardNum, '0-1');

            document.getElementById('simplifiedScoreModal').style.display = 'flex';
        }

        // NOUVEAU: Fermer la modale simplifiée et retourner
        function closeSimplifiedScoreModal() {
            document.getElementById('simplifiedScoreModal').style.display = 'none';
            // Si on était en mode plan, on y reste. Sinon, on retourne à l'accueil
            if (!document.body.classList.contains('player-plan-view-mode') && isPlayerMode) {
                document.getElementById('playerHomeModal').style.display = 'flex';
            }
        }

        // Enregistrer le score depuis la modale simplifiée
        function saveSimplifiedScore(boardNum, result) {
            const { board, physicalTable } = findBoard(boardNum);
            if (!board) return;

            // CORRECTION: Modifier AVANT de sauvegarder
            if (result === "1-0") {
                board.score.white = "1";
                board.score.black = "0";
            } else if (result === "0-1") {
                board.score.white = "0";
                board.score.black = "1";
            } else if (result === "1/2-1/2") {
                board.score.white = "1/2";
                board.score.black = "1/2";
            }

            updateTableDisplay(physicalTable.id);
            updateStats();

            saveHistoryState(); // Sauvegarder APRÈS

            // MODIFIÉ: Logique de fermeture/retour
            document.getElementById('simplifiedScoreModal').style.display = 'none';
            showNotification(`Résultat ${result} enregistré pour l'échiquier ${boardNum} !`, 'success');

            // NOUVEAU: Retour automatique à l'accueil
            if (isPlayerMode) {
                returnToPlayerHome();
            }
        }



        // --- Initialisation ---
        document.addEventListener('DOMContentLoaded', async () => {

            // NOUVEAU: Ouvrir le premier accordéon par défaut (Statistiques)
            const firstAccordionHeader = document.querySelector('.sidebar-section h3');
            if (firstAccordionHeader) {
                toggleAccordion(firstAccordionHeader);
            }


            // CORRECTION: Recharger la stratégie de sauvegarde depuis localStorage
            const savedStrategy = localStorage.getItem(STRATEGY_KEY) || 'server_only';
            const strategySelect = document.getElementById('saveStrategySelector');
            if (strategySelect) {
                strategySelect.value = savedStrategy;
            }

            // Note: Le chargement des données est maintenant géré par chessroom-save-system.js
            // qui s'occupe de charger depuis le serveur ou le localStorage selon la configuration

            // Charger l'état par défaut si aucune donnée n'est chargée
            if (Object.keys(roundsStore).length === 0 || !roundsStore['ronde1']) {
                loadStateFromStore('ronde1');
            }

            document.getElementById('scoreModal').addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    hideScoreModal();
                }
                if (e.key === 'Enter') {
                    saveScoreFromModal();
                }
            });

            // NOUVEAU: Écouteur pour la modale de recherche texte joueur
            document.getElementById('playerTextSearchModal').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    findPlayerFromTextSearch();
                }
            });

            // NOUVEAU: Écouteur pour la modale de recherche liste joueur
            document.getElementById('playerListSearchModal').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    findPlayerFromListSearch();
                }
            });

            // NOUVEAU: Écouteur pour la modale de login joueur
            document.getElementById('playerLoginModal').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    loginAsPlayer();
                }
            });

            // NOUVEAU: Écouteur pour la modale de logout joueur
            document.getElementById('playerLogoutConfirmModal').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    attemptPlayerLogout();
                }
            });

            setTimeout(() => {
                // MODIFIÉ: Vue par défaut
                fitAllTables();
            }, 500);

            // NOUVEAU: Écouteur de synchronisation entre onglets
            window.addEventListener('storage', (e) => {
                // CORRECTION: On écoute la clé de stratégie
                if (e.key === STRATEGY_KEY && e.newValue) {
                    const strategySelect = document.getElementById('saveStrategySelector');
                    if (strategySelect) {
                        strategySelect.value = e.newValue;
                        // On simule le changement pour déclencher les rechargements
                        strategySelect.dispatchEvent(new Event('change'));
                    }
                }

                if (e.key === SAVE_KEY && e.newValue) {

                    if (isPlayerMode) return;

                    if (document.querySelector('.modal-overlay[style*="display: flex"]') || document.getElementById('scoreModal').style.display === 'flex') {
                        console.log('Synchronisation en attente, modale ouverte.');
                        return;
                    }

                    // CORRECTION: Ne synchroniser que si on est en mode 'local_only'
                    // (le mode serveur est géré par le timer de synchro)
                    const currentStrategy = document.getElementById('saveStrategySelector').value;
                    if (currentStrategy !== 'local_only') {
                        return;
                    }

                    console.log('Changement de sauvegarde (local) détecté, rafraîchissement...');
                    try {
                        const data = JSON.parse(e.newValue);
                        if (data && data.roundsStore) {
                            roundsStore = data.roundsStore;
                            arbiterPassword = data.arbiterPassword || null;

                            if (!roundsStore[currentRoundKey]) {
                                currentRoundKey = data.currentRoundKey || 'ronde1';
                            }

                            loadStateFromStore(currentRoundKey);
                            updateRoundSelector();

                            showNotification('Plan mis à jour (synchro. locale)', 'info');
                        }
                    } catch (err) {
                        console.error('Erreur de synchronisation:', err);
                    }
                }
            });
        });

        // ========================================
        // SAUVEGARDE ET SYNCHRONISATION AUTOMATIQUE
        // ========================================
        // Note: Les intervalles de sauvegarde automatique sont maintenant gérés
        // par chessroom-save-system.js qui configure les timers selon les options
        // choisies par l'utilisateur (Mode Arbitre/Spectateur + cases à cocher)

        // --- NOUVELLES FONCTIONS DE GESTION DE TOURNOI ---

        function deleteCurrentRound() {
            // 1. Vérification de sécurité
            const keys = Object.keys(roundsStore);
            if (keys.length <= 1) {
                alert("Impossible de supprimer la seule ronde existante. Pour recommencer à zéro, utilisez le bouton 'Nouveau Tournoi'.");
                return;
            }

            // 2. Demander confirmation
            if (!confirm(`Êtes-vous sûr de vouloir supprimer DÉFINITIVEMENT la ${currentRoundKey.replace('r', 'R')} ?\n\n⚠️ IMPORTANT : Les rondes suivantes seront renumérotées (ex: la Ronde 3 deviendra la Ronde 2).`)) {
                return;
            }

            // 3. Récupérer toutes les clés et les trier numériquement (pour éviter l'ordre ronde1, ronde10, ronde2)
            const sortedKeys = keys.sort((a, b) => {
                const numA = parseInt(a.replace('ronde', ''));
                const numB = parseInt(b.replace('ronde', ''));
                return numA - numB;
            });

            // 4. Créer une liste des données des rondes que l'on GARDE (on exclut la ronde actuelle)
            const remainingRoundsData = sortedKeys
                .filter(key => key !== currentRoundKey)
                .map(key => roundsStore[key]);

            // 5. Reconstruire le roundsStore proprement (ronde1, ronde2, ronde3...)
            // On vide l'ancien store et on le remplit avec les nouvelles clés séquentielles
            roundsStore = {};

            remainingRoundsData.forEach((data, index) => {
                const newKey = `ronde${index + 1}`; // index 0 devient ronde1, index 1 devient ronde2, etc.
                roundsStore[newKey] = data;
            });

            // 6. Basculer vers la dernière ronde disponible (souvent celle qui vient d'être renommée)
            const newKeys = Object.keys(roundsStore);
            const lastKey = newKeys[newKeys.length - 1];

            // Charger la nouvelle vue
            loadStateFromStore(lastKey);
            updateRoundSelector();
            autoSaveToLocalStorage();

            saveHistoryState(); // Sauvegarder APRÈS
            showNotification("Ronde supprimée et numérotation réorganisée.", "success");
        }

        function createNewTournament() {
            // On réutilise la logique existante de clearAll mais avec un message spécifique
            // clearAll() contient déjà un confirm(), mais pour être sûr du message "Nouveau Tournoi":

            if (confirm("⚠️ ATTENTION : Vous allez créer un NOUAU TOURNOI.\n\nToutes les données actuelles (toutes les rondes, joueurs, scores, configurations) seront effacées.\n\nVoulez-vous vraiment continuer ?")) {
                // On appelle la logique de nettoyage sans redemander confirmation (on bypass le confirm du clearAll en exécutant son contenu directement ou en le modifiant légèrement, mais ici on va appeler la logique de reset manuellement pour être propre).

                localStorage.removeItem(SAVE_KEY);
                localStorage.removeItem(SAVE_KEY_TIMESTAMP);

                // Réinitialisation des variables globales
                physicalTables = [];
                rooms = [];
                nextPhysicalTableId = 1;
                nextRoomId = 1;
                nextBoardNumber = 1;
                historyStack = [];
                redoStack = [];

                // Réinitialisation du store
                roundsStore = {};
                currentRoundKey = 'ronde1'; // On repart à la ronde 1

                // Charger l'état vide
                loadStateFromStore('ronde1');
                updateRoundSelector();

                document.getElementById('canvas').innerHTML = '';
                updateStats();

                saveHistoryState(); // Sauvegarder l'état vide

                showNotification("Nouveau tournoi créé.", "success");
            }
        }
    </script>

    <script>
        // ============================================
        // SYSTÈME DE SAUVEGARDE SÉCURISÉ - VERSION CORRIGÉE
        // ============================================

        // ===== CONFIGURATION =====
        const SAVE_CONFIG = {
            modes: {
                ARBITER: 'arbiter',          // Peut sauvegarder
                SPECTATOR: 'spectator'       // Lecture seule
            },
            intervals: {
                LOCAL_SAVE: 30000,           // 30 secondes
                SERVER_SYNC: 5000            // 5 secondes
            },
            maxHistoryDisplay: 20            // Nombre d'historiques affichés
        };

        // Variable locale pour ce module
        let lastSaveStatus = { type: '', message: '', timestamp: null };

        // ===== FONCTIONS DE STATUT =====

        function showSaveStatus(type, message) {
            const statusDiv = document.getElementById('saveStatus');
            if (!statusDiv) return;

            const icons = {
                success: '✅',
                error: '❌',
                warning: '⚠️',
                info: 'ℹ️',
                sync: '🔄'
            };

            const colors = {
                success: '#d4edda',
                error: '#f8d7da',
                warning: '#fff3cd',
                info: '#d1ecf1',
                sync: '#e7f3ff'
            };

            const timestamp = new Date().toLocaleTimeString('fr-FR');

            statusDiv.style.display = 'block';
            statusDiv.style.background = colors[type] || colors.info;
            statusDiv.style.border = `1px solid ${colors[type]}`;
            statusDiv.innerHTML = `${icons[type]} ${message} <small>(${timestamp})</small>`;

            lastSaveStatus = { type, message, timestamp };

            // Masquer après 5 secondes pour les succès
            if (type === 'success') {
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 5000);
            }
        }

        // ===== FONCTIONS DE SAUVEGARDE =====

        async function saveToLocalStorage() {
            try {
                saveCurrentStateToStore();

                const dataToSave = {
                    roundsStore: JSON.parse(JSON.stringify(roundsStore)),
                    currentRoundKey: currentRoundKey,
                    arbiterPassword: arbiterPassword,
                    lastModified: Date.now()
                };

                // Nettoyer les handlers
                Object.values(dataToSave.roundsStore).forEach(roundState => {
                    if (roundState.physicalTables) {
                        roundState.physicalTables.forEach(t => {
                            delete t.mouseDownHandler;
                        });
                    }
                });

                const json = JSON.stringify(dataToSave);
                localStorage.setItem(SAVE_KEY, json);
                localStorage.setItem(SAVE_KEY_TIMESTAMP, Date.now().toString());

                showSaveStatus('success', '💾 Sauvegarde locale réussie');
                return true;
            } catch (error) {
                console.error('Erreur sauvegarde locale:', error);
                showSaveStatus('error', 'Erreur lors de la sauvegarde locale');
                return false;
            }
        }

        async function saveToServer() {
            if (!USE_SERVER_SYNC) {
                showSaveStatus('warning', 'Synchronisation serveur désactivée');
                return false;
            }

            if (currentSaveMode !== SAVE_CONFIG.modes.ARBITER) {
                showSaveStatus('warning', '⚠️ Mode spectateur : sauvegarde serveur bloquée');
                return false;
            }

            try {
                saveCurrentStateToStore();

                const dataToSave = {
                    roundsStore: JSON.parse(JSON.stringify(roundsStore)),
                    currentRoundKey: currentRoundKey,
                    arbiterPassword: arbiterPassword,
                    lastModified: Date.now(),
                    clientTimestamp: lastServerTimestamp, // Optimistic Locking
                    savedBy: currentSaveMode
                };

                // Nettoyer les handlers
                Object.values(dataToSave.roundsStore).forEach(roundState => {
                    if (roundState.physicalTables) {
                        roundState.physicalTables.forEach(t => {
                            delete t.mouseDownHandler;
                        });
                    }
                });

                const response = await fetch(SERVER_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(dataToSave)
                });

                if (response.status === 409) {
                    const errorData = await response.json();
                    alert("⚠️ CONFLIT DE VERSION !\n\nQuelqu'un d'autre a modifié les données pendant que vous travailliez.\n\nVos modifications n'ont PAS été sauvegardées pour éviter d'écraser leur travail.\n\nVeuillez recharger la page pour voir les nouvelles données.");
                    showSaveStatus('error', 'Conflit de version - Sauvegarde annulée');
                    return false;
                }

                if (response.ok) {
                    const result = await response.json();
                    if (result.success) {
                        if (result.timestamp) lastServerTimestamp = result.timestamp;
                        showSaveStatus('success', `☁️ Sauvegarde serveur réussie`);
                        return true;
                    }
                } else {
                    showSaveStatus('error', 'Erreur serveur : ' + response.status);
                }
                return false;
            } catch (error) {
                console.error('❌ Erreur serveur:', error);
                showSaveStatus('error', 'Impossible de contacter le serveur');
                return false;
            }
        }

        async function loadFromServer(isAutoSync = false) {
            if (!USE_SERVER_SYNC) return false;

            try {
                if (!isAutoSync) {
                    showSaveStatus('sync', '🔄 Chargement depuis le serveur...');
                }

                // Add timestamp to prevent caching
                const response = await fetch(SERVER_URL + '?t=' + new Date().getTime());

                // Get Timestamp Header for Optimistic Locking
                const tsHeader = response.headers.get('X-Data-Timestamp');
                if (tsHeader) {
                    lastServerTimestamp = parseInt(tsHeader, 10);
                    console.log("Server Timestamp:", lastServerTimestamp);
                }

                if (!response.ok) {
                    if (!isAutoSync) showSaveStatus('error', 'Erreur lors du chargement serveur');
                    return false;
                }

                const data = await response.json();

                if (data && data.roundsStore && typeof data.roundsStore === 'object' &&
                    Object.keys(data.roundsStore).length > 0) {

                    // Vérifier si les données ont changé
                    const currentJson = JSON.stringify(roundsStore);
                    const serverJson = JSON.stringify(data.roundsStore);

                    if (currentJson === serverJson) {
                        if (!isAutoSync) showSaveStatus('info', 'ℹ️ Les données sont déjà à jour');
                        return false;
                    }

                    // CORRECTION: En mode spectateur, ne JAMAIS demander confirmation
                    // En mode arbitre, demander uniquement si action manuelle ET données locales existent
                    if (!isAutoSync &&
                        currentSaveMode === SAVE_CONFIG.modes.ARBITER &&
                        Object.keys(roundsStore).length > 0) {
                        if (!confirm('⚠️ Charger les données du serveur écrasera vos modifications locales. Continuer ?')) {
                            showSaveStatus('warning', 'Chargement annulé');
                            return false;
                        }
                    }

                    roundsStore = data.roundsStore;
                    currentRoundKey = data.currentRoundKey || 'ronde1';
                    arbiterPassword = data.arbiterPassword || null;

                    // Migration des données
                    Object.values(roundsStore).forEach(roundState => {
                        if (!roundState.physicalTables) roundState.physicalTables = [];
                        if (!roundState.rooms) roundState.rooms = [];
                        if (!roundState.nextRoomId) roundState.nextRoomId = 1;
                        roundState.physicalTables.forEach(pt => {
                            if (!pt.arbiterComment) pt.arbiterComment = { text: "", flag: "none" };
                            pt.boards.forEach(b => {
                                if (b.score === undefined) b.score = { white: "", black: "" };
                                if (b.players && b.players.white && typeof b.players.white === 'string') {
                                    b.players.white = { name: b.players.white, elo: null };
                                    b.players.black = { name: b.players.black, elo: null };
                                }
                                if (!b.players) {
                                    b.players = { white: { name: "", elo: null }, black: { name: "", elo: null } };
                                }
                            });
                        });
                    });

                    loadStateFromStore(currentRoundKey);
                    updateRoundSelector();

                    if (!isAutoSync) {
                        showSaveStatus('success', '✅ Données chargées depuis le serveur');
                        checkAndNotifyPlayer();
                    }
                    if (typeof checkAndRedirectPlayer === 'function') {
                        checkAndRedirectPlayer(); 
                    }
                    return true;
                } else {
                    if (!isAutoSync) showSaveStatus('warning', 'Aucune donnée sur le serveur');
                    return false;
                }
            } catch (error) {
                console.error('Erreur chargement serveur:', error);
                if (!isAutoSync) showSaveStatus('error', 'Erreur lors du chargement');
                return false;
            }
        }

        // NOUVEAU: Fonction pour charger depuis localStorage
        async function loadFromLocalStorage() {
            try {
                const saved = localStorage.getItem(SAVE_KEY);
                if (!saved) {
                    showSaveStatus('info', 'Aucune sauvegarde locale trouvée');
                    return false;
                }

                const data = JSON.parse(saved);

                if (data && data.roundsStore && typeof data.roundsStore === 'object') {
                    roundsStore = data.roundsStore;
                    currentRoundKey = data.currentRoundKey || 'ronde1';
                    arbiterPassword = data.arbiterPassword || null;

                    // Migration des données
                    Object.values(roundsStore).forEach(roundState => {
                        if (!roundState.physicalTables) roundState.physicalTables = [];
                        if (!roundState.rooms) roundState.rooms = [];
                        if (!roundState.nextRoomId) roundState.nextRoomId = 1;
                        roundState.physicalTables.forEach(pt => {
                            if (!pt.arbiterComment) pt.arbiterComment = { text: "", flag: "none" };
                            pt.boards.forEach(b => {
                                if (b.score === undefined) b.score = { white: "", black: "" };
                                if (b.players && b.players.white && typeof b.players.white === 'string') {
                                    b.players.white = { name: b.players.white, elo: null };
                                    b.players.black = { name: b.players.black, elo: null };
                                }
                                if (!b.players) {
                                    b.players = { white: { name: "", elo: null }, black: { name: "", elo: null } };
                                }
                            });
                        });
                    });

                    loadStateFromStore(currentRoundKey);
                    updateRoundSelector();

                    showSaveStatus('success', '✅ Données chargées depuis le localStorage');
                    return true;
                }
                return false;
            } catch (error) {
                console.error('Erreur chargement localStorage:', error);
                showSaveStatus('error', 'Erreur lors du chargement local');
                return false;
            }
        }

        // NOUVEAU: Fonction pour purger le localStorage
        function purgeLocalStorage() {
            if (!confirm('⚠️ ATTENTION : Supprimer TOUTES les sauvegardes locales ?\n\nCette action est irréversible.\n\nAssurez-vous d\'avoir sauvegardé sur le serveur si nécessaire.')) {
                return;
            }

            try {
                localStorage.removeItem(SAVE_KEY);
                localStorage.removeItem(SAVE_KEY_TIMESTAMP);
                showSaveStatus('success', '🗑️ Sauvegardes locales supprimées');
            } catch (error) {
                console.error('Erreur purge localStorage:', error);
                showSaveStatus('error', 'Erreur lors de la suppression');
            }
        }

        // ===== SYNCHRONISATION AUTOMATIQUE =====

        async function syncFromServerIfNeeded() {
            // CORRECTION: Supprimer le délai anti-conflit
            // La synchronisation se fait maintenant immédiatement après chaque action

            // En mode spectateur, toujours synchroniser depuis le serveur
            if (currentSaveMode === SAVE_CONFIG.modes.SPECTATOR) {
                await loadFromServer(true); // true = auto sync silencieux
            }
        }

        // ===== HISTORIQUE SERVEUR =====

        async function loadFromHistory(filename) {
            if (!filename) return false;

            try {
                showSaveStatus('sync', '🔄 Chargement de l\'historique...');

                const response = await fetch(`${SERVER_URL}?history=${encodeURIComponent(filename)}`);
                if (!response.ok) {
                    showSaveStatus('error', 'Erreur lors du chargement de l\'historique');
                    return false;
                }

                const data = await response.json();

                if (data && data.roundsStore) {
                    if (confirm(`⚠️ Restaurer cette sauvegarde écrasera toutes les données actuelles. Continuer ?`)) {
                        roundsStore = data.roundsStore;
                        currentRoundKey = data.currentRoundKey || 'ronde1';
                        arbiterPassword = data.arbiterPassword || null;

                        // Migration
                        Object.values(roundsStore).forEach(roundState => {
                            if (!roundState.physicalTables) roundState.physicalTables = [];
                            if (!roundState.rooms) roundState.rooms = [];
                            if (!roundState.nextRoomId) roundState.nextRoomId = 1;
                            roundState.physicalTables.forEach(pt => {
                                if (!pt.arbiterComment) pt.arbiterComment = { text: "", flag: "none" };
                                pt.boards.forEach(b => {
                                    if (b.score === undefined) b.score = { white: "", black: "" };
                                    if (b.players && b.players.white && typeof b.players.white === 'string') {
                                        b.players.white = { name: b.players.white, elo: null };
                                        b.players.black = { name: b.players.black, elo: null };
                                    }
                                    if (!b.players) {
                                        b.players = { white: { name: "", elo: null }, black: { name: "", elo: null } };
                                    }
                                });
                            });
                        });

                        loadStateFromStore(currentRoundKey);
                        updateRoundSelector();

                        // Sauvegarder immédiatement
                        saveToLocalStorage();
                        if (currentSaveMode === SAVE_CONFIG.modes.ARBITER) {
                            await saveToServer();
                        }

                        showSaveStatus('success', '✅ Historique restauré');
                        return true;
                    }
                }
                return false;
            } catch (error) {
                console.error('Erreur restauration historique:', error);
                showSaveStatus('error', 'Erreur lors de la restauration');
                return false;
            }
        }

        // NOUVEAU: Fonction pour supprimer un fichier d'historique
        async function deleteHistoryFile(filename, buttonElement) {
            if (!confirm(`Supprimer définitivement le fichier "${filename}" ?\n\nCette action est irréversible.`)) {
                return;
            }

            try {
                const response = await fetch(`${SERVER_URL}?delete=${encodeURIComponent(filename)}`);
                if (!response.ok) {
                    showSaveStatus('error', 'Erreur lors de la suppression');
                    return;
                }

                const result = await response.json();
                if (result.success) {
                    // Retirer visuellement l'élément
                    const historyItem = buttonElement.closest('.history-item');
                    if (historyItem) {
                        historyItem.style.opacity = '0';
                        setTimeout(() => historyItem.remove(), 300);
                    }
                    showSaveStatus('success', `Fichier ${filename} supprimé`);
                } else {
                    showSaveStatus('error', 'Impossible de supprimer le fichier');
                }
            } catch (error) {
                console.error('Erreur suppression:', error);
                showSaveStatus('error', 'Erreur lors de la suppression');
            }
        }

        // NOUVEAU: Fonction pour supprimer TOUT l'historique
        async function deleteAllHistory() {
            if (!confirm('⚠️ ATTENTION : Supprimer TOUT l\'historique du serveur ?\n\nCette action est IRRÉVERSIBLE et supprimera toutes les sauvegardes automatiques.\n\nLes données actuelles ne seront pas affectées.')) {
                return;
            }

            // Double confirmation pour sécurité
            if (!confirm('Confirmez-vous vraiment la suppression de TOUT l\'historique ?')) {
                return;
            }

            try {
                const response = await fetch(`${SERVER_URL}?delete_all=true`);
                if (!response.ok) {
                    showSaveStatus('error', 'Erreur lors de la suppression');
                    return;
                }

                const result = await response.json();
                if (result.success) {
                    // Fermer la modale et recharger
                    const modal = document.getElementById('historyModal');
                    if (modal) modal.remove();

                    showSaveStatus('success', result.message);
                } else {
                    showSaveStatus('error', 'Impossible de supprimer l\'historique');
                }
            } catch (error) {
                console.error('Erreur suppression totale:', error);
                showSaveStatus('error', 'Erreur lors de la suppression');
            }
        }

        async function showHistoryModal() {
            if (!USE_SERVER_SYNC) {
                alert('La synchronisation serveur doit être activée pour voir l\'historique.');
                return;
            }

            try {
                showSaveStatus('sync', '🔄 Chargement de l\'historique...');

                const response = await fetch(`${SERVER_URL}?list_history=true`);
                if (!response.ok) {
                    showSaveStatus('error', 'Erreur lors du chargement de l\'historique');
                    return;
                }

                const result = await response.json();
                if (!result.success || !result.history) {
                    showSaveStatus('warning', 'Aucun historique trouvé');
                    return;
                }

                showHistoryList(result.history);
                showSaveStatus('success', 'Historique chargé');
            } catch (error) {
                console.error('Erreur chargement historique:', error);
                showSaveStatus('error', 'Impossible de charger l\'historique');
            }
        }

        function showHistoryList(historyItems) {
            // Créer la modale
            const modal = document.createElement('div');
            modal.id = 'historyModal';
            modal.className = 'modal-overlay';
            modal.style.cssText = 'display: flex; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 10000; align-items: center; justify-content: center;';

            modal.innerHTML = `
        <div style="background: white; border-radius: 12px; padding: 30px; max-width: 800px; width: 90%; max-height: 80vh; overflow-y: auto; box-shadow: 0 10px 40px rgba(0,0,0,0.3);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 style="margin: 0; color: #2c3e50;">📂 Historique des sauvegardes</h2>
                <button id="closeHistoryModal" style="background: #eb3349; color: white; border: none; border-radius: 50%; width: 32px; height: 32px; font-size: 1.2em; cursor: pointer; display: flex; align-items: center; justify-content: center;">×</button>
            </div>
            
            <div style="margin-bottom: 15px; padding: 10px; background: #fff3cd; border-left: 4px solid #ffc107; border-radius: 4px;">
                <strong>ℹ️ Info :</strong> Les sauvegardes sont créées automatiquement à chaque modification.
            </div>
            
            <button id="deleteAllHistoryBtn" style="padding: 10px 20px; background: #dc3545; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; margin-bottom: 20px; width: 100%;">
                🗑️ Supprimer TOUT l'historique
            </button>
            
            <div id="historyList"></div>
        </div>
    `;

            document.body.appendChild(modal);

            // Remplir la liste
            const listDiv = document.getElementById('historyList');

            if (historyItems.length === 0) {
                listDiv.innerHTML = '<p style="text-align: center; color: #6c757d; padding: 40px;">Aucune sauvegarde trouvée</p>';
                return;
            }

            // Limiter l'affichage
            const displayItems = historyItems.slice(0, SAVE_CONFIG.maxHistoryDisplay);

            const listHTML = displayItems.map(item => `
        <div class="history-item" style="border: 1px solid #dee2e6; border-radius: 8px; padding: 15px; margin-bottom: 10px; transition: all 0.3s ease;">
            <div style="display: flex; justify-content: space-between; align-items: center; gap: 10px;">
                <div style="flex: 1;">
                    <div style="font-weight: bold; color: #2c3e50; margin-bottom: 5px;">${item.filename}</div>
                    <div style="color: #6c757d; font-size: 0.9em;">
                        📅 ${item.date} | 💾 ${(item.size / 1024).toFixed(2)} Ko
                    </div>
                </div>
                <div style="display: flex; gap: 8px;">
                    <button class="restore-btn" data-file="${item.filename}" style="padding: 8px 12px; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer; white-space: nowrap; width: auto; margin-bottom: 0;">
                        🔄 Restaurer
                    </button>
                    <a href="${SERVER_URL}?history=${encodeURIComponent(item.filename)}" download="${item.filename}" style="padding: 8px 12px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; text-decoration: none; display: inline-block; white-space: nowrap; width: auto; margin-bottom: 0;">
                        ⬇️ Télécharger
                    </a>
                    <button class="delete-btn" data-file="${item.filename}" style="padding: 8px 12px; background: #eb3349; color: white; border: none; border-radius: 4px; cursor: pointer; width: auto; margin-bottom: 0;">
                        🗑️ Supprimer
                    </button>
                </div>
            </div>
        </div>
    `).join('');

            listDiv.innerHTML = listHTML;

            // Event listeners
            document.querySelectorAll('.restore-btn').forEach(btn => {
                btn.addEventListener('click', async () => {
                    const filename = btn.dataset.file;
                    const success = await loadFromHistory(filename);
                    if (success) {
                        modal.remove();
                    }
                });
            });

            document.querySelectorAll('.delete-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    deleteHistoryFile(btn.dataset.file, btn);
                });
            });

            document.getElementById('closeHistoryModal').addEventListener('click', () => {
                modal.remove();
            });

            document.getElementById('deleteAllHistoryBtn').addEventListener('click', () => {
                deleteAllHistory();
            });

            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }

        // ===== GESTION DES MODES =====

        function setMode(mode) {
            currentSaveMode = mode;

            // NOUVEAU: Récupérer les éléments du switch
            const modeSwitch = document.getElementById('modeSwitch');
            const modeSwitchLabel = document.getElementById('modeSwitchLabel');
            const saveStrategySelector = document.getElementById('saveStrategySelector');
            const btnShowHistory = document.getElementById('btnShowHistory');

            if (mode === SAVE_CONFIG.modes.ARBITER) {
                // Mode Arbitre : peut sauvegarder
                if (modeSwitch) modeSwitch.checked = true;
                if (modeSwitchLabel) modeSwitchLabel.textContent = 'Arbitre';
                if (btnShowHistory) btnShowHistory.disabled = false;
                if (saveStrategySelector) saveStrategySelector.disabled = false;

                document.body.classList.remove('spectator-mode');

                // --- CORRECTION AJOUTÉE ---
                if (typeof setTool === 'function') {
                    setTool('select'); // Remettre l'outil "Sélection" par défaut
                }
                // --- FIN CORRECTION ---

                showSaveStatus('info', '👨‍⚖️ Mode Arbitre activé - Vous pouvez modifier et sauvegarder');

            } else {
                // Mode Spectateur : lecture seule
                if (modeSwitch) modeSwitch.checked = false;
                if (modeSwitchLabel) modeSwitchLabel.textContent = 'Spectateur';
                if (btnShowHistory) btnShowHistory.disabled = false; // Peut voir l'historique
                if (saveStrategySelector) saveStrategySelector.disabled = true;

                document.body.classList.add('spectator-mode');

                // --- CORRECTION AJOUTÉE ---
                if (typeof setTool === 'function') {
                    setTool('pan'); // Forcer le mode "Bouger"
                }
                // --- FIN CORRECTION ---

                showSaveStatus('info', '👁️ Mode Spectateur activé - Lecture seule');
            }

            // Réinitialiser les intervalles
            setupAutoSaveIntervals();
        }

        // ===== CONFIGURATION DES INTERVALLES =====

        // ===== CONFIGURATION DES INTERVALLES =====

        function setupAutoSaveIntervals() {
            // Nettoyer les anciens intervalles (AJOUT DE window.)
            if (window.localSaveInterval) clearInterval(window.localSaveInterval);
            if (window.serverSyncInterval) clearInterval(window.serverSyncInterval);

            const strategySelect = document.getElementById('saveStrategySelector');
            if (!strategySelect) return;

            const strategy = strategySelect.value;

            if (strategy === 'local_only') {
                // MODE LOCAL
                if (currentSaveMode === SAVE_CONFIG.modes.ARBITER) {
                    // AJOUT DE window.
                    window.localSaveInterval = setInterval(() => {
                        saveToLocalStorage();
                    }, SAVE_CONFIG.intervals.LOCAL_SAVE);
                }
                console.log('Mode local: Sauvegarde locale activée, serveur désactivé');

            } else if (strategy === 'server_only') {
                // MODE SERVEUR
                // AJOUT DE window.
                window.serverSyncInterval = setInterval(() => {
                    syncFromServerIfNeeded();
                }, SAVE_CONFIG.intervals.SERVER_SYNC);
                console.log('Mode serveur: Synchronisation serveur activée');
            }
        }

        // ===== ÉVÉNEMENTS DE L'INTERFACE =====

        function initSaveControls() {
            console.log('🔧 Initialisation des contrôles de sauvegarde...');

            setTimeout(() => {
                // MODIFIÉ: Cible le nouvel interrupteur
                const modeSwitch = document.getElementById('modeSwitch');
                const saveStrategySelector = document.getElementById('saveStrategySelector');
                const btnShowHistory = document.getElementById('btnShowHistory');

                console.log('🔍 Éléments trouvés:', {
                    modeSwitch: !!modeSwitch, // Modifié
                    saveStrategySelector: !!saveStrategySelector,
                    btnShowHistory: !!btnShowHistory
                });

                if (!modeSwitch) { // Modifié
                    console.error('❌ Interrupteur de mode non trouvé !'); // Modifié
                    return;
                }

                // MODIFIÉ: Listener pour l'interrupteur (change)
                modeSwitch?.addEventListener('change', (e) => {
                    const isChecked = e.target.checked;

                    if (isChecked) {
                        // --- Tente de passer en mode Arbitre ---
                        if (!arbiterPassword) {
                            // Pas de mot de passe défini, créer un maintenant
                            alert("⚠️ Aucun mot de passe arbitre n'est défini.\n\nVeuillez en créer un pour sécuriser l'accès au mode Arbitre.");
                            document.getElementById('arbiterPassModal').style.display = 'flex';
                            e.target.checked = false; // Rester en spectateur
                            return;
                        }

                        // Afficher la modale de validation
                        document.getElementById('switchToArbiterModal').style.display = 'flex';
                        document.getElementById('switchArbiterPassInput').value = '';
                        document.getElementById('switchArbiterPassInput').focus();

                        // Remettre temporairement en spectateur (sera changé après validation)
                        e.target.checked = false;

                    } else {
                        // --- Passe en mode Spectateur (toujours autorisé) ---
                        setMode(SAVE_CONFIG.modes.SPECTATOR);
                    }
                });

                // Listener pour la stratégie
                saveStrategySelector?.addEventListener('change', (e) => {
                    const newStrategy = e.target.value;

                    // CORRECTION: Recharger les données selon la nouvelle stratégie
                    if (newStrategy === 'server_only') {
                        console.log('Changement vers mode serveur - Chargement serveur...');
                        loadFromServer(false); // false = action manuelle, afficher confirmation si conflit
                    } else if (newStrategy === 'local_only') {
                        console.log('Changement vers mode local - Chargement localStorage...');
                        const hasLocalData = localStorage.getItem(SAVE_KEY);
                        if (hasLocalData) {
                            loadFromLocalStorage();
                        } else {
                            showSaveStatus('info', 'Mode local activé - Aucune sauvegarde locale');
                        }
                    }

                    // NOUVEAU: Mémoriser le choix
                    try {
                        localStorage.setItem(STRATEGY_KEY, newStrategy);
                    } catch (e) {
                        console.warn("Impossible de mémoriser la stratégie de sauvegarde.", e);
                    }

                    setupAutoSaveIntervals();
                    showSaveStatus('info', '📡 Stratégie de sauvegarde mise à jour.');
                });

                btnShowHistory?.addEventListener('click', () => {
                    console.log('📂 Clic sur Historique');
                    showHistoryModal();
                });

                console.log('✅ Event listeners attachés');

                // Initialiser les intervalles
                setupAutoSaveIntervals();
            }, 500);
        }

        // Fonction pour valider le passage en mode Arbitre
        window.validateSwitchToArbiter = function () {
            const passwordInput = document.getElementById('switchArbiterPassInput');
            const enteredPassword = passwordInput.value;

            if (enteredPassword === arbiterPassword) {
                // Mot de passe correct
                document.getElementById('switchToArbiterModal').style.display = 'none';
                setMode(SAVE_CONFIG.modes.ARBITER); // setMode va cocher la case
                showSaveStatus('success', '✅ Mode Arbitre activé');
            } else {
                // Mot de passe incorrect
                alert('❌ Mot de passe incorrect');
                passwordInput.value = '';
                passwordInput.focus();
            }
        };

        // Fonction pour annuler le passage en mode Arbitre
        window.cancelSwitchToArbiter = function () {
            document.getElementById('switchToArbiterModal').style.display = 'none';
        };

        // ===== HOOK DE SAUVEGARDE APRÈS RÉSULTAT =====

        function onResultSaved() {
            // CORRECTION: Sauvegarder IMMÉDIATEMENT selon la stratégie stricte

            const strategySelect = document.getElementById('saveStrategySelector');
            if (!strategySelect) return;

            const strategy = strategySelect.value;

            // Vérifier qu'on est bien en mode arbitre
            if (currentSaveMode !== SAVE_CONFIG.modes.ARBITER) {
                console.log('Mode spectateur - Pas de sauvegarde');
                return;
            }

            // CORRECTION: Mode strictement séparé
            if (strategy === 'local_only') {
                // MODE LOCAL : Sauvegarder UNIQUEMENT en local
                console.log('Sauvegarde locale immédiate');
                saveToLocalStorage();
            } else if (strategy === 'server_only') {
                // MODE SERVEUR : Sauvegarder UNIQUEMENT sur serveur
                console.log('Sauvegarde serveur immédiate');
                saveToServer();
            }
        }

        // ==========================================
        // NOUVELLES FONCTIONS INTÉGRÉES
        // ==========================================

        // --- MODE PROJECTEUR ---
        function toggleProjectorMode() {
            document.body.classList.toggle('projector-mode');
            if (document.body.classList.contains('projector-mode')) {
                fitAllTables();
                // Passer en plein écran si possible
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen().catch(e => console.log(e));
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen().catch(e => console.log(e));
                }
                setTimeout(fitAllTables, 100);
            }
        }

        // --- MISE À JOUR ATOMIQUE DES SCORES ---
        async function updateScoreOnServer(roundKey, boardNumber, result) {
            // Ne rien faire si la synchro serveur est désactivée globalement
            if (typeof USE_SERVER_SYNC !== 'undefined' && !USE_SERVER_SYNC) return;

            // Ne rien faire en mode local_only
            const strategySelect = document.getElementById('saveStrategySelector');
            if (strategySelect && strategySelect.value === 'local_only') return;

            try {
                const response = await fetch(SERVER_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'update_score',
                        roundKey: roundKey,
                        boardNumber: boardNumber,
                        result: result
                    })
                });

                if (!response.ok) {
                    console.error("Erreur mise à jour score serveur:", response.status);
                    showSaveStatus('warning', '⚠️ Erreur synchro score serveur');
                } else {
                    const res = await response.json();
                    if (res.success) {
                        console.log("Score mis à jour sur serveur (atomique)");
                    }
                }
            } catch (e) {
                console.error("Exception mise à jour score:", e);
            }
        }

        // ===== INITIALISATION =====

        document.addEventListener('DOMContentLoaded', () => {
            initSaveControls();

            // CORRECTION: Charger VRAIMENT selon la stratégie
            const strategySelect = document.getElementById('saveStrategySelector');
            const strategy = strategySelect ? strategySelect.value : 'server_only';

            // IMPORTANT: Vérifier d'abord si on a des données locales
            const hasLocalData = localStorage.getItem(SAVE_KEY);

            if (strategy === 'local_only') {
                // MODE LOCAL : Charger UNIQUEMENT depuis localStorage, jamais depuis serveur
                if (hasLocalData) {
                    console.log('Mode local: Chargement depuis localStorage');
                    loadFromLocalStorage();
                } else {
                    console.log('Mode local: Aucune donnée locale - Nouveau tournoi');
                    showSaveStatus('info', 'Mode local - Nouveau tournoi');
                }
            } else {
                // MODE SERVEUR : Charger depuis serveur
                console.log('Mode serveur: Chargement depuis serveur');
                loadFromServer(true);
            }

            // NOUVEAU: Démarrer en mode SPECTATEUR par défaut
            setMode(SAVE_CONFIG.modes.SPECTATOR);

            // NOUVEAU: Listener pour Enter dans la modale de switch
            const switchModal = document.getElementById('switchToArbiterModal');
            if (switchModal) {
                switchModal.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        validateSwitchToArbiter();
                    } else if (e.key === 'Escape') {
                        cancelSwitchToArbiter();
                    }
                });
            }

            showSaveStatus('success', '🚀 Système de sauvegarde initialisé - Mode Spectateur');
        });

        // ===== EXPORT DES FONCTIONS =====

        window.ChessRoomSave = {
            saveLocal: saveToLocalStorage,
            saveServer: saveToServer,
            loadServer: loadFromServer,
            showHistory: showHistoryModal,
            setMode: setMode,
            onResultSaved: onResultSaved
        };
    </script>
    <script>
        // ... (Existing JS) ...

        // --- GLOBAL VARIABLES FOR OPTIMISTIC LOCKING ---
        let lastServerTimestamp = 0;

        // --- HEARTBEAT ---
        function updateConnectionStatus(status) {
            const el = document.getElementById('connectionStatus');
            if (el) {
                el.className = status;
                el.title = status === 'online' ? 'Connecté' : (status === 'offline' ? 'Déconnecté' : 'Vérification...');
            }
        }

        function checkConnection() {
            updateConnectionStatus('checking');
            // Use a lightweight HEAD request to test.php or save.php
            fetch('test.php', { method: 'HEAD', cache: 'no-store' })
                .then(response => {
                    if (response.ok) updateConnectionStatus('online');
                    else updateConnectionStatus('offline');
                })
                .catch(() => updateConnectionStatus('offline'));
        }
        // Start Heartbeat
        setInterval(checkConnection, 30000); // Check every 30s
        setTimeout(checkConnection, 1000); // Initial check

        // --- DARK MODE ---
        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
            const isDark = document.body.classList.contains('dark-mode');
            localStorage.setItem('chessRoomDarkMode', isDark);
        }
        // Init Dark Mode
        if (localStorage.getItem('chessRoomDarkMode') === 'true') {
            document.body.classList.add('dark-mode');
        }

        // --- FILTERS ---
            function filterTables(filter) {
        // 1. Gestion de l'apparence des boutons
        document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
        const activeBtn = document.getElementById('filterBtn' + filter.charAt(0).toUpperCase() + filter.slice(1));
        if (activeBtn) activeBtn.classList.add('active');

        // 2. Application du filtre sur les tables physiques
        physicalTables.forEach(table => {
            const element = document.getElementById(`phys-table-${table.id}`);
            if (!element) return;

            // On réinitialise l'affichage
            element.classList.remove('hidden-by-filter');

            if (filter === 'all') return; // Si "Toutes", on s'arrête là (tout est affiché)

            // 3. Analyse de l'état de la table
            let isTableEmpty = true;       // La table est-elle vide de joueurs ?
            let hasActiveGame = false;     // Y a-t-il au moins une partie en cours ?
            let isFullyFinished = true;    // Toutes les parties occupées sont-elles finies ?

            let boardsWithPlayers = 0;

            table.boards.forEach(board => {
                // Vérifie s'il y a des joueurs (Nom non vide)
                const hasPlayers = board.players && (
                    (board.players.white && board.players.white.name.trim() !== "") || 
                    (board.players.black && board.players.black.name.trim() !== "")
                );

                // Vérifie s'il y a un score
                const hasScore = board.score && (board.score.white !== '' || board.score.black !== '');

                if (hasPlayers) {
                    isTableEmpty = false;
                    boardsWithPlayers++;
                    
                    if (!hasScore) {
                        // Partie avec joueurs mais SANS score = En cours
                        hasActiveGame = true; 
                        isFullyFinished = false;
                    }
                }
            });

            // Si la table n'a que des échiquiers vides, elle n'est pas "finie", elle est juste vide.
            if (boardsWithPlayers === 0) {
                isFullyFinished = false; 
            }

            // 4. Logique de masquage selon le filtre choisi
            let shouldHide = false;

            if (filter === 'empty') {
                // On veut voir les vides -> on cache si NON vide
                if (!isTableEmpty) shouldHide = true;
            } 
            else if (filter === 'playing') {
                // On veut voir "En cours" -> on cache si Vide OU si tout est fini
                if (isTableEmpty || !hasActiveGame) shouldHide = true;
            } 
            else if (filter === 'finished') {
                // On veut voir "Terminées" -> on cache si Vide OU s'il reste une partie active
                if (isTableEmpty || !isFullyFinished) shouldHide = true;
            }

            // 5. Application
            if (shouldHide) {
                element.classList.add('hidden-by-filter');
            }
        });
        }

        // --- ATOMIC SCORE UPDATE ---
        async function updateScoreOnServer(roundKey, boardNumber, result) {
            // Check if server sync is enabled/relevant
            const strategySelect = document.getElementById('saveStrategySelector');
            if (strategySelect && strategySelect.value === 'local_only') return;

            try {
                const response = await fetch('update_score.php', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        roundKey: roundKey,
                        boardNumber: boardNumber,
                        result: result
                    })
                });
                const data = await response.json();
                if (data.success) {
                    showSaveStatus('success', 'Score mis à jour (Atomique)');
                    return true;
                } else {
                    console.error('Update Score Error:', data.error);
                    showSaveStatus('error', 'Erreur MAJ Score');
                    return false;
                }
            } catch (e) {
                console.error('Update Score Exception:', e);
                showSaveStatus('error', 'Erreur Connexion (Score)');
                return false;
            }
        }
    </script>

<script>
// =====================================================
// SYSTÈME DE SUIVI JOUEUR V7 (CORRECTIF NOMS ADVERSAIRES)
// =====================================================

window.watchedPlayerName = localStorage.getItem('chessRoomWatchedPlayer') || null;
window.lastFoundSignature = null; 
window.wakeLock = null;

document.addEventListener('DOMContentLoaded', () => {
    if (window.watchedPlayerName) {
        setTimeout(() => enableTrackingMode(window.watchedPlayerName), 500);
    }
});

window.updateSpectatorPlayerList = function() {
    const roundDisplay = document.getElementById('spectatorRoundDisplay');
    if (roundDisplay && typeof currentRoundKey !== 'undefined') {
        roundDisplay.textContent = currentRoundKey.replace('ronde', 'Ronde ').replace(/^r/, 'R');
    }

    if (document.getElementById('playerTrackingContainer').style.display !== 'none') return;

    const select = document.getElementById('spectatorPlayerSelect');
    if (!select) return;

    let players = [];
    if (typeof roundsStore !== 'undefined' && roundsStore[currentRoundKey]) {
        const data = roundsStore[currentRoundKey];
        if (data.physicalTables) {
            data.physicalTables.forEach(table => {
                table.boards.forEach(board => {
                    if (board.players) {
                        if (board.players.white && board.players.white.name) players.push(board.players.white.name.trim());
                        if (board.players.black && board.players.black.name) players.push(board.players.black.name.trim());
                    }
                });
            });
        }
    }
    players.sort((a, b) => a.localeCompare(b));
    players = [...new Set(players)];
    select.innerHTML = '<option value="">-- Choisir votre nom --</option>';
    players.forEach(name => {
        const option = document.createElement('option');
        option.value = name;
        option.text = name;
        select.appendChild(option);
    });
};

window.startAutoWatchFromList = function() {
    const select = document.getElementById('spectatorPlayerSelect');
    const name = select.value;
    if (!name) { alert("Merci de choisir un nom."); updateSpectatorPlayerList(); return; }
    enableTrackingMode(name);
};

function enableTrackingMode(name) {
    window.watchedPlayerName = name;
    localStorage.setItem('chessRoomWatchedPlayer', name);
    window.lastFoundSignature = null;
    
    document.getElementById('playerSelectContainer').style.display = 'none';
    document.getElementById('playerTrackingContainer').style.display = 'block';
    document.getElementById('trackingPlayerName').textContent = name;

    if ('wakeLock' in navigator) navigator.wakeLock.request('screen').catch(e => console.log(e));
    
    if (typeof renderAllTables === 'function') renderAllTables();
    checkAndRedirectPlayer();
}

window.stopAutoWatch = function() {
    window.watchedPlayerName = null;
    localStorage.removeItem('chessRoomWatchedPlayer');
    window.lastFoundSignature = null;
    
    document.getElementById('playerSelectContainer').style.display = 'block';
    document.getElementById('playerTrackingContainer').style.display = 'none';
    
    if (typeof renderAllTables === 'function') renderAllTables();
    updateSpectatorPlayerList();
};

// CŒUR DU SYSTÈME
window.checkAndRedirectPlayer = function() {
    const roundDisplay = document.getElementById('spectatorRoundDisplay');
    if (roundDisplay && typeof currentRoundKey !== 'undefined') {
        roundDisplay.textContent = currentRoundKey.replace('ronde', 'Ronde ').replace(/^r/, 'R');
    }

    if (!window.watchedPlayerName) return;
    const infoDiv = document.getElementById('trackingLiveInfo');
    if (!infoDiv) return;

    if (typeof roundsStore === 'undefined' || !currentRoundKey || !roundsStore[currentRoundKey]) {
        infoDiv.innerHTML = '<span style="color:#999;">Chargement...</span>';
        return;
    }

    const normalize = (str) => str ? str.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").trim() : "";
    const targetName = normalize(window.watchedPlayerName);
    
    const tables = roundsStore[currentRoundKey].physicalTables;
    let found = false;
    let foundData = {};

    for (const table of tables) {
        for (const board of table.boards) {
            if (board.players) {
                const pWhite = normalize(board.players.white.name);
                const pBlack = normalize(board.players.black.name);

                if (pWhite.includes(targetName) || pBlack.includes(targetName)) {
                    found = true;
                    const isWhite = pWhite.includes(targetName);
                    foundData = {
                        tableId: table.id,
                        boardNum: board.boardNumber,
                        color: isWhite ? '⚪ Blancs' : '⚫ Noirs',
                        // On récupère les vrais objets joueurs complets pour l'affichage
                        playerObj: isWhite ? board.players.white : board.players.black,
                        opponentObj: isWhite ? board.players.black : board.players.white,
                        // Pour le panneau latéral
                        opponentName: isWhite ? board.players.black.name : board.players.white.name,
                        opponentElo: isWhite ? board.players.black.elo : board.players.white.elo,
                        rawWhite: board.players.white, // Objet complet
                        rawBlack: board.players.black  // Objet complet
                    };
                    break;
                }
            }
        }
        if (found) break;
    }

    if (found) {
        const oppEloDisplay = foundData.opponentElo ? `(${foundData.opponentElo})` : '';
        infoDiv.innerHTML = `
            <div style="color: #667eea; font-weight: bold; font-size: 1.4em; margin-bottom: 5px;">Table ${foundData.boardNum}</div>
            <div style="font-size: 1.1em; margin-bottom: 5px;">${foundData.color}</div>
            <div style="font-size: 0.9em; color: #555;">Contre : <strong>${foundData.opponentName}</strong> ${oppEloDisplay}</div>
        `;
        infoDiv.style.borderColor = "#28a745"; 

        const currentSignature = currentRoundKey + "_" + foundData.boardNum + "_" + foundData.opponentName;
        
        // DÉTECTION DE CHANGEMENT POUR LE POPUP
        if (window.lastFoundSignature !== currentSignature) {
            console.log("Nouveau match détecté -> Zoom & Popup");
            window.lastFoundSignature = currentSignature;
            
            // 1. Scroll
            setTimeout(() => {
                const el = document.getElementById(`phys-table-${foundData.tableId}`);
                if(el) el.scrollIntoView({behavior: "smooth", block: "center"});
            }, 300);
            
            // 2. Popup CORRECTEMENT REMPLI
            if (typeof showPlayerTableInfo === 'function') {
                // Fermer l'ancien
                const oldModal = document.getElementById('playerTableInfoModal');
                if(oldModal) oldModal.style.display = 'none';

                setTimeout(() => {
                    // On passe les vrais objets joueurs ici !
                    showPlayerTableInfo(
                        { 
                            boardNumber: foundData.boardNum, 
                            players: { 
                                white: foundData.rawWhite, 
                                black: foundData.rawBlack 
                            } 
                        }, 
                        null, 
                        (foundData.color.includes('Blanc') ? 'white' : 'black'), 
                        window.watchedPlayerName, 
                        foundData.playerObj.elo // Elo du joueur suivi
                    );
                }, 400);
            }
        }

    } else {
        infoDiv.innerHTML = `
            <span style="font-size: 1.1em; font-weight: bold; color: #e67e22;">⏳ En attente...</span>
            <div style="font-size: 0.8em; color: #777; margin-top: 5px;">
                Pas de partie trouvée<br>dans la ronde en cours.
            </div>
        `;
        infoDiv.style.borderColor = "#e67e22";
    }
};
</script>

</body>

</html>