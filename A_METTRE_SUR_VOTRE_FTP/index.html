<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gestionnaire de Plan de Salles d'√âchecs</title>
    
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>

    <style>
        /* ... [La plupart du CSS est identique] ... */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 10px;
            font-size: 14px;
        }
        
        /* ... [CSS Mode Player identique] ... */
        body.player-plan-view-mode .sidebar,
        body.player-plan-view-mode .toolbar,
        body.player-plan-view-mode .shortcut-bar,
        body.player-plan-view-mode .zoom-controls,
        body.player-plan-view-mode #sidebarToggle {
            display: none !important;
        }
        
        body.player-plan-view-mode #playerPlanReturnButton {
            display: block;
        }

        /* =====================================================
            NOUVEAU: Verrouillage complet du Mode Spectateur
        =====================================================
        */
        
        /* 1. Cache tous les boutons d'action de la barre lat√©rale */
        .spectator-mode .sidebar-content button,
        .spectator-mode .sidebar-content input[type="file"],
        .spectator-mode .sidebar-content label.file-upload-label {
            display: none !important;
        }
        
        /* 2. Cache les boutons de la barre d'outils (sauf Outils de navigation) */
        .spectator-mode .tool-btn[onclick*="delete"],
        .spectator-mode .tool-btn[onclick*="duplicate"],
        .spectator-mode .tool-btn[onclick*="rotate"],
        .spectator-mode .tool-btn[onclick*="flip"],
        .spectator-mode .tool-btn[onclick*="undo"],
        .spectator-mode .tool-btn[onclick*="redo"],
        .spectator-mode .btn-success[onclick*="startQRScanner"] {
            display: none !important;
        }
        
        /* 3. D√©sactive les interactions sur le plan (tables, salles) */
        .spectator-mode .table-element,
        .spectator-mode .room-element,
        .spectator-mode .board-container {
            cursor: default !important;
            pointer-events: none !important; /* Bloque tous les clics */
        }
        
        /* 4. Cache les poign√©es de modification (au cas o√π) */
        .spectator-mode .delete-btn,
        .spectator-mode .rotate-btn,
        .spectator-mode .resize-handle,
        .spectator-mode .flip-btn-single,
        .spectator-mode .arbiter-flag,
        .spectator-mode .room-delete-btn,
        .spectator-mode .room-resize-handle {
            display: none !important;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: calc(100vh - 20px);
        }

        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
            transition: grid-template-columns 0.3s;
            position: relative; 
        }

        .sidebar {
            width: 200px;
            background: #f8f9fa;
            border-right: 2px solid #e9ecef;
            display: flex;
            flex-direction: column;
            /* MODIFI√â: overflow-y: hidden pour l'accord√©on */
            overflow-y: hidden; 
            transition: width 0.3s ease, padding 0.3s ease;
            position: relative;
            /* MODIFI√â: padding g√©r√© par les sections */
            padding: 0;
        }
        
        .main-content.sidebar-collapsed .sidebar {
            width: 0;
            padding: 0;
            border-right: none;
            overflow: hidden;
        }

        #sidebarToggle {
            position: absolute;
            top: 10px;
            left: 200px; 
            width: 28px;
            height: 28px;
            padding: 0;
            font-size: 1.2em;
            z-index: 1001; 
            border-radius: 50% 0 0 50%;
            margin-bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: left 0.3s ease;
            transform: translateX(-100%); 
        }
        
        .main-content.sidebar-collapsed #sidebarToggle {
            left: 0px; 
            border-radius: 0 50% 50% 0;
            transform: translateX(0);
        }

        /*
        =====================================================
            NOUVEAU SYST√àME ACCORD√âON
        =====================================================
        */
        .sidebar-section {
            /* MODIFI√â: Plus de padding/margin, g√©r√© par le contenu */
            margin-bottom: 0;
            border-bottom: 2px solid #e9ecef;
            /* min-width: 270px; */ /* MODIFI√â: Supprim√© ou comment√© */
        }
        .sidebar-section:last-child {
            border-bottom: none;
            /* NOUVEAU: Permet √† la derni√®re section de remplir l'espace */
            flex: 1; 
            display: flex;
            flex-direction: column;
            /* CORRECTION: Ajout√© pour forcer la contrainte de hauteur */
            min-height: 0;
        }

        .sidebar-section h3 {
            color: #2c3e50;
            font-size: 1.05em;
            display: flex;
            align-items: center;
            gap: 8px;
            /* NOUVEAU: Cliquable */
            padding: 15px;
            margin-bottom: 0;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .sidebar-section h3:hover {
            background-color: #e9ecef;
        }
        .sidebar-section h3.active {
            background-color: #667eea;
            color: white;
        }
        
        /* NOUVEAU: Conteneur du contenu de l'accord√©on */
        .sidebar-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
            padding: 0 15px; /* Padding lat√©ral */
            background: #ffffff;
        }
        
        .sidebar-content.expanded {
            /* NOUVEAU: Hauteur pour le contenu */
            max-height: 70vh; /* Hauteur max pour le contenu */
            overflow-y: auto; /* Scroll si besoin DANS la section */
            padding: 15px; /* Padding complet */
        }
        
        .sidebar-section:last-child .sidebar-content.expanded {
             /* NOUVEAU: Permet au dernier de s'√©tendre */
            max-height: none;
            flex: 1;
        }
        /* Fin NOUVEAU SYST√àME ACCORD√âON */


        .control-group {
            margin-bottom: 12px;
        }

        /* ... [Reste du CSS identique] ... */
        
        .control-group label {
            display: block;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 4px;
            font-size: 0.9em;
        }

        input[type="number"], input[type="text"], input[type="file"], select, input[type="password"] {
            width: 100%;
            padding: 6px 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 0.95em;
            transition: border-color 0.3s;
            background: white; 
        }
        
        .toolbar input[type="number"] {
            width: 60px;
            padding: 4px 8px;
            font-size: 0.9em;
            text-align: center;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #667eea;
        }

        button {
            width: 100%;
            padding: 8px 12px;
            font-size: 0.9em;
            font-weight: 600;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 6px;
        }

        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-primary, .btn-success, .btn-danger, .btn-secondary, .btn-info {
            color: white;
        }
        .btn-primary { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        .btn-success { background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); }
        .btn-danger { background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%); }
        .btn-secondary { background: linear-gradient(135deg, #6c757d 0%, #5a6268 100%); }
        .btn-info { background: linear-gradient(135deg, #17a2b8 0%, #138496 100%); }
        
        .btn-small {
            width: auto;
            padding: 4px 8px;
            font-size: 0.85em;
            margin-left: 5px;
        }

        .stats { display: grid; grid-template-columns: 1fr; gap: 8px; }
        .stat-item { background: white; padding: 8px; border-radius: 6px; border: 2px solid #e9ecef; }
        .stat-label { color: #6c757d; font-size: 0.85em; font-weight: 600; }
        .stat-value { color: #2c3e50; font-weight: 700; font-size: 1.3em; }

        .workspace {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #ecf0f1;
            position: relative;
            overflow: hidden;
        }

        .toolbar {
            background: white;
            padding: 4px 10px; /* MODIFI√â: 10px est devenu 6px */
            border-bottom: 2px solid #e9ecef;
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        .toolbar button {
            width: auto;
            padding: 3px 6px;
            font-size: 0.8em;
            margin: 0;
        }
        
        .timer-controls {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-left: 15px;
            padding-left: 15px;
            border-left: 2px solid #e9ecef;
        }
        #roundTimer {
            font-size: 1.1em;   /* MODIFI√â: 1.3em est devenu 1.1em */
            font-weight: 700;
            color: #2c3e50;
            background: #f8f9fa;
            padding: 3px 6px;   /* MODIFI√â: 4px 10px est devenu 3px 8px */
            border-radius: 6px;
            min-width: 70px;
            text-align: center;
        }
        #roundTimer.timer-countdown { color: #1565c0; }
        #roundTimer.timer-elapsed { color: #c62828; }
        #roundTimer.timer-flash { animation: flash 1s infinite; }
        @keyframes flash {
            0%, 100% { background-color: #69f0ae; }
            50% { background-color: #f8f9fa; }
        }

        .tool-btn { background: #e9ecef; color: #2c3e50; }
        
        .toolbar .tool-btn[onclick="undo()"],
        .toolbar .tool-btn[onclick="redo()"] {
            font-size: 1.1em;
            padding: 6px 8px;
        }

        .tool-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            overflow: auto;
            background: 
                linear-gradient(90deg, #ddd 1px, transparent 1px),
                linear-gradient(#ddd 1px, transparent 1px);
            background-size: 50px 50px;
        }

        .canvas {
            position: relative;
            width: 3000px;
            height: 2000px;
            cursor: default;
            transform-origin: 0 0;
        }

        .canvas.move-mode { cursor: grab; }
        .canvas.move-mode:active { cursor: grabbing; }

        .table-element {
            position: absolute;
            background: white;
            border: 3px solid #2c3e50;
            border-radius: 8px;
            padding: 8px; 
            cursor: move;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            transition: box-shadow 0.3s, transform 0.3s;
            min-width: 150px; 
            user-select: none;
            transform-origin: top left;
            z-index: 10;
        }

        .table-element:hover {
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
            z-index: 100;
        }

        .table-element.selected {
            border-color: #667eea;
            box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.5);
            z-index: 101;
        }
        
        .table-element.has-pairing {
            background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
            border-color: #4caf50;
        }

        .table-content { transform-origin: center center; }

        .table-element.rotate-0 { transform: rotate(0deg); }
        .table-element.rotate-90 { transform: rotate(90deg); }
        .table-element.rotate-180 { transform: rotate(180deg); }
        .table-element.rotate-270 { transform: rotate(270deg); }

        .board-container {
            position: relative;
            padding: 4px; 
            flex: 1; 
            border-right: 1px solid #ddd; 
            border-bottom: none;
            min-width: 140px; 
            transition: background-color 0.3s, border-color 0.3s; 
        }
        .board-container:last-child { border-right: none; border-bottom: none; }
        
        .board-container.board-scored {
            background-color: #ffebee; 
            border-color: #c62828; 
        }

        .canvas.moveboard-mode .board-container { cursor: grab; }
        .canvas.moveboard-mode .board-container:active { cursor: grabbing; }
        .canvas.moveboard-mode .board-container.over { background-color: rgba(102, 126, 234, 0.2); }

        body.player-plan-view-mode .board-container.has-players {
            cursor: pointer;
        }
        body.player-plan-view-mode .board-container.has-players:hover {
            background-color: rgba(102, 126, 234, 0.2);
        }


        .board-number {
            font-size: 1.4em; 
            font-weight: 700;
            color: #667eea;
            margin-bottom: 5px; 
            text-align: center;
        }

        .table-element.has-pairing .board-number { color: #2e7d32; }
        
        .table-content-inner { 
            display: flex; 
            width: 100%;
        }
        
        .player-comment {
            font-size: 0.9em;
            font-style: italic;
            color: #b71c1c; 
            padding: 2px 4px;
            background: #fff9c4; 
            border-radius: 3px;
            text-align: center;
            margin-bottom: 3px;
            white-space: normal; 
            word-wrap: break-word;
        }

        .player {
            display: flex;
            align-items: center;
            gap: 6px; 
            padding: 4px 6px;
            font-size: 0.85em;
            background: rgba(255,255,255,0.7);
            border-radius: 5px;
            margin-top: 5px;
            overflow: hidden; 
            min-height: 40px; 
        }
        
        .player-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid #2c3e50;
            flex-shrink: 0;
        }

        .player-color.white { background: white; }
        .player-color.black { background: #2c3e50; }

        .player-info {
            flex: 1; 
            min-width: 0; 
            display: flex;
            flex-direction: column; 
        }

        .player-name {
            font-weight: 400;
            color: #2c3e50;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.2;
            cursor: pointer; 
        }
        .player-name:hover { color: #667eea; }
        .player-name .lastname {
            font-weight: 700;
            text-transform: uppercase;
        }
        
        .player-elo {
            font-size: 0.9em;
            color: #6c757d;
            white-space: nowrap;
        }

        .player-score {
            font-weight: 700;
            font-size: 1.1em;
            padding: 4px 8px;
            cursor: pointer;
            border-radius: 4px;
            margin-left: auto; 
            flex-shrink: 0;
        }
        .player-score:hover { background: #e0e0e0; }

        .table-element.expanded .player-name {
            white-space: normal;
            overflow: visible;
            text-overflow: clip;
        }

        .delete-btn, .rotate-btn {
            position: absolute;
            width: 24px;
            height: 24px;
            color: white;
            border: 2px solid white;
            border-radius: 50%;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            z-index: 5;
        }
        .delete-btn { background: #f44336; top: -10px; right: -10px; }
        .rotate-btn { background: #2196f3; bottom: -10px; right: -10px; font-size: 12px; }
        
        .arbiter-flag {
            position: absolute;
            width: 24px;
            height: 24px;
            color: #424242;
            border: 2px solid white;
            background: #eeeeee;
            border-radius: 50%;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            z-index: 5;
            top: -10px;
            left: -10px;
        }
        .arbiter-flag.flag-red { background: #f44336; color: white; }
        .arbiter-flag.flag-yellow { background: #ffeb3b; color: #424242; }
        .arbiter-flag.flag-green { background: #4caf50; color: white; }
        .arbiter-flag.flag-none { display: none; }
        .table-element.selected .arbiter-flag { display: flex; }
        .table-element .arbiter-flag:not(.flag-none) { display: flex; }

        .table-element.selected .delete-btn,
        .table-element.selected .rotate-btn {
            display: flex;
        }
        
        .flip-btn-single {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 20px;
            height: 20px;
            background: #ff9800;
            color: white;
            border: 1px solid white;
            border-radius: 50%;
            cursor: pointer;
            display: none; 
            align-items: center;
            justify-content: center;
            font-size: 10px;
            padding: 0;
            margin: 0;
            z-index: 5;
        }
        
        .table-element.selected .flip-btn-single { display: flex; }
        .flip-btn-single:hover { background: #f57c00; }

        .resize-handle {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 24px;
            height: 30px;
            background: #2196f3;
            color: white;
            border: 2px solid white;
            border-radius: 5px;
            cursor: ew-resize;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            z-index: 102;
        }
        .resize-handle.handle-left { left: -12px; }
        .resize-handle.handle-right { right: -12px; }
        
        .table-element.rotate-90 .resize-handle,
        .table-element.rotate-270 .resize-handle {
            cursor: ns-resize;
        }

        .table-element.selected .resize-handle { display: flex; }

        .selection-box {
            position: absolute;
            border: 2px dashed #667eea;
            background: rgba(102, 126, 234, 0.1);
            pointer-events: none;
            z-index: 9999;
        }

        .zoom-controls {
            position: absolute;
            bottom: 35px; 
            right: 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            padding: 8px;
            display: flex;
            align-items: center; 
            gap: 8px; 
            z-index: 1000;
        }

        .zoom-btn {
            width: 32px; 
            height: 32px; 
            padding: 0;
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1em;
            flex-shrink: 0; 
        }
        
        .zoom-slider {
            width: 120px; 
            margin: 0 5px;
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: #ddd;
            outline: none;
            border-radius: 5px;
        }

        .zoom-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #667eea;
            cursor: pointer;
            border-radius: 50%;
        }

        .zoom-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #667eea;
            cursor: pointer;
            border-radius: 50%;
        }

        .file-upload-label {
            width: 100%;
            padding: 8px 14px;
            font-size: 0.9em;
            font-weight: 600;
            border-radius: 6px;
            cursor: pointer;
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); 
            color: white;
            display: block;
            text-align: center;
            margin-bottom: 6px;
        }

        input[type="file"] { display: none; }
        
        #ghost {
            background: white;
            border: 2px dashed #667eea;
            padding: 10px;
            border-radius: 8px;
            pointer-events: none;
        }

        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            display: none; 
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            font-weight: bold;
            z-index: 9999;
            flex-direction: column;
            gap: 20px;
        }
        
        #loadingOverlay::before {
            content: '‚è≥';
            font-size: 3em;
            animation: spin 1.5s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        /* Modale de Score */
        #scoreModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: none; 
            align-items: center;
            justify-content: center;
            /* MODIFICATION Z-INDEX */
            z-index: 10002; 
        }
        #scoreModalContent {
            background: white;
            padding: 20px 25px;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            width: 300px;
        }
        #scoreModalContent h4 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.2em;
        }
        #scoreModalContent p {
            font-size: 0.95em;
            margin-bottom: 10px;
        }
        #scoreModalSelect {
            width: 100%;
            font-size: 1.1em;
            padding: 8px 10px;
            margin-bottom: 20px;
        }
        .score-modal-buttons {
            display: flex;
            gap: 10px;
        }
        .score-modal-buttons button {
            margin-bottom: 0;
        }

        /* Barre d'aide Raccourcis */
        .shortcut-bar {
            background: #4a4a4a;
            color: #f0f0f0;
            padding: 4px 15px;
            font-size: 0.8em;
            text-align: center;
            z-index: 1000;
            position: absolute;
            bottom: 0;
            width: 100%;
            border-top: 1px solid #666;
        }
        .shortcut-bar span {
            margin-left: 50px;
            margin-right: 5px;
            color: #fafafa;
            background: #616161;
            padding: 2px 5px;
            border-radius: 4px;
        }

        /*
        =====================================================
            STYLES CSS QR AJOUT√âS
        =====================================================
        */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: none; 
            align-items: center;
            justify-content: center;
            /* MODIFICATION Z-INDEX */
            z-index: 10002; /* Mettre au-dessus de playerHomeModal */
        }
        .modal-content {
            background: white;
            padding: 20px 25px;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            width: 90%;
            max-width: 500px;
        }
        .modal-content h2, .modal-content h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            text-align: center;
        }

        /* Styles pour la notification */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 16px 24px;
            border-radius: 10px;
            color: white;
            font-weight: 600;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            /* MODIFICATION Z-INDEX */
            z-index: 10003; /* Au-dessus de tout */
            opacity: 0;
            transform: translateX(400px);
            transition: all 0.3s;
        }
        .notification.show {
            opacity: 1;
            transform: translateX(0);
        }
        .notification.success { background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); }
        .notification.error { background: linear-gradient(135deg, #ee0979 0%, #ff6a00 100%); }
        .notification.info { background: linear-gradient(135deg, #17a2b8 0%, #138496 100%); }
        
        .info-box {
            background: #e7f3ff;
            border-left: 4px solid #2196F3;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
        
        /*
        =====================================================
            STYLES CSS SALLES / MURS (MODIFI√âS)
        =====================================================
        */
        .room-element {
            position: absolute;
            background: rgba(102, 126, 234, 0.05);
            border: 3px dashed #667eea;
            border-radius: 10px;
            min-width: 200px;
            min-height: 200px;
            cursor: move;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            user-select: none;
            padding-top: 30px;
            z-index: 1;
        }

        .room-element.selected {
            border-style: solid;
            border-color: #764ba2;
            background: rgba(102, 126, 234, 0.1);
            z-index: 5;
            }

        .room-title {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            background: #667eea;
            color: white;
            padding: 4px 10px;
            font-weight: 600;
            font-size: 0.9em;
            border-radius: 8px 8px 0 0;
            text-align: center;
            cursor: pointer;
        }
        
        .room-delete-btn {
            position: absolute;
            width: 24px;
            height: 24px;
            color: white;
            border: 2px solid white;
            border-radius: 50%;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            z-index: 6;
            background: #f44336; 
            top: -10px; 
            right: -10px;
        }
        
        .room-element.selected .room-delete-btn {
            display: flex;
        }

        .room-resize-handle {
            position: absolute;
            width: 15px;
            height: 15px;
            background: #667eea;
            border: 2px solid white;
            border-radius: 50%;
            z-index: 6;
        }
        .room-resize-handle.br {
            bottom: -8px;
            right: -8px;
            cursor: se-resize;
        }
        .room-resize-handle.bl {
            bottom: -8px;
            left: -8px;
            cursor: sw-resize;
        }
        .room-resize-handle.tr {
            top: -8px;
            right: -8px;
            cursor: ne-resize;
        }
        .room-resize-handle.tl {
            top: -8px;
            left: -8px;
            cursor: nw-resize;
        }

        .room-element:not(.selected) .room-resize-handle {
            display: none;
        }
        
        #playerPlanReturnButton {
            position: fixed;
            /* MODIFI√â: en bas au centre et plus petit */
            bottom: 20px; 
            left: 50%;
            transform: translateX(-50%);
            z-index: 10002;
            /* MODIFI√â: padding et font-size */
            padding: 8px 16px;
            font-size: 0.9em; 
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
            display: none; /* Cach√© par d√©faut */
            width: auto; /* NOUVEAU */
            margin-bottom: 0; /* NOUVEAU */
        }
        
        body.player-plan-view-mode .sidebar,
        body.player-plan-view-mode .toolbar,
        body.player-plan-view-mode .shortcut-bar,
        body.player-plan-view-mode .zoom-controls,
        body.player-plan-view-mode #sidebarToggle {
            display: none !important;
        }
        
        body.player-plan-view-mode #playerPlanReturnButton {
            display: block;
        }

        /* NOUVEAU: R√©duire la taille des boutons dans la sidebar */
        .sidebar-content button {
            font-size: 0.8em; /* Plus petit pour s'adapter √† 200px */
            padding: 6px 8px; /* Ajuster le padding */
        }

        /* NOUVEAU: Styles pour le d√©compte plein √©cran */
        #bigTimerOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            
            /* Cach√© par d√©faut */
            display: none; 
            
            /* Centrage */
            align-items: center;
            justify-content: center;
            
            /* Au-dessus du plan, mais sous les modales */
            z-index: 10000; 
            
            /* TR√àS IMPORTANT: Laisse passer les clics ! */
            pointer-events: none; 
        }

        #bigTimerDisplay {
            font-size: 15vw; /* Taille √©norme qui s'adapte √† l'√©cran */
            font-weight: bold;
            color: white;
            
            /* Ombre pour la lisibilit√© sur tous les fonds */
            text-shadow: 0 0 25px rgba(0, 0, 0, 0.8), 0 0 10px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="main-content">
            <button id="sidebarToggle" onclick="toggleSidebar()" class="btn-secondary" title="Masquer/Afficher le volet">¬´</button>
            
            <div class="sidebar">
                
                <div class="sidebar-section">
                    <h3 onclick="toggleAccordion(this)">üìä Statistiques</h3>
                    <div class="sidebar-content">
                        <div class="stats">
                            <div class="stat-item">
                                <div class="stat-label">Total</div>
                                <div class="stat-value" id="totalBoards">0</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">√âchiquiers</div>
                                <div class="stat-value" id="pairedBoards">0</div>
                            </div>
                            
                            <div class="stat-item" style="background-color: #fff3cd; border-color: #ffeeba;">
                                <div class="stat-label" style="color: #856404;">Restants</div>
                                <div class="stat-value" id="remainingBoards" style="color: #856404;">0</div>
                            </div>
                            
                            <div class="stat-item">
                                <div class="stat-label">Joueurs</div>
                                <div class="stat-value" id="totalPlayers">0</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="sidebar-section" id="saveControlsSection">
                    <h3 onclick="toggleAccordion(this)">üíæ Sauvegardes</h3>
                    <div class="sidebar-content">
                        
                        <div class="control-group" style="margin-top: 12px;">
                            <label for="modeSelector" style="font-weight: bold;">üéÆ Mode de Fonctionnement :</label>
                            <select id="modeSelector" style="font-weight: 600;">
                                <option value="arbiter">üë®‚Äç‚öñÔ∏è Arbitre</option>
                                <option value="spectator">üëÅÔ∏è Spectateur</option>
                            </select>
                        </div>
                        
                        <div class="control-group">
                            <label for="saveStrategySelector" style="font-weight: bold;">üì° Mode de Sauvegarde :</label>
                            <select id="saveStrategySelector">
                                <option value="server_local">Serveur + Local</option>
                                <option value="server_only">Serveur Seul</option>
                                <option value="local_only">Local Seul</option>
                                <option value="manual">Manuel</option>
                            </select>
                        </div>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 12px;">
                            <button id="btnForceSaveServer" class="btn-primary" style="font-size: 0.85em; padding: 8px 6px;">
                                ‚òÅÔ∏è Sauvegarde Serveur
                            </button>
                            <button id="btnLoadServer" class="btn-info" style="font-size: 0.85em; padding: 8px 6px;">
                                üîÑ Recharger Serveur
                            </button>
                        </div>
                        <button id="btnShowHistory" class="btn-secondary" style="margin-top: 8px;">
                            üìÇ Historique
                        </button>
                        
                        <div id="saveStatus" style="margin-top: 10px; padding: 8px; border-radius: 4px; font-size: 0.8em; display: none; word-wrap: break-word;">
                            </div>
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3 onclick="toggleAccordion(this)">‚õ≥Ô∏è Rondes</h3>
                    <div class="sidebar-content">
                        <div class="control-group">
                            <label for="roundSelector">Ronde Actuelle :</label>
                            <select id="roundSelector" onchange="switchRound(this.value)"></select>
                        </div>
                        <button class="btn-primary" onclick="addNewRound()">+ Nouvelle Ronde</button>
                        <button class="btn-secondary" onclick="cloneRoundLayout()">+ Cloner la dispo</button>
                        
                        <button class="btn-danger" style="margin-top: 5px;" onclick="deleteCurrentRound()">- Supprimer la Ronde</button>
                        
                        <hr style="margin: 10px 0; border: 1px solid #e9ecef;">
                        
                        <button class="btn-danger" onclick="createNewTournament()">‚ö†Ô∏è Nouveau Tournoi</button>
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3 onclick="toggleAccordion(this)">‚ûï Disposition</h3>
                    <div class="sidebar-content">
                        
                        <div class="control-group">
                            <label for="boardsPerTable">√âchiquiers par table physique :</label>
                            <input type="number" id="boardsPerTable" min="1" max="10" value="1">
                        </div>
                        <div class="control-group">
                            <label for="physicalTablesPerRow">Tables par rang√©e :</label>
                            <input type="number" id="physicalTablesPerRow" min="1" max="20" value="10">
                        </div>
                        <div class="control-group">
                            <label for="tableLength">Longueur des tables :</label>
                            <input type="number" id="tableLength" min="100" max="300" value="180" step="10">
                        </div>
                        <div class="control-group">
                            <label for="startCorner">Position de d√©part :</label>
                            <select id="startCorner">
                                <option value="tl">En haut √† gauche</option>
                                <option value="tr">En haut √† droite</option>
                                <option value="bl">En bas √† gauche</option>
                                <option value="br">En bas √† droite</option>
                            </select>
                        </div>
                        <button class="btn-secondary" onclick="autoArrangeTables()">üìê R√©organiser le plan</button>
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3 onclick="toggleAccordion(this)">üèõÔ∏è Salles</h3>
                    <div class="sidebar-content">
                        <div class="control-group">
                            <label for="roomNameInput">Nom de la salle/zone :</label>
                            <input type="text" id="roomNameInput" placeholder="Ex: Salle A, Zone Calme...">
                        </div>
                        <button class="btn-info" onclick="addRoom()">+ Ajouter une Salle/Mur</button>
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3 onclick="toggleAccordion(this)">üéÆ Appariements</h3>
                    <div class="sidebar-content">
                        <label for="pairingFileInput" class="file-upload-label">üìÅ Charger</label>
                        <input type="file" id="pairingFileInput" accept=".html,.htm" onchange="loadPapiFile(event)">
                        
                        <hr style="margin: 10px 0; border: 1px solid #e9ecef;">
                        
                        <div class="control-group">
                            <label for="boardCount">√âchiquiers √† cr√©er :</label>
                            <input type="number" id="boardCount" min="1" max="2000" value="10">
                        </div>
                        <button class="btn-primary" onclick="addBoards()">Ajouter</button>
                        
                        <hr style="margin: 10px 0; border: 1px solid #e9ecef;">
                        
                        <button class="btn-danger" onclick="clearPairings()">Effacer</button>
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3 onclick="toggleAccordion(this)">üîç Joueurs</h3>
                    <div class="sidebar-content">
                        <div class="control-group">
                            <label for="searchInput">Chercher √©chiquier/joueur :</label>
                            <input type="text" id="searchInput" placeholder="Nom ou num√©ro d'√©chiquier..." oninput="searchTables()" list="search-suggestions">
                            <datalist id="search-suggestions"></datalist>
                        </div>
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3 onclick="toggleAccordion(this)">üì† QR-codes</h3>
                    <div class="sidebar-content">
                        <div class="control-group">
                            <label for="qrNumTables">Nombre d'√©chiquiers √† g√©n√©rer :</label>
                            <input type="number" id="qrNumTables" min="1" max="2000" value="50">
                        </div>
                        <button class="btn-info" onclick="generateQRFiches()">üñ®Ô∏è G√©n√©rer Fiches QR</button>
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3 onclick="toggleAccordion(this)">üéõÔ∏è Actions</h3>
                    <div class="sidebar-content">
                        <button class="btn-info" onclick="exportToPDF()">üìÑ R√©sultats</button>
                        
                        <button class="btn-secondary" onclick="exportToTRF()" style="margin-top: 5px;">
                            üåç Export TRF (FIDE)
                        </button>
                        <hr style="margin: 10px 0; border: 1px solid #e9ecef;">
                        <div class="control-group" style="margin-top: 10px; margin-bottom: 5px;">
                            <label for="pdfOrientation" style="font-size: 0.9em;">Orientation :</label>
                            <select id="pdfOrientation" style="padding: 4px 8px; font-size: 0.9em;">
                                <option value="l">Paysage</option>
                                <option value="p">Portrait</option>
                            </select>
                        </div>
                        <button class="btn-info" id="exportVisualPdfBtn" onclick="exportVisualPDF()">üñ®Ô∏è Plan</button>
                        
                        <hr style="margin: 10px 0; border: 1px solid #e9ecef;">
                        
                        <button class="btn-info" onclick="showArbiterPasswordModal()">üîê D√©finir Mot de Passe</button>
                        <button class="btn-success" onclick="showPlayerLoginModal()">üßë‚Äçü§ù‚Äçüßë Mode Saisie Joueurs</button>
                        
                        <hr style="margin: 10px 0; border: 1px solid #e9ecef;">

                        <button class="btn-secondary" onclick="saveLayout()">üíæ Sauvegarder le Tournoi</button>
                        <button class="btn-secondary" onclick="loadLayout()">üìÇ Charger le Tournoi</button>
                        <button class="btn-danger" onclick="clearAll()">üóëÔ∏è Tout effacer</button>
                    </div>
                </div>
            </div> <div class="workspace">
                <div class="toolbar">
                    <button class="tool-btn active" onclick="setTool('select')" id="selectTool">
                        &nbsp;&nbsp;&nbsp;üñ±Ô∏è S√©lection
                    </button>
                    <button class="tool-btn" onclick="setTool('multiselect')" id="multiselectTool">
                        ‚òëÔ∏è Plusieurs
                    </button>
                    <button class="tool-btn" onclick="setTool('pan')" id="panTool">
                        ‚úã Bouger
                    </button>
                    <button class="tool-btn" onclick="setTool('moveboard')" id="moveboardTool">
                        ‚á≠ D√©placer
                    </button>
                    
                    <button class="tool-btn" onclick="undo()" id="undoButton" title="Annuler (Ctrl+Z)" disabled>
                        ‚Ü∂
                    </button>
                    <button class="tool-btn" onclick="redo()" id="redoButton" title="R√©tablir (Ctrl+Y)" disabled>
                        ‚Ü∑
                    </button>
                    
                    <button class="tool-btn" onclick="deleteSelected()" title="Supprimer (Touche Suppr ou Retour)">
                        üóëÔ∏è Effacer
                    </button>
                    <button class="tool-btn" onclick="duplicateSelected()" title="Dupliquer (Ctrl+D)">
                        üìã Dupliquer
                    </button>
                    <button class="tool-btn" onclick="rotateSelected()" title="Rotation (R)">
                        ‚Üª Tourner
                    </button>
                    <button class="tool-btn" onclick="flipPlayersSelected()">
                        üîÑ Inverser
                    </button>

                    <button class="btn-success" onclick="startQRScanner()" title="Scanner un r√©sultat par QR Code" style="margin: 0;">
                        üì∑ QR-codes
                    </button>
                    
                    <div class="timer-controls">
                        <label for="timerMinutes" style="font-size: 0.9em; color: #333;">Minuteur :</label>
                        <input type="number" id="timerMinutes" value="15" min="-240">
                        <button class="btn-success btn-small" onclick="startRoundTimer()">‚ñ∂</button>
                        <button class="btn-danger btn-small" onclick="stopRoundTimer()">‚èπ</button>
                        <span id="roundTimer">00:00</span>
                    </div>

                    <div style="margin-left: auto; color: #6c757d; font-size: 0.9em;">
                        Nb: <span id="selectedCount">0</span> | Z: <span id="zoomLevel">100%</span>
                    </div>
                </div>

                <div class="canvas-container" id="canvasContainer">
                    <div class="canvas" id="canvas"></div>
                </div>

                <div class="zoom-controls">
                    <input type="range" min="10" max="200" value="100" class="zoom-slider" id="zoomSlider" 
                           oninput="applyZoom(this.value / 100)" 
                           onchange="applyZoom(this.value / 100)">
                    <button class="zoom-btn btn-secondary" onclick="resetZoom()" title="Zoom 100%">‚äô</button>
                    <button class="zoom-btn btn-secondary" onclick="fitAllTables()" title="Voir toutes les tables">‚õ∂</button>
                </div>

                <div class="shortcut-bar">
                    <span>S</span> S√©l. <span>P</span> D√©pl. <span>M</span> Multi-S√©l. <span>Ctrl+Z</span> Annuler <span>Suppr/Retour</span> Suppr. <span>R</span> Rotation <span>Ctrl+A</span> Tout S√©l.
                </div>

            </div>
        </div>
    </div>
    
    <button id="playerPlanReturnButton" class="btn-secondary" onclick="returnToPlayerHome()">
        ‚¨ÖÔ∏è Retour √† l'accueil
    </button>
    <div id="loadingOverlay">
        <span>G√©n√©ration du PDF en cours...</span>
    </div>
    <div id="scoreModal">
        <div id="scoreModalContent">
            <h4>Saisir le r√©sultat</h4>
            <p>Pour l'√©chiquier : <strong id="scoreModalBoardNum"></strong></p>
            <select id="scoreModalSelect">
                <option value="">-- Choisir R√©sultat --</option>
                <option value="1-0">1-0</option>
                <option value="0-1">0-1</option>
                <option value="1/2-1/2">¬Ω-¬Ω</option>
                <option value="1-F">1-F (Blanc gagne F)</option>
                <option value="F-1">F-1 (Noir gagne F)</option>
                <option value="1/2-0">¬Ω-0</option>
                <option value="0-1/2">0-¬Ω</option>
                <option value="0-0">0-0 (Double perte)</option>
                <option value="F-F">F-F (Double forfait)</option>
            </select>
            <div class="score-modal-buttons">
                <button class="btn-success" onclick="saveScoreFromModal()">OK</button>
                <button class="btn-secondary" onclick="hideScoreModal()">Annuler</button>
            </div>
        </div>
    </div>
    <div id="qrScannerModal" class="modal-overlay" style="display:none;">
        <div id="qrScannerContent" class="modal-content">
            <h2>Scanner le QR Code</h2>
            <div id="video-container" style="background: #000; border-radius: 8px; overflow: hidden; margin: 20px 0;">
                <video id="qrVideo" autoplay playsinline style="width: 100%; display: block;"></video>
            </div>
            <div class="info-box">
                Positionnez le QR code dans le cadre de la cam√©ra
            </div>
            <button class="btn-danger" onclick="stopQRScanner()" style="width: 100%;">
                Arr√™ter et Fermer
            </button>
        </div>
    </div>
    <div id="qrValidationModal" class="modal-overlay" style="display:none;">
        <div id="qrValidationContent" class="modal-content" style="width: 90%; max-width: 450px;">
            <h3>Valider le r√©sultat ?</h3>
            <div id="validation-info" style="background: #f8f9fa; border-radius: 8px; padding: 20px; text-align: left; margin: 20px 0; line-height: 1.6;">
                <p style="font-size:1.1em; margin-bottom: 10px;">
                    <strong>√âchiquier :</strong> <span id="qrValidateBoard"></span>
                </p>
                <p style="font-size:1.1em; margin-bottom: 5px;">
                    <strong>Blancs :</strong> <span id="qrValidateWhite"></span>
                </p>
                <p style="font-size:1.1em; margin-bottom: 15px; border-bottom: 1px solid #ddd; padding-bottom: 15px;">
                    <strong>Noirs :</strong> <span id="qrValidateBlack"></span>
                </p>
                <p style="font-size:1.4em; color:#667eea; text-align: center;">
                    <strong>R√©sultat :</strong> <span id="qrValidateResult"></span>
                </p>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                <button class="btn-success" onclick="validateQRResult()">
                    ‚úÖ Valider
                </button>
                <button class="btn-secondary" onclick="cancelQRValidation()">
                    ‚ùå Annuler
                </button>
            </div>
        </div>
    </div>
    <div id="notification" class="notification"></div>
    <div id="arbiterPassModal" class="modal-overlay">
        <div class="modal-content" style="width: 350px;">
            <h2>Mot de passe Arbitre</h2>
            <p style="font-size: 0.9em; color: #666; margin-bottom: 15px;">
                D√©finissez un mot de passe pour le "Mode Saisie Joueur".
                Laissez vide pour d√©sactiver ce mode.
            </p>
            <div class="control-group">
                <label for="arbiterPassInput">Nouveau mot de passe :</label>
                <input type="password" id="arbiterPassInput" placeholder="Minimum 4 caract√®res">
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn-success" onclick="setArbiterPassword()">Enregistrer</button>
                <button class="btn-secondary" onclick="document.getElementById('arbiterPassModal').style.display = 'none'">Annuler</button>
            </div>
        </div>
    </div>
    <div id="playerLoginModal" class="modal-overlay">
        <div class="modal-content" style="width: 350px;">
            <h2>Acc√®s Saisie R√©sultat</h2>
            <p style="margin-bottom: 15px;">Veuillez entrer le mot de passe arbitre pour continuer.</p>
            <div class="control-group">
                <label for="playerPassInput">Mot de passe :</label>
                <input type="password" id="playerPassInput">
            </div>
            <div id="playerLoginError" style="color: #c00; font-weight: 600; margin-top: 10px; display: none;">
                Mot de passe incorrect.
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn-primary" onclick="loginAsPlayer()">Valider</button>
                <button class="btn-secondary" onclick="document.getElementById('playerLoginModal').style.display = 'none'">Annuler</button>
            </div>
        </div>
    </div>
    <div id="playerHomeModal" class="modal-overlay" style="z-index: 10001; flex-direction: column; background: rgba(240, 240, 240, 0.98);">
        <div class="modal-content" style="width: 90%; max-width: 600px; box-shadow: 0 10px 40px rgba(0,0,0,0.3);">
            <h2 style="font-size: 1.8em;">Saisie des R√©sultats (Ronde: <span id="playerModeRound"></span>)</h2>
            <p style="text-align: center; font-size: 1.1em; margin-bottom: 25px;">
                Comment voulez-vous saisir votre r√©sultat ?
            </p>
            <div style="display: grid; grid-template-columns: 1fr; gap: 15px;">
                <button class="btn-success" style="font-size: 1.2em; padding: 15px;" onclick="startQRScanner()">
                    üì∑ Scanner QR Code
                </button>
                <button class="btn-primary" style="font-size: 1.2em; padding: 15px;" onclick="showPlayerPlanView()">
                    üó∫Ô∏è Saisir depuis le plan
                </button>
                <button class="btn-info" style="font-size: 1.2em; padding: 15px;" onclick="showPlayerListSearch()">
                    üßë‚Äçü§ù‚Äçüßë Choisir mon nom (liste)
                </button>
                <button class="btn-info" style="font-size: 1.2em; padding: 15px;" onclick="showPlayerTextSearch()">
                    üîç Chercher par nom
                </button>
            </div>
            <button class="btn-danger" style="margin-top: 30px; width: auto; padding: 10px 20px; display: block; margin-left: auto; margin-right: auto;" onclick="promptToLogoutPlayer()">
                Quitter le Mode Saisie
            </button>
        </div>
    </div>
    <div id="playerTextSearchModal" class="modal-overlay" style="z-index: 10002;">
        <div class="modal-content" style="width: 90%; max-width: 500px;">
            <h3>Chercher ma partie</h3>
            <div class="control-group">
                <label for="playerSearchInput">Entrez votre nom :</label>
                <input type="text" id="playerSearchInput" placeholder="Ex: Durand..." list="player-search-suggestions" oninput="populatePlayerSearchSuggestions()">
                <datalist id="player-search-suggestions"></datalist>
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn-primary" onclick="findPlayerFromTextSearch()">Rechercher</button>
                <button class="btn-secondary" onclick="closePlayerTextSearch()">Annuler</button>
            </div>
        </div>
    </div>
    <div id="playerListSearchModal" class="modal-overlay" style="z-index: 10002;">
        <div class="modal-content" style="width: 90%; max-width: 500px;">
            <h3>Choisir ma partie</h3>
            <div class="control-group">
                <label for="playerListSelect">S√©lectionnez votre nom dans la liste :</label>
                <select id="playerListSelect" style="font-size: 1.1em; padding: 8px 10px;">
                    <option value="">-- Chargement... --</option>
                </select>
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn-primary" onclick="findPlayerFromListSearch()">Valider</button>
                <button class="btn-secondary" onclick="closePlayerListSearch()">Annuler</button>
            </div>
        </div>
    </div>
    <div id="simplifiedScoreModal" class="modal-overlay" style="z-index: 10002;">
        <div class="modal-content" style="width: 90%; max-width: 500px;">
            <h3>Saisir R√©sultat (√âchiquier <span id="simplifiedBoardNum"></span>)</h3>
            
            <div id="simplifiedPlayerInfo" style="background: #f8f9fa; border-radius: 8px; padding: 15px; text-align: center; margin-bottom: 20px; font-size: 1.1em;">
                <p><strong>Blancs:</strong> <span id="simplifiedWhitePlayer"></span></p>
                <p><strong>Noirs:</strong> <span id="simplifiedBlackPlayer"></span></p>
            </div>

            <div style="display: grid; grid-template-columns: 1fr; gap: 15px;">
                <button id="btnWinWhite" class="btn-primary" style="font-size: 1.1em; padding: 15px; line-height: 1.4;"></button>
                <button id="btnDraw" class="btn-secondary" style="font-size: 1.1em; padding: 15px; line-height: 1.4;"></button>
                <button id="btnWinBlack" class="btn-primary" style="font-size: 1.1em; padding: 15px; line-height: 1.4;"></button>
            </div>
            
            <button class="btn-danger" style="margin-top: 25px;" onclick="closeSimplifiedScoreModal()">
                Annuler
            </button>
        </div>
    </div>
    <div id="playerLogoutConfirmModal" class="modal-overlay" style="z-index: 10002;">
        <div class="modal-content" style="width: 350px;">
            <h2>Quitter le Mode Saisie</h2>
            <p style="margin-bottom: 15px;">Veuillez entrer le mot de passe arbitre pour quitter.</p>
            <div class="control-group">
                <label for="playerLogoutPassInput">Mot de passe :</label>
                <input type="password" id="playerLogoutPassInput">
            </div>
            <div id="playerLogoutError" style="color: #c00; font-weight: 600; margin-top: 10px; display: none;">
                Mot de passe incorrect.
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn-danger" onclick="attemptPlayerLogout()">Confirmer</button>
                <button class="btn-secondary" onclick="closePlayerLogoutConfirm()">Annuler</button>
            </div>
        </div>
    </div>
    <div id="playerLogoutConfirmModal" class="modal-overlay" style="z-index: 10002;">
        </div>

    <div id="bigTimerOverlay">
        <span id="bigTimerDisplay">00:00</span>
    </div>


    <script>
        // --- NOUVEAU: Gestion Accord√©on ---
        function toggleAccordion(headerElement) {
            const content = headerElement.nextElementSibling;
            const isExpanded = content.classList.contains('expanded');
            
            // Fermer tous les autres
            document.querySelectorAll('.sidebar-content.expanded').forEach(el => {
                if (el !== content) {
                    el.classList.remove('expanded');
                    el.previousElementSibling.classList.remove('active');
                }
            });
            
            // Ouvrir/Fermer celui-ci
            if (isExpanded) {
                content.classList.remove('expanded');
                headerElement.classList.remove('active');
            } else {
                content.classList.add('expanded');
                headerElement.classList.add('active');
            }
        }
        // --- Fin Gestion Accord√©on ---

        // --- Gestion Multi-Rondes ---
        let roundsStore = {};
        let currentRoundKey = 'ronde1';

        // --- Templates de salle (Supprim√©) ---
        // const roomTemplates = { ... }; // SUPPRIM√â
        
        function getCurrentState() {
            if (!roundsStore[currentRoundKey]) {
                roundsStore[currentRoundKey] = {
                    physicalTables: [],
                    rooms: [],
                    nextPhysicalTableId: 1,
                    nextRoomId: 1,
                    nextBoardNumber: 1,
                    historyStack: [],
                    redoStack: []
                };
            }
            // Assurer la compatibilit√© avec les anciens sauvegardes
            if (!roundsStore[currentRoundKey].rooms) {
                roundsStore[currentRoundKey].rooms = [];
            }
            if (!roundsStore[currentRoundKey].nextRoomId) {
                roundsStore[currentRoundKey].nextRoomId = 1;
            }
            return roundsStore[currentRoundKey];
        }

        // Variables globales pour l'√©tat ACTIF
        let physicalTables = [];
        let rooms = [];
        let nextPhysicalTableId = 1;
        let nextRoomId = 1;
        let nextBoardNumber = 1;
        let historyStack = [];
        let redoStack = [];

        // --- Gestion du Timer ---
        let timerInterval = null;
        let timerTargetTime = 0;
        let timerMode = 'stop'; 

        let selectedTables = [];
        let currentTool = 'select';
        let isDragging = false;
        let isResizing = false;
        let dragContext = {}; 
        let canvasDrag = { active: false, startX: 0, startY: 0, scrollLeft: 0, scrollTop: 0 };
        let selectionBox = { active: false, startX: 0, startY: 0, element: null };
        let currentZoom = 1;
        let defaultTableWidth = 200;
        let lastTablePosition = { x: 100, y: 100 };
        
        let isUndoRedoing = false; 
        let movingBoard = null;
        
        const CANVAS_WIDTH = 3000;
        const CANVAS_HEIGHT = 2000;
        const START_MARGIN = 100;
        
        // --- Sauvegarde Auto LocalStorage ---
        const SAVE_KEY = 'chessRoomManagerSave';
        const SAVE_KEY_TIMESTAMP = 'chessRoomManagerSaveTimestamp'; 
        const SERVER_URL = 'save.php';
        const USE_SERVER_SYNC = true;
        
        // === NOUVEAU SYST√àME DE SAUVEGARDE ===
        // MODIFI√â: tournamentName supprim√©, les cases √† cocher sont g√©r√©es par chessroom-save-system.js
        // let tournamentName = ''; // SUPPRIM√â
        let currentSaveMode = 'arbiter'; // 'arbiter' ou 'spectator'
        // let autoSaveLocalEnabled = true; // G√©r√© par le syst√®me de sauvegarde
        // let autoSaveServerEnabled = false; // G√©r√© par le syst√®me de sauvegarde
        // let autoSyncEnabled = true; // G√©r√© par le syst√®me de sauvegarde
        let localSaveInterval = null;
        let serverSyncInterval = null;
        let lastServerTimestamp = 0;
        let lastLocalSaveTime = 0; // <-- NOUVELLE LIGNE

        // ========================================
// SYNCHRONISATION SERVEUR
// ========================================
// Les fonctions de sauvegarde sont maintenant dans chessroom-save-system.js
// - saveToLocalStorage()
// - saveToServer()
// - loadFromServer()
// - syncFromServerIfNeeded()
// - Gestion de l'historique
// - Interface utilisateur de contr√¥le

       function autoSaveToLocalStorage() {
    try {
        saveCurrentStateToStore();
        
        const dataToSave = {
            roundsStore: JSON.parse(JSON.stringify(roundsStore)),
            currentRoundKey: currentRoundKey,
            arbiterPassword: arbiterPassword
            // SUPPRIM√â: tournamentName
        };
        
        Object.values(dataToSave.roundsStore).forEach(roundState => {
            if (roundState.physicalTables) {
                roundState.physicalTables.forEach(t => {
                    delete t.mouseDownHandler;
                });
            }
        });
        
        const json = JSON.stringify(dataToSave);
        localStorage.setItem(SAVE_KEY, json);
        localStorage.setItem(SAVE_KEY_TIMESTAMP, Date.now().toString());
        
        // MODIFI√â: La logique de sauvegarde serveur est g√©r√©e par onResultSaved()
        // et les timers dans chessroom-save-system.js
        
    } catch (error) {
        console.error("Erreur lors de la sauvegarde auto:", error);
        if (error.name === 'QuotaExceededError') {
            alert("Erreur: Impossible de sauvegarder. La m√©moire cache du navigateur est pleine.");
        }
    }
}
        
        function loadFromLocalStorage() {
            const savedData = localStorage.getItem(SAVE_KEY);
            const savedTimestamp = localStorage.getItem(SAVE_KEY_TIMESTAMP); 
            
            if (!savedData || !savedTimestamp) { 
                return false; // Pas de sauvegarde
            }

            try {
                const data = JSON.parse(savedData);
                
                // NOUVEAU: Formatage de la date
                const timestampStr = new Date(parseInt(savedTimestamp)).toLocaleString('fr-FR', {
                    day: 'numeric', month: 'long', hour: '2-digit', minute: '2-digit'
                });
                
                // MODIFI√â: Afficher le confirm() avec la date
                if (data && data.roundsStore && typeof data.roundsStore === 'object' && !Array.isArray(data.roundsStore) && Object.keys(data.roundsStore).length > 0 && confirm(`Une sauvegarde automatique du ${timestampStr} a √©t√© trouv√©e. Voulez-vous la charger ?`)) {                    
                    roundsStore = data.roundsStore;
                    currentRoundKey = data.currentRoundKey || 'ronde1';
                    arbiterPassword = data.arbiterPassword || null; // NOUVEAU: Charger le mot de passe

                    // Migration (identique √† loadLayout)
                    Object.values(roundsStore).forEach(roundState => {
                        if (!roundState.physicalTables) roundState.physicalTables = [];
                        if (!roundState.rooms) roundState.rooms = [];
                        if (!roundState.nextRoomId) roundState.nextRoomId = 1;
                        roundState.physicalTables.forEach(pt => {
                            if (!pt.arbiterComment) pt.arbiterComment = { text: "", flag: "none" };
                            pt.boards.forEach(b => {
                                if (b.score === undefined) b.score = { white: "", black: "" };
                                // Correction migration
                                if (b.players && b.players.white && typeof b.players.white === 'string') {
                                    b.players = {
                                        white: { name: b.players.white, elo: (b.players.white_elo || ""), comment: "" },
                                        black: { name: b.players.black, elo: (b.players.black_elo || ""), comment: "" }
                                    };
                                } else if (b.players) {
                                    if (b.players.white && !b.players.white.elo) b.players.white.elo = "";
                                    if (b.players.white && !b.players.white.comment) b.players.white.comment = "";
                                    if (b.players.black && !b.players.black.elo) b.players.black.elo = "";
                                    if (b.players.black && !b.players.black.comment) b.players.black.comment = "";
                                }
                            });
                        });
                        if (!roundState.historyStack) roundState.historyStack = [];
                        if (!roundState.redoStack) roundState.redoStack = [];
                    });
                    
                    updateRoundSelector();
                    loadStateFromStore(currentRoundKey);
                    
                    showNotification('Sauvegarde automatique charg√©e !', 'success');
                    return true; // Chargement r√©ussi
                }
                return false; // L'utilisateur a refus√©
            } catch (error) {
                console.error("Erreur chargement localStorage:", error);
                localStorage.removeItem(SAVE_KEY); // Supprimer la sauvegarde corrompue
                localStorage.removeItem(SAVE_KEY_TIMESTAMP); 
                return false;
            }
        }


        // --- Gestion Multi-Rondes ---
        function saveCurrentStateToStore() {
            let state = getCurrentState(); 
            state.physicalTables = JSON.parse(JSON.stringify(physicalTables));
            state.rooms = JSON.parse(JSON.stringify(rooms));
            state.nextPhysicalTableId = nextPhysicalTableId;
            state.nextRoomId = nextRoomId;
            state.nextBoardNumber = nextBoardNumber;
            state.historyStack = JSON.parse(JSON.stringify(historyStack));
            state.redoStack = JSON.parse(JSON.stringify(redoStack));
        }

        function loadStateFromStore(key) {
            currentRoundKey = key;
            const state = getCurrentState(); 
            
            physicalTables = JSON.parse(JSON.stringify(state.physicalTables));
            rooms = JSON.parse(JSON.stringify(state.rooms));
            nextPhysicalTableId = state.nextPhysicalTableId;
            nextRoomId = state.nextRoomId;
            nextBoardNumber = state.nextBoardNumber;
            historyStack = JSON.parse(JSON.stringify(state.historyStack));
            redoStack = JSON.parse(JSON.stringify(state.redoStack));

            renderAllTables();
            renderAllRooms();
            updateStats();
            updateHistoryButtons();
            
            if (document.getElementById('roundSelector')) {
                document.getElementById('roundSelector').value = key;
            }
            const roundName = key.replace('r', 'R');
            if (document.getElementById('playerModeRound')) {
                document.getElementById('playerModeRound').textContent = roundName;
            }
        }
        
        function updateRoundSelector() {
            const selector = document.getElementById('roundSelector');
            if (!selector) return;
            selector.innerHTML = '';
            // S'assurer qu'il y a au moins une ronde
            if (Object.keys(roundsStore).length === 0) {
                 roundsStore['ronde1'] = {
                    physicalTables: [], rooms: [], nextPhysicalTableId: 1, nextRoomId: 1,
                    nextBoardNumber: 1, historyStack: [], redoStack: []
                };
                currentRoundKey = 'ronde1';
            }
            Object.keys(roundsStore).forEach((key, index) => {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = key.replace('r', 'R');
                selector.appendChild(option);
            });
            selector.value = currentRoundKey;
        }

        function switchRound(key) {
            if (key === currentRoundKey) return;
            saveCurrentStateToStore();
            loadStateFromStore(key);
            autoSaveToLocalStorage();
        }

        function addNewRound() {
            saveCurrentStateToStore();
            const newKey = `ronde${Object.keys(roundsStore).length + 1}`;
            currentRoundKey = newKey;
            
            roundsStore[newKey] = {
                physicalTables: [],
                rooms: [],
                nextPhysicalTableId: 1,
                nextRoomId: 1,
                nextBoardNumber: 1,
                historyStack: [],
                redoStack: []
            };
            
            loadStateFromStore(newKey); 
            updateRoundSelector();
            saveHistoryState();
            autoSaveToLocalStorage();
        }

        function cloneRoundLayout() {
            saveCurrentStateToStore();
            
            const newLayout = JSON.parse(JSON.stringify(physicalTables));
            newLayout.forEach(pt => {
                pt.boards.forEach(b => {
                    b.players = null;
                    b.score = { white: "", black: "" };
                    b.flipped = false;
                });
            });
            
            const newRooms = JSON.parse(JSON.stringify(rooms));

            const newKey = `ronde${Object.keys(roundsStore).length + 1}`;
            currentRoundKey = newKey;

            roundsStore[newKey] = {
                physicalTables: newLayout, 
                rooms: newRooms,
                nextPhysicalTableId: nextPhysicalTableId, 
                nextRoomId: nextRoomId,
                nextBoardNumber: nextBoardNumber, 
                historyStack: [], 
                redoStack: []
            };
            
            loadStateFromStore(newKey);
            updateRoundSelector();
            saveHistoryState(); 
            autoSaveToLocalStorage();
        }


        // --- Fonctions du Timer ---
        function startRoundTimer() {
            clearInterval(timerInterval);
            const minutes = parseInt(document.getElementById('timerMinutes').value) || 0;
            
            if (minutes > 0) {
                // CAS 1: D√âCOMPTE (Ex: 15)
                // AFFICHE le grand minuteur
                document.getElementById('bigTimerOverlay').style.display = 'flex'; 
                timerTargetTime = Date.now() + (minutes * 60 * 1000);
                timerMode = 'down';
            } else {
                // CAS 2: COMPTEUR (Ex: 0 ou -5)
                // N'affiche PAS le grand minuteur
                document.getElementById('bigTimerOverlay').style.display = 'none'; 
                timerTargetTime = Date.now() + (minutes * 60 * 1000); 
                timerMode = 'up';
            }
            
            updateTimer(); // Met √† jour l'affichage imm√©diatement
            timerInterval = setInterval(updateTimer, 500);
        }

        // CORRECTION: CETTE FONCTION √âTAIT MANQUANTE
        function stopRoundTimer() {
            clearInterval(timerInterval);
            timerInterval = null;
            timerMode = 'stop';
            const timerDisplay = document.getElementById('roundTimer');
            timerDisplay.textContent = '00:00';
            timerDisplay.className = '';
            
            // CACHE et r√©initialise le grand minuteur (comme demand√©)
            document.getElementById('bigTimerOverlay').style.display = 'none'; 
            document.getElementById('bigTimerDisplay').textContent = '00:00'; 
        }

        function updateTimer() {
            const timerDisplay = document.getElementById('roundTimer');
            const bigTimerDisplay = document.getElementById('bigTimerDisplay'); 
            const now = Date.now();
            
            if (timerMode === 'down') {
                // Logique du D√âCOMPTE (valeur positive)
                let remainingMs = timerTargetTime - now;
                
                if (remainingMs <= 0) {
                    clearInterval(timerInterval); 
                    timerInterval = null;
                    timerMode = 'stop'; 
                    timerDisplay.textContent = '00:00'; 
                    timerDisplay.className = 'timer-elapsed timer-flash'; // Flash vert
                    
                    document.getElementById('bigTimerOverlay').style.display = 'none'; 
                    bigTimerDisplay.textContent = '00:00';
                    
                } else {
                    const seconds = Math.floor((remainingMs / 1000) % 60);
                    const minutes = Math.floor((remainingMs / 1000 / 60) % 60);
                    const newTime = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                    timerDisplay.textContent = newTime;
                    bigTimerDisplay.textContent = newTime; 
                    timerDisplay.className = 'timer-countdown'; // Style bleu
                }
                
            } else if (timerMode === 'up') {
                // Logique du COMPTEUR (valeur 0 ou n√©gative)
                let elapsedMs = now - timerTargetTime; 

                // CORRECTION: Les calculs √©taient manquants
                const totalSeconds = Math.floor(elapsedMs / 1000);
                const seconds = totalSeconds % 60;
                const totalMinutes = Math.floor(totalSeconds / 60);
                const minutes = totalMinutes % 60;
                const hours = Math.floor(totalMinutes / 60);
                
                let newTime = '';
                if (hours > 0) {
                    newTime = `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                } else {
                    newTime = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }
                timerDisplay.textContent = newTime;
                timerDisplay.className = 'timer-elapsed'; // Style rouge
            }
        }


        // --- Template (Supprim√©) ---
        function applyTemplate(templateName) {
            // SUPPRIM√â
            alert("Cette fonctionnalit√© a √©t√© retir√©e.");
        }

        // --- Fonctions d'historique (Modifi√©es pour le store) ---
        function saveHistoryState() {
            if (isUndoRedoing) return; 
            const state = {
                physicalTables: JSON.parse(JSON.stringify(physicalTables)), 
                rooms: JSON.parse(JSON.stringify(rooms)),
                nextPhysicalTableId: nextPhysicalTableId,
                nextRoomId: nextRoomId,
                nextBoardNumber: nextBoardNumber
            };
            historyStack.push(state);
            redoStack = []; 
            if (historyStack.length > 50) { 
                historyStack.shift();
            }
            updateHistoryButtons();
            autoSaveToLocalStorage();

            // NOUVEAU: D√©clencher la sauvegarde serveur (si activ√©e)
            if (window.ChessRoomSave) window.ChessRoomSave.onResultSaved(); 
        }
        function restoreState(state) {
            isUndoRedoing = true; 
            physicalTables = JSON.parse(JSON.stringify(state.physicalTables)); 
            rooms = state.rooms ? JSON.parse(JSON.stringify(state.rooms)) : [];
            nextPhysicalTableId = state.nextPhysicalTableId;
            nextRoomId = state.nextRoomId || 1;
            nextBoardNumber = state.nextBoardNumber;
            
            renderAllTables(); 
            renderAllRooms();
            updateStats();
            clearSelection();
            isUndoRedoing = false; 
        }
        function undo() {
            if (historyStack.length < 2) return;
            const currentState = historyStack.pop(); 
            redoStack.push(currentState); 
            const prevState = historyStack[historyStack.length - 1]; 
            restoreState(prevState); 
            updateHistoryButtons(); 
            autoSaveToLocalStorage();
        }
        function redo() {
            if (redoStack.length === 0) return;
            const nextState = redoStack.pop(); 
            historyStack.push(nextState); 
            restoreState(nextState); 
            updateHistoryButtons();
            autoSaveToLocalStorage();
        }
        function updateHistoryButtons() {
            document.getElementById('undoButton').disabled = historyStack.length < 2;
            document.getElementById('redoButton').disabled = redoStack.length === 0;
        }
        
        // --- Toggle Sidebar ---
        function toggleSidebar() {
            const mainContent = document.querySelector('.main-content');
            const btn = document.getElementById('sidebarToggle');
            mainContent.classList.toggle('sidebar-collapsed');
            if (mainContent.classList.contains('sidebar-collapsed')) {
                btn.innerHTML = '¬ª';
            } else {
                btn.innerHTML = '¬´';
            }
        }
        
        // --- Fonctions Utilitaires ---
        function findBoard(boardNum) {
            const searchKey = boardNum.toString();
            for (const physicalTable of physicalTables) {
                const board = physicalTable.boards.find(b => b.boardNumber.toString() === searchKey);
                if (board) {
                    return { board, physicalTable };
                }
            }
            return { board: null, physicalTable: null };
        }
        
        // --- Format des Noms (NOM Pr√©nom) ---
        function formatPlayerName(fullName) {
            if (!fullName) return '';
            const parts = fullName.trim().split(/\s+/);
            const lastName = parts.pop() || '';
            const firstName = parts.join(' ');
            return `<strong class="lastname">${lastName.toUpperCase()}</strong> ${firstName}`;
        }
        
        // NOUVEAU: Obtenir le nom simple
        function getSimplePlayerName(fullName) {
            if (!fullName) return 'N/A';
            const parts = fullName.trim().split(/\s+/);
            const lastName = parts.pop() || '';
            const firstName = parts.join(' ');
            return `${firstName} ${lastName.toUpperCase()}`;
        }

        
        function getLayoutConfig() {
            const corner = document.getElementById('startCorner').value;
            const physicalTablesPerRow = parseInt(document.getElementById('physicalTablesPerRow').value) || 10;
            const tableLengthCm = parseInt(document.getElementById('tableLength').value) || 180;
            const boardsPerTable = parseInt(document.getElementById('boardsPerTable').value) || 1;
            
            const minWidthPerBoard = 150;
            const estimatedTableWidth = Math.max(tableLengthCm * 1.2, minWidthPerBoard * boardsPerTable);
            const estimatedRowWidth = (estimatedTableWidth + 30) * physicalTablesPerRow - 30;
            const estimatedTableHeight = 160;

            switch(corner) {
                case 'tr':
                    return { 
                        startX: CANVAS_WIDTH - START_MARGIN, 
                        startY: START_MARGIN, 
                        xDir: -1, 
                        yDir: 1 
                    };
                case 'bl':
                    return { 
                        startX: START_MARGIN, 
                        startY: CANVAS_HEIGHT - START_MARGIN - estimatedTableHeight, 
                        xDir: 1, 
                        yDir: -1 
                    };
                case 'br':
                    return { 
                        startX: CANVAS_WIDTH - START_MARGIN, 
                        startY: CANVAS_HEIGHT - START_MARGIN - estimatedTableHeight, 
                        xDir: -1, 
                        yDir: -1 
                    };
                case 'tl':
                default:
                    return { 
                        startX: START_MARGIN, 
                        startY: START_MARGIN, 
                        xDir: 1, 
                        yDir: 1 
                    };
            }
        }


        // --- Gestion des Outils ---
        function setTool(tool) {
            // NOUVEAU: Ne pas changer d'outil en mode joueur
            if (isPlayerMode && !document.body.classList.contains('player-plan-view-mode')) return;
            
            currentTool = tool;
            const canvas = document.getElementById('canvas');
            
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(tool + 'Tool').classList.add('active');
            
            canvas.classList.remove('move-mode', 'moveboard-mode');
            
            if (tool === 'pan') {
                canvas.classList.add('move-mode');
                canvas.style.cursor = 'grab';
            } else if (tool === 'multiselect') {
                canvas.style.cursor = 'crosshair';
            } else if (tool === 'moveboard') {
                canvas.classList.add('moveboard-mode');
                canvas.style.cursor = 'default';
            } else {
                canvas.style.cursor = 'default';
            }
        }

        // --- Cr√©ation/Disposition des Tables ---
        function addBoards() {
            saveHistoryState(); 
            try {
                const boardCount = parseInt(document.getElementById('boardCount').value);
                const boardsPerTable = parseInt(document.getElementById('boardsPerTable').value) || 1;
                const physicalTablesPerRow = parseInt(document.getElementById('physicalTablesPerRow').value) || 10;
                const tableLengthCm = parseInt(document.getElementById('tableLength').value) || 180;
                
                const minWidthPerBoard = 150; 
                
                if (!boardCount || boardCount < 1 || boardCount > 2000) {
                    alert('Veuillez saisir un nombre d\'√©chiquiers entre 1 et 2000');
                    historyStack.pop(); 
                    updateHistoryButtons();
                    return;
                }

                const physicalTableCount = Math.ceil(boardCount / boardsPerTable);
                const spacingY = 160; 
                const newTables = []; 
                
                let currentX, currentY, currentCol, xDir, yDir;
                
                if (physicalTables.length === 0) {
                    let layout = getLayoutConfig();
                    currentX = layout.startX;
                    currentY = layout.startY;
                    xDir = layout.xDir;
                    yDir = layout.yDir;
                    currentCol = 0;
                } else {
                    xDir = 1; yDir = 1;
                    const totalExistingTables = physicalTables.length;
                    const lastCompleteRow = Math.floor((totalExistingTables - 1) / physicalTablesPerRow);
                    const lastCol = (totalExistingTables - 1) % physicalTablesPerRow;
                    
                    if (lastCol === physicalTablesPerRow - 1) {
                        currentX = START_MARGIN;
                        currentY = START_MARGIN + ((lastCompleteRow + 1) * spacingY);
                        currentCol = 0;
                    } else {
                        const lastTableInRow = physicalTables.find(t => t.y === (START_MARGIN + (lastCompleteRow * spacingY)) && (physicalTables.indexOf(t) % physicalTablesPerRow === lastCol));
                        const lastTableWidth = lastTableInRow ? (lastTableInRow.width || defaultTableWidth) : defaultTableWidth;
                        
                        currentX = (lastTableInRow ? lastTableInRow.x : START_MARGIN) + lastTableWidth + 30;
                        currentY = START_MARGIN + (lastCompleteRow * spacingY);
                        currentCol = lastCol + 1;
                    }
                }

                let currentBoardCount = physicalTables.reduce((acc, p) => acc + p.boards.length, 0);
                const totalBoardTarget = boardCount + currentBoardCount;

                for (let i = 0; i < physicalTableCount; i++) {
                    const col = (currentCol + i) % physicalTablesPerRow;
                    
                    if (col === 0 && i > 0) {
                        currentX = (physicalTables.length === 0) ? getLayoutConfig().startX : START_MARGIN;
                        currentY += spacingY * yDir;
                    }

                    const actualBoardsForThisTable = Math.min(boardsPerTable, totalBoardTarget - currentBoardCount);
                    if (actualBoardsForThisTable <= 0) break;
                    
                    const tableWidth = Math.max(tableLengthCm * 1.2, minWidthPerBoard * actualBoardsForThisTable);
                    
                    const tableX = (xDir === 1) ? currentX : currentX - tableWidth; 
                    const tableY = (yDir === 1) ? currentY : currentY;
                    
                    const physicalTable = {
                        id: nextPhysicalTableId++,
                        x: tableX,
                        y: tableY,
                        rotation: 0,
                        width: tableWidth,
                        arbiterComment: { text: "", flag: "none" },
                        boards: []
                    };
                    
                    for (let j = 0; j < actualBoardsForThisTable; j++) {
                         physicalTable.boards.push({
                            boardNumber: nextBoardNumber++,
                            players: null, 
                            flipped: false,
                            score: { white: "", black: "" } 
                         });
                         currentBoardCount++;
                    }
                    
                    if(physicalTable.boards.length > 0) {
                        physicalTables.push(physicalTable);
                        newTables.push(physicalTable);
                        createTableElement(physicalTable);
                        lastTablePosition = { x: tableX, y: tableY };
                        currentX += (tableWidth + 30) * xDir; 
                    }
                }
updateStats();
                
                if (newTables.length > 0) {
                    setTimeout(() => centerViewOnTables(newTables), 100);
                }
            } catch (error) {
                console.error('Error in addBoards:', error);
                alert('Une erreur est survenue: ' + error.message);
                historyStack.pop(); 
                updateHistoryButtons();
            }
        }

        function centerViewOnTables(tablesToCenter) {
            if (tablesToCenter.length === 0) return;
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            tablesToCenter.forEach(pTable => {
                minX = Math.min(minX, pTable.x);
                minY = Math.min(minY, pTable.y);
                maxX = Math.max(maxX, pTable.x + (pTable.width || 200));
                maxY = Math.max(maxY, pTable.y + 160); 
            });
            const margin = 100;
            minX -= margin; minY -= margin; maxX += margin; maxY += margin;
            const centerX = (minX + maxX) / 2; const centerY = (minY + maxY) / 2;
            const container = document.getElementById('canvasContainer');
            const containerWidth = container.clientWidth; const containerHeight = container.clientHeight;
            const contentWidth = maxX - minX; const contentHeight = maxY - minY;
            const zoomX = containerWidth / contentWidth; const zoomY = containerHeight / contentHeight;
            const suggestedZoom = Math.min(zoomX, zoomY, 1) * 0.9;
            if (suggestedZoom < currentZoom) {
                applyZoom(Math.max(0.1, suggestedZoom));
            }
            container.scrollLeft = (centerX * currentZoom) - containerWidth / 2;
            container.scrollTop = (centerY * currentZoom) - containerHeight / 2;
        }

        function createTableElement(physicalTable) {
            try {
                const canvas = document.getElementById('canvas');
                if (!canvas) return;
                
                const element = document.createElement('div');
                element.className = `table-element rotate-${physicalTable.rotation}`;
                element.id = `phys-table-${physicalTable.id}`;
                element.style.left = physicalTable.x + 'px';
                element.style.top = physicalTable.y + 'px';
                element.style.width = (physicalTable.width || defaultTableWidth) + 'px';
                element.style.setProperty('--rotation', `${physicalTable.rotation}deg`);
                element.dataset.tableId = physicalTable.id; 
                
                const contentInner = document.createElement('div');
                contentInner.className = 'table-content-inner';
                
                element.prepend(contentInner);
                
                const flagClass = physicalTable.arbiterComment ? `flag-${physicalTable.arbiterComment.flag}` : 'flag-none';
                
                element.innerHTML += `
                    <div class="arbiter-flag ${flagClass}" onclick="event.stopPropagation(); editArbiterComment(${physicalTable.id})" title="Commentaire arbitre">‚öê</div>
                    <div class="delete-btn" onclick="event.stopPropagation(); deleteTable(${physicalTable.id})">√ó</div>
                    <div class="rotate-btn" onclick="event.stopPropagation(); rotateTable(${physicalTable.id})">‚Üª</div>
                    <div class="resize-handle handle-left" onmousedown="event.stopPropagation(); startResize(event, ${physicalTable.id}, 'left')">‚¨å</div>
                    <div class="resize-handle handle-right" onmousedown="event.stopPropagation(); startResize(event, ${physicalTable.id}, 'right')">‚¨å</div>
                `;
                
                updateTableDisplay(physicalTable.id, element); 

                physicalTable.mouseDownHandler = (e) => handleTableMouseDown(e, physicalTable.id);
                element.addEventListener('mousedown', physicalTable.mouseDownHandler);
                element.addEventListener('click', (e) => {
                    // NOUVEAU: D√©sactiv√© en mode joueur
                    if (isPlayerMode) return;
                    if (e.target.classList.contains('player-name')) element.classList.toggle('expanded');
                });

                canvas.appendChild(element);
            } catch (error) { console.error('Error in createTableElement:', error); }
        }
        
        // --- Drag/Drop √âchiquier ---
        function startMoveBoard(e, boardNumber, tableId) {
            if (isDragging || movingBoard) return;
            isDragging = true; 
            
            const { board } = findBoard(boardNumber);
            if (!board) return;
            
            const sourceElement = e.currentTarget;
            
            const ghost = sourceElement.cloneNode(true);
            ghost.id = 'ghost';
            ghost.style.position = 'absolute';
            ghost.style.opacity = '0.7';
            ghost.style.zIndex = '2000';
            ghost.style.width = sourceElement.offsetWidth + 'px'; 
            document.body.appendChild(ghost);

            movingBoard = {
                boardNumber,
                originalTableId: tableId,
                element: ghost,
                offsetX: e.offsetX,
                offsetY: e.offsetY
            };
            
            moveGhost(e); 
            
            document.querySelectorAll('.table-element').forEach(tableEl => {
                tableEl.addEventListener('mouseenter', handleTableDropEnter);
                tableEl.addEventListener('mouseleave', handleTableDropLeave);
            });
        }
        
        function moveGhost(e) {
            if (!movingBoard) return;
            movingBoard.element.style.left = (e.clientX - movingBoard.offsetX) + 'px';
            movingBoard.element.style.top = (e.clientY - movingVhost.offsetY) + 'px';
        }

        function handleTableDropEnter(e) {
            if (!movingBoard) return;
            e.currentTarget.classList.add('selected'); 
        }
        
        function handleTableDropLeave(e) {
            if (!movingBoard) return;
            const tableId = parseInt(e.currentTarget.dataset.tableId);
            if (!selectedTables.includes(tableId)) {
                e.currentTarget.classList.remove('selected');
            }
        }
        
        
        // --- Modification des √âl√©ments ---
        
        // Commentaire Arbitre (Table)
        function editArbiterComment(tableId) {
            const table = physicalTables.find(t => t.id === tableId);
            if (!table) return;

            if (!table.arbiterComment) {
                table.arbiterComment = { text: "", flag: "none" };
            }

            const currentText = table.arbiterComment.text || '';
            const newText = prompt("Ajouter/modifier le commentaire arbitre pour cette table:", currentText);

            if (newText !== null) { 
                const currentFlag = table.arbiterComment.flag || 'none';
                const newFlag = prompt("Couleur du drapeau (none, red, yellow, green):", currentFlag);
                
                saveHistoryState(); 
                table.arbiterComment.text = newText.trim();
                table.arbiterComment.flag = newFlag ? newFlag.trim().toLowerCase() : 'none';
                
                const element = document.getElementById(`phys-table-${tableId}`);
                if (element) {
                    const flagEl = element.querySelector('.arbiter-flag');
                    if(flagEl) {
                        flagEl.className = `arbiter-flag flag-${table.arbiterComment.flag}`;
                    }
                }
            }
        }

        function editPlayerComment(boardNum, color) {
            // NOUVEAU: D√©sactiv√© en mode joueur
            if (isPlayerMode) return;
            
            const { board, physicalTable } = findBoard(boardNum);
            if (!board || !board.players) return;

            const player = board.players[color];
            const currentValue = player.comment || '';
            const newValue = prompt(`Ajouter/modifier le commentaire pour ${player.name}:`, currentValue);

            if (newValue !== null) { 
                saveHistoryState(); 
                player.comment = newValue.trim();
                updateTableDisplay(physicalTable.id);
            }
        }
        
        // --- Saisie de score par Modale ---
        function editScore(boardNum) {
            // NOUVEAU: Si on est en mode joueur, utiliser la modale simplifi√©e
            if (isPlayerMode) {
                const { board, physicalTable } = findBoard(boardNum);
                // NOUVEAU: V√©rifier si le score est d√©j√† saisi
                if (board && (board.score.white !== '' || board.score.black !== '')) {
                    showNotification("Ce r√©sultat a d√©j√† √©t√© saisi.", "info");
                    return;
                }
                if (board && board.players) {
                    showSimplifiedScoreModal(board, physicalTable);
                }
                return;
            }
            
            // Logique arbitre (modale compl√®te)
            const { board } = findBoard(boardNum);
            if (!board) return;
            showScoreModal(boardNum);
        }

        function showScoreModal(boardNum) {
            const { board } = findBoard(boardNum);
            if (!board) return;
            
            const modal = document.getElementById('scoreModal');
            const select = document.getElementById('scoreModalSelect');
            const boardNumEl = document.getElementById('scoreModalBoardNum');
            
            boardNumEl.textContent = boardNum;
            modal.dataset.boardNum = boardNum; 
            
            let currentValue = "";
            if (board.score.white && board.score.black) {
                // G√©rer le cas 1/2-1/2
                if(board.score.white === "1/2" && board.score.black === "1/2") {
                    currentValue = "1/2-1/2";
                } else {
                    currentValue = `${board.score.white}-${board.score.black}`;
                }
            }
            
            select.value = currentValue;
            if (select.value !== currentValue) {
                 select.value = ""; 
            }
            
            modal.style.display = 'flex';
            select.focus();
        }

        function hideScoreModal() {
            document.getElementById('scoreModal').style.display = 'none';
        }

        function saveScoreFromModal() {
            const modal = document.getElementById('scoreModal');
            const select = document.getElementById('scoreModalSelect');
            const boardNum = modal.dataset.boardNum;
            const value = select.value;

            const { board, physicalTable } = findBoard(boardNum);
            if (!board) {
                hideScoreModal();
                return;
            }

            saveHistoryState();
            
            if (value === "") {
                board.score.white = "";
                board.score.black = "";
            } else {
                const parts = value.split('-');
                board.score.white = parts[0] || "";
                board.score.black = parts[1] || "";
            }
            
            updateTableDisplay(physicalTable.id);
            updateStats();
            if (window.ChessRoomSave) window.ChessRoomSave.onResultSaved();
            hideScoreModal();
        }

        
        // --- Validation "Entr√©e" pour le num√©ro d'√©chiquier ---
        function editBoardNumber(oldNumber) {
            // NOUVEAU: D√©sactiv√© en mode joueur
            if (isPlayerMode) return;
            
            try {
                const { board, physicalTable } = findBoard(oldNumber);
                if (!board) return;

                const physicalTableEl = document.getElementById(`phys-table-${physicalTable.id}`);
                const boardEl = physicalTableEl.querySelector(`[data-board-number="${oldNumber.toString().replace(/"/g, '\\"')}"]`);
                const numberDisplay = boardEl.querySelector('.board-number-display');
                const originalText = numberDisplay.textContent.trim();
                
                const input = document.createElement('input');
                input.type = 'text';
                input.value = oldNumber;
                input.style.cssText = `
                    width: 100px; text-align: center; margin: 0 auto; display: block;
                    border: 2px solid #667eea; font-size: 1.2em; padding: 4px; font-weight: 700;
                `;
                
                numberDisplay.innerHTML = '';
                numberDisplay.appendChild(input);
                input.focus();
                input.select();
                
                // Fonction de sauvegarde (closure)
                function saveEdit() {
                    input.removeEventListener('blur', saveEdit);
                    input.removeEventListener('keydown', handleKeydown);

                    const newNumberStr = input.value.trim();
                    const originalNumber = oldNumber;
                    
                    if (newNumberStr === "") {
                        numberDisplay.innerHTML = originalText;
                        return;
                    }
                    
                    const newNumberValue = parseInt(newNumberStr);
                    let newNumber;
                    
                    if (isNaN(newNumberValue) || newNumberValue.toString() !== newNumberStr) {
                         newNumber = newNumberStr;
                    } else {
                        newNumber = newNumberValue;
                    }

                    if (newNumber.toString() === originalNumber.toString()) {
                        numberDisplay.innerHTML = newNumber;
                        return;
                    }
                    
                    saveHistoryState(); 
                    const { board: targetBoard } = findBoard(originalNumber);
                    
                    if (targetBoard) {
                        targetBoard.boardNumber = newNumber;
                        
                        numberDisplay.innerHTML = newNumber;
                        boardEl.dataset.boardNumber = newNumber;
                        
                        const boardNumForEvent = (typeof newNumber === 'string') ? `'${newNumber.replace(/'/g, "\\'")}'` : newNumber;
                        
                        numberDisplay.setAttribute('onDblClick', `event.stopPropagation(); editBoardNumber(${boardNumForEvent})`);
                        boardEl.querySelector('.flip-btn-single').setAttribute('onclick', `event.stopPropagation(); flipSingleBoard(${boardNumForEvent})`);

                        boardEl.querySelectorAll('.player-name').forEach(nameEl => {
                            const player = nameEl.closest('.player');
                            if (player) {
                                const color = player.dataset.color;
                                nameEl.setAttribute('onclick', `event.stopPropagation(); editPlayerComment(${boardNumForEvent}, '${color}')`);
                            }
                        });
                        boardEl.querySelectorAll('.player-score').forEach(scoreEl => {
                            scoreEl.setAttribute('onclick', `event.stopPropagation(); editScore(${boardNumForEvent})`);
                        });
                        
                    } else {
                        numberDisplay.innerHTML = originalText;
                    }
                }
                
                // Gestionnaire de clavier
                function handleKeydown(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault(); 
                        saveEdit();
                    } else if (e.key === 'Escape') {
                        input.removeEventListener('blur', saveEdit);
                        input.removeEventListener('keydown', handleKeydown);
                        numberDisplay.innerHTML = originalText;
                    }
                }
                
                input.addEventListener('blur', saveEdit);
                input.addEventListener('keydown', handleKeydown);

            } catch (error) { console.error('Error in editBoardNumber:', error); }
        }

        function handleTableMouseDown(e, tableId) {
            try {
                // MODIFI√â: Logique de clic en mode joueur simplifi√©e (g√©r√©e par le clic sur .board-container)
                if (isPlayerMode && document.body.classList.contains('player-plan-view-mode')) {
                    // Laisser le clic remonter jusqu'au .board-container si c'est la cible
                    if (e.target.closest('.board-container')) {
                        return;
                    }
                    // Emp√™cher d'autres actions
                    e.stopPropagation();
                    e.preventDefault();
                    return;
                }
            
                if (e.target.classList.contains('delete-btn') || 
                    e.target.classList.contains('rotate-btn') ||
                    e.target.classList.contains('resize-handle') || 
                    e.target.classList.contains('flip-btn-single') ||
                    e.target.classList.contains('arbiter-flag') || 
                    e.target.classList.contains('player-name') ||
                    e.target.classList.contains('player-score') ||
                    (e.target.closest('.board-container') && currentTool === 'moveboard') ||
                    e.target.tagName.toLowerCase() === 'input') { 
                    return;
                }
                
                // Ne pas s√©lectionner la table si on clique sur une salle (car la salle est derri√®re)
                if (e.target.classList.contains('room-element') || e.target.classList.contains('room-title')) {
                    return;
                }

                if (currentTool === 'select') {
                    isDragging = true;
                    if (!e.ctrlKey && !e.metaKey && !selectedTables.includes(tableId)) {
                        clearSelection(true); // MODIFI√â: Ne pas d√©s√©lectionner les salles
                        selectTable(tableId);
                    } else if (e.ctrlKey || e.metaKey) {
                        toggleTableSelection(tableId);
                    }
                    
                    dragContext = { 
                        isRoom: false,
                        tables: [], 
                        startX: e.clientX, 
                        startY: e.clientY 
                    };
                    
                    selectedTables.forEach(id => {
                        const table = physicalTables.find(t => t.id === id);
                        const element = document.getElementById(`phys-table-${id}`);
                        if (table && element) {
                            dragContext.tables.push({ table, element, initialX: table.x, initialY: table.y });
                            element.style.zIndex = '1000';
                        }
                    });
                    
                    e.preventDefault();
                    e.stopPropagation();
                }
            } catch (error) { console.error('Error in handleTableMouseDown:', error); }
        }

        function selectTable(tableId) {
            if (selectedTables.includes(tableId)) return;
            selectedTables.push(tableId);
            const element = document.getElementById(`phys-table-${tableId}`);
            if (element) element.classList.add('selected');
            updateSelectedCount();
        }

        function toggleTableSelection(tableId) {
            const index = selectedTables.indexOf(tableId);
            if (index > -1) {
                selectedTables.splice(index, 1);
                const element = document.getElementById(`phys-table-${tableId}`);
                if (element) element.classList.remove('selected');
            } else {
                selectTable(tableId);
            }
            updateSelectedCount();
        }

        function clearSelection(keepRooms = false) {
            selectedTables.forEach(id => {
                const element = document.getElementById(`phys-table-${id}`);
                if (element) element.classList.remove('selected');
            });
            selectedTables = [];
            updateSelectedCount();
            
            if (!keepRooms) {
                document.querySelectorAll('.room-element.selected').forEach(el => el.classList.remove('selected'));
            }
        }

        function updateSelectedCount() {
            document.getElementById('selectedCount').textContent = selectedTables.length;
        }

        function deleteTable(tableId, addToHistory = true) {
            if (addToHistory) saveHistoryState(); 
            try {
                const index = physicalTables.findIndex(t => t.id === tableId);
                if (index !== -1) {
                    physicalTables.splice(index, 1);
                    const element = document.getElementById(`phys-table-${tableId}`);
                    if (element) element.remove();
                    const selIndex = selectedTables.indexOf(tableId);
                    if (selIndex > -1) {
                        selectedTables.splice(selIndex, 1);
                        updateSelectedCount();
                    }
                    updateStats();
                }
            } catch (error) { console.error('Error in deleteTable:', error); }
        }

        function deleteSelected() {
            if (selectedTables.length === 0) return;
            saveHistoryState(); 
            try {
                [...selectedTables].forEach(id => deleteTable(id, false)); 
                clearSelection();
            } catch (error) { console.error('Error in deleteSelected:', error); }
        }
        function rotateSelected() {
            if (selectedTables.length === 0) return;
            saveHistoryState(); 
            try {
                selectedTables.forEach(id => rotateTable(id, false)); 
            } catch (error) { console.error('Error in rotateSelected:', error); }
        }

        function flipSingleBoard(boardNumber) {
            // NOUVEAU: D√©sactiv√© en mode joueur
            if (isPlayerMode) return;
            
            saveHistoryState();
            try {
                const { board, physicalTable } = findBoard(boardNumber);
                if (board && board.players) {
                    board.flipped = !board.flipped;
                    updateTableDisplay(physicalTable.id);
                }
            } catch (error) { console.error('Error in flipSingleBoard:', error); }
        }

        function flipPlayersSelected() {
            if (selectedTables.length === 0) return;
            saveHistoryState();
            try {
                selectedTables.forEach(id => {
                    const table = physicalTables.find(t => t.id === id);
                    if (table) {
                        table.boards.forEach(board => {
                            if (board.players) board.flipped = !board.flipped;
                        });
                        updateTableDisplay(id); 
                    }
                });
            } catch (error) { console.error('Error in flipPlayersSelected:', error); }
        }

        // --- FONCTION DE RENDU PRINCIPALE ---
        function updateTableDisplay(tableId, element) {
            try {
                const table = physicalTables.find(t => t.id === tableId);
                if (!table) return;
                
                if (!element) {
                    element = document.getElementById(`phys-table-${tableId}`);
                }
                if (!element) return;
                
                const contentInner = element.querySelector('.table-content-inner');
                if (!contentInner) return;
                
                contentInner.innerHTML = ''; 
                
                let allPaired = table.boards.length > 0;
                let hasVisibleBoards = false; 
                    
                table.boards.forEach((board) => {
                    const isInverted = (table.rotation === 180 && !board.flipped) || (table.rotation !== 180 && board.flipped);
                    
                    if (board.players === null) allPaired = false;
                    
                    const boardNumForEvent = (typeof board.boardNumber === 'string') ? `'${board.boardNumber.replace(/'/g, "\\'")}'` : board.boardNumber;
                    
                    let playersHTML = '';
                    let boardHasPlayers = false; 

                    if (board.players) {
                        boardHasPlayers = true; 
                        const pWhite = board.players.white;
                        const pBlack = board.players.black;
                        const sWhite = board.score.white || '...'; 
                        const sBlack = board.score.black || '...';
                        
                        const buildPlayerHTML = (player, color, score) => {
                            if (!player) return ''; 
                            const playerNameFormatted = formatPlayerName(player.name);
                            const playerElo = player.elo || '----';
                            const playerCommentHTML = player.comment ? `<div class="player-comment">${player.comment}</div>` : '';
                            
                            // En mode arbitre uniquement, onclick sur les scores
                            const scoreClickEvent = !isPlayerMode ? 
                                `onclick="event.stopPropagation(); editScore(${boardNumForEvent})"` : '';
                            
                            return playerCommentHTML + `
                                <div class="player" data-color="${color}">
                                    <div class="player-color ${color}"></div>
                                    <div class="player-info">
                                        <div class="player-name" 
                                             title="Cliquez pour commenter ${player.name}"
                                             onclick="event.stopPropagation(); editPlayerComment(${boardNumForEvent}, '${color}')">
                                             ${playerNameFormatted}
                                        </div>
                                        <div class="player-elo">${playerElo}</div>
                                    </div>
                                    <div class="player-score"
                                         title="Cliquez pour saisir le r√©sultat"
                                         ${scoreClickEvent}>
                                         ${score}
                                    </div>
                                </div>
                            `;
                        };

                        const whitePlayerHTML = buildPlayerHTML(pWhite, 'white', sWhite);
                        const blackPlayerHTML = buildPlayerHTML(pBlack, 'black', sBlack);

                        playersHTML = isInverted ? (blackPlayerHTML + whitePlayerHTML) : (whitePlayerHTML + blackPlayerHTML);
                        
                    } else {
                         playersHTML = '<div style="color: #999; font-size: 0.8em; text-align: center;">En attente</div>';
                    }

                    const boardContainer = document.createElement('div');
                    
                    const hasScore = (board.score && (board.score.white !== '' || board.score.black !== ''));
                    const scoredClass = hasScore ? 'board-scored' : '';
                    const hasPlayersClass = boardHasPlayers ? 'has-players' : ''; 

                    // NOUVEAU: Cacher les tables termin√©es en mode plan joueur
                    if (isPlayerMode && document.body.classList.contains('player-plan-view-mode') && hasScore) {
                        boardContainer.style.display = 'none';
                    } else {
                        hasVisibleBoards = true; 
                    }
                    
                    // MODIFI√â: Pas de onclick en attribut, on utilise addEventListener
                    boardContainer.className = `board-container ${scoredClass} ${hasPlayersClass}`;
                    boardContainer.dataset.boardNumber = board.boardNumber;
                    
                    boardContainer.innerHTML = `
                        <button class="flip-btn-single" onclick="event.stopPropagation(); flipSingleBoard(${boardNumForEvent})">üîÑ</button>
                        <div class="board-number board-number-display" title="Double-cliquez pour √©diter" onDblClick="event.stopPropagation(); editBoardNumber(${boardNumForEvent})">
                            ${board.boardNumber}
                        </div>
                        ${playersHTML}
                    `;
                    
                    // NOUVEAU: Gestionnaire de clic qui v√©rifie le mode dynamiquement
                    boardContainer.addEventListener('click', function(e) {
                        // Seulement en mode plan joueur avec des joueurs assign√©s
                        if (isPlayerMode && document.body.classList.contains('player-plan-view-mode') && boardHasPlayers) {
                            e.stopPropagation();
                            editScore(board.boardNumber);
                        }
                    });
                    
                    boardContainer.addEventListener('mousedown', (e) => {
                        // En mode plan joueur, ne rien faire (laisser le click listener g√©rer)
                        if (isPlayerMode && document.body.classList.contains('player-plan-view-mode')) {
                             return;
                        }
                        else if (currentTool === 'moveboard') {
                            e.stopPropagation();
                            startMoveBoard(e, board.boardNumber, table.id);
                        }
                    });
                    
                    boardContainer.addEventListener('mouseenter', (e) => {
                        if (movingBoard && movingBoard.originalTableId === table.id) {
                            e.currentTarget.classList.add('over');
                        }
                    });
                    boardContainer.addEventListener('mouseleave', (e) => {
                        if (movingBoard) {
                            e.currentTarget.classList.remove('over');
                        }
                    });
                    
                    contentInner.appendChild(boardContainer);
                });
                
                // NOUVEAU: Cacher la table physique si tous ses √©chiquiers sont masqu√©s
                if (isPlayerMode && document.body.classList.contains('player-plan-view-mode') && !hasVisibleBoards) {
                    element.style.display = 'none';
                } else {
                    element.style.display = 'block';
                }
                
                if (allPaired) element.classList.add('has-pairing');
                else element.classList.remove('has-pairing');
            
            } catch (error) {
                console.error(`Erreur lors de la mise √† jour de la table ${tableId}:`, error);
            }
        }

        // --- Rotation ---
        function rotateTable(tableId, addToHistory = true) {
            if (addToHistory) saveHistoryState();
            try {
                const table = physicalTables.find(t => t.id === tableId);
                if (table) {
                    table.rotation = (table.rotation === 0) ? 90 : 0;
                    
                    const element = document.getElementById(`phys-table-${tableId}`);
                    if (element) {
                        element.className = element.className.replace(/rotate-\d+/, `rotate-${table.rotation}`);
                        element.style.setProperty('--rotation', `${table.rotation}deg`);
                        
                        element.classList.remove('vertical-layout');
                        
                        const contentInner = element.querySelector('.table-content-inner');
                        if (contentInner) {
                            contentInner.style.transform = 'rotate(0deg)'; 
                        }
                    }
                }
            } catch (error) { console.error('Error in rotateTable:', error); }
        }


        // --- Redimensionnement ---
        function startResize(e, tableId, handleSide) {
            isResizing = true;
            const table = physicalTables.find(t => t.id === tableId);
            const element = document.getElementById(`phys-table-${tableId}`);
            
            const startX = e.clientX;
            const startY = e.clientY;
            const startWidth = table.width || defaultTableWidth;
            const startXPos = table.x;
            const startYPos = table.y;
            
            function onMouseMove(e) {
                if (!isResizing) return;
                
                const deltaX = (e.clientX - startX) / currentZoom;
                const deltaY = (e.clientY - startY) / currentZoom;
                
                let delta = 0;
                
                switch(table.rotation) {
                    case 0: delta = (handleSide === 'left') ? -deltaX : deltaX; break;
                    case 90: delta = (handleSide === 'left') ? -deltaY : deltaY; break;
                    case 180: delta = (handleSide === 'left') ? deltaX : -deltaX; break;
                    case 270: delta = (handleSide === 'left') ? deltaY : -deltaY; break;
                }

                let newWidth = startWidth + delta;
                const minWidth = (table.boards.length * 150); 
                newWidth = Math.max(minWidth, Math.min(2000, newWidth)); 
                
                const widthChange = newWidth - startWidth;

                table.width = newWidth;
                element.style.width = newWidth + 'px';
                
                if (handleSide === 'left') {
                    const radians = table.rotation * Math.PI / 180;
                    const cos = Math.cos(radians);
                    const sin = Math.sin(radians);
                    
                    table.x = startXPos - (widthChange * cos);
                    table.y = startYPos - (widthChange * sin);
                    
                    element.style.left = table.x + 'px';
                    element.style.top = table.y + 'px';
                }
            }
            
            function onMouseUp() {
                if (isResizing) {
                    if (table.width !== startWidth || table.x !== startXPos || table.y !== startYPos) {
                        saveHistoryState();
                    }
                }
                isResizing = false;
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }
            
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            e.preventDefault();
        }

        function duplicateSelected() {
            if (selectedTables.length === 0) return;
            saveHistoryState();
            try {
                const newTables = [];
                selectedTables.forEach(id => {
                    const original = physicalTables.find(t => t.id === id);
                    if (original) {
                        const newTable = JSON.parse(JSON.stringify(original)); 
                        newTable.id = nextPhysicalTableId++;
                        newTable.x = original.x + 50;
                        newTable.y = original.y + 50;
                        newTable.boards.forEach(board => {
                            board.boardNumber = nextBoardNumber++;
                        });
                        physicalTables.push(newTable);
                        newTables.push(newTable.id);
                        createTableElement(newTable);
                    }
                });
                clearSelection();
                newTables.forEach(id => selectTable(id));
                updateStats();
            } catch (error) { console.error('Error in duplicateSelected:', error); }
        }

        function autoArrangeTables() {
            if (physicalTables.length === 0) {
                alert("Il n'y a aucune table √† r√©organiser. Chargez d'abord les appariements ou ajoutez des tables vierges.");
                return;
            }
            if (!confirm("Voulez-vous vraiment r√©organiser toutes les tables en fonction des param√®tres actuels ? Les positions et rotations manuelles seront perdues.")) {
                return;
            }
            
            saveHistoryState(); 
            
            try {
                const boardsPerTable = parseInt(document.getElementById('boardsPerTable').value) || 1;
                const physicalTablesPerRow = parseInt(document.getElementById('physicalTablesPerRow').value) || 10;
                const tableLengthCm = parseInt(document.getElementById('tableLength').value) || 180;
                
                let allBoards = [];
                physicalTables.forEach(pt => {
                    allBoards.push(...pt.boards);
                });
                
                allBoards.sort((a, b) => {
                    let numA = parseFloat(a.boardNumber);
                    let numB = parseFloat(b.boardNumber);
                    if (isNaN(numA)) numA = Infinity; 
                    if (isNaN(numB)) numB = Infinity;
                    if (numA !== numB) return numA - numB;
                    return String(a.boardNumber).localeCompare(String(b.boardNumber));
                });

                physicalTables = [];
                document.getElementById('canvas').innerHTML = '';
                renderAllRooms(); // <-- S'assurer que les salles sont re-rendues
                nextPhysicalTableId = 1;
                
                const layout = getLayoutConfig();
                let currentX = layout.startX;
                let currentY = layout.startY;
                const xDir = layout.xDir;
                const yDir = layout.yDir;
                const spacingY = 160 * yDir;
                const minWidthPerBoard = 150;
                let col = 0;
                
                for (let i = 0; i < allBoards.length; i += boardsPerTable) {
                    const boardsForThisTable = allBoards.slice(i, i + boardsPerTable);
                    
                    const tableWidth = Math.max(tableLengthCm * 1.2, minWidthPerBoard * boardsForThisTable.length);
                    
                    if (col === 0) {
                        currentX = layout.startX; 
                    }

                    const tableX = (xDir === 1) ? currentX : currentX - tableWidth;
                    const tableY = (yDir === 1) ? currentY : currentY - 160;

                    const physicalTable = {
                        id: nextPhysicalTableId++,
                        x: tableX,
                        y: tableY,
                        rotation: 0,
                        width: tableWidth,
                        arbiterComment: { text: "", flag: "none" },
                        boards: boardsForThisTable 
                    };
                    
                    physicalTables.push(physicalTable);
                    
                    currentX += (tableWidth + 30) * xDir;
                    col++;
                    if (col >= physicalTablesPerRow) {
                        col = 0;
                        currentY += spacingY;
                    }
                }

                renderAllTables();
                updateStats();
                setTimeout(fitAllTables, 100);

            } catch (e) {
                console.error("Error during autoArrange:", e);
                alert("Une erreur est survenue lors de la r√©organisation.");
            }
        }
        
        // --- NOUVELLES FONCTIONS SALLES / MURS (MODIFI√âES) ---

        function addRoom() {
            const name = document.getElementById('roomNameInput').value.trim() || "Nouvelle Salle";
            saveHistoryState();
            
            const newRoom = {
                id: nextRoomId++,
                name: name,
                x: 100,
                y: 100,
                width: 500,
                height: 500
            };
            
            rooms.push(newRoom);
            createRoomElement(newRoom);
            document.getElementById('roomNameInput').value = '';
        }

        function createRoomElement(room) {
            const canvas = document.getElementById('canvas');
            const element = document.createElement('div');
            element.className = 'room-element';
            element.id = `room-${room.id}`;
            element.style.left = room.x + 'px';
            element.style.top = room.y + 'px';
            element.style.width = room.width + 'px';
            element.style.height = room.height + 'px';
            element.dataset.roomId = room.id;
            
            element.innerHTML = `
                <div class="room-title" ondblclick="event.stopPropagation(); renameRoom(${room.id})" title="Double-cliquez pour renommer">
                    ${room.name}
                </div>
                <div class="room-delete-btn" onclick="event.stopPropagation(); deleteRoom(${room.id})">√ó</div>
                <div class="room-resize-handle tl" onmousedown="event.stopPropagation(); startRoomResize(event, ${room.id}, 'tl')"></div>
                <div class="room-resize-handle tr" onmousedown="event.stopPropagation(); startRoomResize(event, ${room.id}, 'tr')"></div>
                <div class="room-resize-handle bl" onmousedown="event.stopPropagation(); startRoomResize(event, ${room.id}, 'bl')"></div>
                <div class="room-resize-handle br" onmousedown="event.stopPropagation(); startRoomResize(event, ${room.id}, 'br')"></div>
            `;
            
            element.addEventListener('mousedown', (e) => handleRoomMouseDown(e, room.id));
            
            // Placer avant les tables (qui ont un z-index >= 10)
            canvas.prepend(element);
        }
        
        function renameRoom(roomId) {
            const room = rooms.find(r => r.id === roomId);
            if (!room) return;
            
            const newName = prompt("Nouveau nom pour la salle :", room.name);
            if (newName !== null && newName.trim() !== "") {
                saveHistoryState();
                room.name = newName.trim();
                const element = document.getElementById(`room-${roomId}`);
                if (element) {
                    element.querySelector('.room-title').textContent = room.name;
                }
            }
        }
        
        function deleteRoom(roomId, addToHistory = true) {
            if (addToHistory) saveHistoryState();
            
            const index = rooms.findIndex(r => r.id === roomId);
            if (index > -1) {
                rooms.splice(index, 1);
                const element = document.getElementById(`room-${roomId}`);
                if (element) {
                    element.remove();
                }
            }
        }

        function renderAllRooms() {
            // D'abord, supprimer les anciens √©l√©ments de salle
            document.querySelectorAll('.room-element').forEach(el => el.remove());
            // Puis, recr√©er
            rooms.forEach(room => createRoomElement(room));
        }

        function handleRoomMouseDown(e, roomId) {
            if (e.target.classList.contains('room-resize-handle') || e.target.classList.contains('room-delete-btn')) return;
            if (currentTool !== 'select') return;

            clearSelection(); // D√©s√©lectionner les tables
            document.querySelectorAll('.room-element.selected').forEach(el => el.classList.remove('selected'));
            
            const element = document.getElementById(`room-${roomId}`);
            element.classList.add('selected');
            
            isDragging = true;
            const room = rooms.find(r => r.id === roomId);
            
            dragContext = { 
                isRoom: true,
                room, 
                element, 
                initialX: room.x, 
                initialY: room.y,
                startX: e.clientX, 
                startY: e.clientY 
            };
            
            element.style.zIndex = '5';
            e.preventDefault();
            e.stopPropagation();
        }

        function startRoomResize(e, roomId, handle) {
            isResizing = true;
            const room = rooms.find(r => r.id === roomId);
            const element = document.getElementById(`room-${roomId}`);
            
            const startX = e.clientX;
            const startY = e.clientY;
            const startWidth = room.width;
            const startHeight = room.height;
            const startXPos = room.x;
            const startYPos = room.y;
            
            function onMouseMove(e) {
                if (!isResizing) return;
                
                const deltaX = (e.clientX - startX) / currentZoom;
                const deltaY = (e.clientY - startY) / currentZoom;

                if (handle.includes('r')) {
                    room.width = Math.max(100, startWidth + deltaX);
                    element.style.width = room.width + 'px';
                }
                if (handle.includes('b')) {
                    room.height = Math.max(100, startHeight + deltaY);
                    element.style.height = room.height + 'px';
                }
                if (handle.includes('l')) {
                    room.width = Math.max(100, startWidth - deltaX);
                    room.x = startXPos + deltaX;
                    element.style.width = room.width + 'px';
                    element.style.left = room.x + 'px';
                }
                if (handle.includes('t')) {
                    room.height = Math.max(100, startHeight - deltaY);
                    room.y = startYPos + deltaY;
                    element.style.height = room.height + 'px';
                    element.style.top = room.y + 'px';
                }
            }
            
            function onMouseUp() {
                if (isResizing) {
                    saveHistoryState();
                }
                isResizing = false;
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }
            
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            e.preventDefault();
        }


        // --- Appariements, CSV, Recherche ---
        
        function loadPapiFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (physicalTables.length > 0) {
                if (!confirm("Charger ce fichier PAPI remplacera les appariements de la ronde actuelle. Continuer ?")) {
                    event.target.value = ''; 
                    return;
                }
            }
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    parsePapiFile(e.target.result);
                } catch (error) {
                    console.error('Error parsing PAPI file:', error);
                    alert('Erreur lors du traitement du fichier HTML: ' + error.message);
                }
            };
            reader.readAsText(file, 'ISO-8859-1');
            event.target.value = ''; 
        }

        function parsePapiFile(htmlContent) {
            saveHistoryState();
            
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlContent, 'text/html');
            const rows = doc.querySelectorAll('tr[class^="papi_small_"]');
            const pairings = {};
            let maxBoardNum = 0;
            
            rows.forEach(row => {
                try {
                    if (row.children.length < 10) return;
                    
                    const player1Name = row.children[1].textContent.trim();
                    const player1Elo = row.children[2].textContent.trim().replace(/\s/g, ' '); 
                    const tableInfo = row.children[5].textContent.trim();
                    const colorInfo = row.children[6].textContent.trim();
                    const player2Name = row.children[8].textContent.trim();
                    const player2Elo = row.children[9].textContent.trim().replace(/\s/g, ' '); 
                    
                    if (!tableInfo.startsWith('TABLE')) return;
                    
                    const boardNumStr = tableInfo.replace('TABLE', '').trim();
                    const boardNum = parseInt(boardNumStr); 
                    
                    if (isNaN(boardNum) || boardNum <= 0) {
                        return; 
                    }
                    
                    if (!pairings[boardNum]) {
                        let whitePlayer, blackPlayer, whiteElo, blackElo;
                        if (colorInfo.includes('blancs')) {
                            whitePlayer = player1Name;
                            whiteElo = player1Elo;
                            blackPlayer = player2Name;
                            blackElo = player2Elo;
                        } else {
                            whitePlayer = player2Name;
                            whiteElo = player2Elo;
                            blackPlayer = player1Name;
                            blackElo = player1Elo;
                        }
                        
                        pairings[boardNum] = {
                            white: { name: whitePlayer, elo: whiteElo, comment: "" },
                            black: { name: blackPlayer, elo: blackElo, comment: "" }
                        };
                        
                        if (boardNum > maxBoardNum) maxBoardNum = boardNum;
                    }
                } catch (e) {
                    console.warn('Skipped a row during PAPI parse:', e);
                }
            });

            const boardNumbers = Object.keys(pairings).map(Number).sort((a, b) => a - b);
            
            if (boardNumbers.length === 0) {
                alert('Aucun appariement valide trouv√© dans le fichier.');
                historyStack.pop();
                updateHistoryButtons();
                return;
            }

            // Si la disposition est vide, on la cr√©e
            if (physicalTables.length === 0) {
                physicalTables = [];
                document.getElementById('canvas').innerHTML = '';
                renderAllRooms(); // <-- S'assurer que les salles sont re-rendues
                nextPhysicalTableId = 1;
                nextBoardNumber = maxBoardNum + 1;
                
                const boardsPerTable = parseInt(document.getElementById('boardsPerTable').value) || 1;
                const physicalTablesPerRow = parseInt(document.getElementById('physicalTablesPerRow').value) || 10;
                const tableLengthCm = parseInt(document.getElementById('tableLength').value) || 180;
                
                const minWidthPerBoard = 150; 
                
                const layout = getLayoutConfig(); 
                let currentX = layout.startX;
                let currentY = layout.startY;
                const xDir = layout.xDir;
                const yDir = layout.yDir;
                
                const spacingY = 160 * yDir; 
                let col = 0;

                for (let i = 0; i < boardNumbers.length; i += boardsPerTable) {
                    const boardsForThisTable = boardNumbers.slice(i, i + boardsPerTable);
                    const tableWidth = Math.max(tableLengthCm * 1.2, minWidthPerBoard * boardsForThisTable.length);
                    
                    if (col === 0) {
                        currentX = layout.startX; 
                    }

                    const tableX = (xDir === 1) ? currentX : currentX - tableWidth;
                    const tableY = (yDir === 1) ? currentY : currentY - 160;

                    const physicalTable = {
                        id: nextPhysicalTableId++,
                        x: tableX,
                        y: tableY,
                        rotation: 0,
                        width: tableWidth,
                        arbiterComment: { text: "", flag: "none" },
                        boards: []
                    };

                    boardsForThisTable.forEach(boardNum => {
                        const pairing = pairings[boardNum]; 
                        physicalTable.boards.push({
                            boardNumber: boardNum,
                            players: pairing, 
                            flipped: false,
                            score: { white: "", black: "" } 
                        });
                    });
                    
                    physicalTables.push(physicalTable);
                    
                    currentX += (tableWidth + 30) * xDir;
                    col++;
                    if (col >= physicalTablesPerRow) {
                        col = 0;
                        currentY += spacingY;
                    }
                }
                setTimeout(fitAllTables, 100); 

            } else {
                // La disposition existe, on fusionne les appariements
                physicalTables.forEach(pt => {
                    pt.boards.forEach(b => {
                        const pairing = pairings[b.boardNumber];
                        if (pairing) {
                            b.players = pairing;
                            b.score = { white: "", black: "" };
                            b.flipped = false;
                        }
                    });
                });
            }


            renderAllTables();
            updateStats();
            alert(`${boardNumbers.length} appariements charg√©s dans la ronde actuelle !`);
        }


        function clearPairings() {
            saveHistoryState(); 
            physicalTables.forEach(t => t.boards.forEach(b => {
                b.players = null;
                b.score = { white: "", black: "" }; 
            }));
            renderAllTables();
            updateStats();
        }
        
        function searchTables() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase().trim();
            const suggestionsList = document.getElementById('search-suggestions');
            suggestionsList.innerHTML = '';
            
            document.querySelectorAll('.table-element').forEach(el => {
                el.style.opacity = '1';
                el.style.transform = el.style.transform.replace(/scale\([^)]*\)/, '');
                el.style.zIndex = '10'; // Retour au z-index de base
            });

            if (!searchTerm) return;
            
            let foundTable = null; 
            const addedSuggestions = new Set(); // NOUVEAU: √âviter les doublons
            
            physicalTables.forEach(table => {
                const element = document.getElementById(`phys-table-${table.id}`);
                let tableMatches = false;
                table.boards.forEach(board => {
                    let matches = false;
                    let matchValue = '';
                    if (board.boardNumber.toString().toLowerCase().includes(searchTerm)) {
                        matches = true;
                        matchValue = `√âchiquier ${board.boardNumber}`;
                    }
                    if (board.players) {
                        if (board.players.white.name.toLowerCase().includes(searchTerm)) {
                            matches = true;
                            matchValue = getSimplePlayerName(board.players.white.name); // MODIFI√â
                        } else if (board.players.black.name.toLowerCase().includes(searchTerm)) {
                            matches = true;
                            matchValue = getSimplePlayerName(board.players.black.name); // MODIFI√â
                        }
                    }
                    if (matches) {
                        tableMatches = true; 
                        // MODIFI√â: G√©rer les doublons
                        if (matchValue && !addedSuggestions.has(matchValue)) {
                            const option = document.createElement('option');
                            option.value = matchValue;
                            suggestionsList.appendChild(option);
                            addedSuggestions.add(matchValue);
                        }
                    }
                });
                if (tableMatches) {
                    if (!foundTable) foundTable = table; 
                    element.style.transform = 'scale(1.1)';
                    element.style.zIndex = '999';
                } else {
                    element.style.opacity = '0.3';
                }
            });
            if (foundTable) scrollToTable(foundTable);
        }
        function scrollToTable(table) {
            if (!table) return;
            const container = document.getElementById('canvasContainer');
            const containerWidth = container.clientWidth, containerHeight = container.clientHeight;
            const tableWidth = table.width || defaultTableWidth;
            const tableCenterX = (table.x + tableWidth / 2) * currentZoom;
            const tableCenterY = (table.y + 160 / 2) * currentZoom; 
            container.scrollLeft = tableCenterX - containerWidth / 2;
            container.scrollTop = tableCenterY - containerHeight / 2;
        }

        // --- Sauvegarde, Chargement, PDF ---
        function clearAll() {
            if (confirm('√ätes-vous s√ªr de vouloir effacer TOUT le tournoi (toutes les rondes) ?')) {
                localStorage.removeItem(SAVE_KEY); 
                localStorage.removeItem(SAVE_KEY_TIMESTAMP); 
                
                physicalTables = [];
                rooms = [];
                nextPhysicalTableId = 1;
                nextRoomId = 1;
                nextBoardNumber = 1;
                historyStack = [];
                redoStack = [];
                
                roundsStore = {};
                currentRoundKey = 'ronde1';
                loadStateFromStore('ronde1');
                updateRoundSelector();

                document.getElementById('canvas').innerHTML = '';
                updateStats();
            }
        }
        
        function saveLayout() {
            saveCurrentStateToStore(); 
            const data = {
                roundsStore: JSON.parse(JSON.stringify(roundsStore)),
                currentRoundKey: currentRoundKey,
                arbiterPassword: arbiterPassword
            };
            
            Object.values(data.roundsStore).forEach(roundState => {
                if (roundState.physicalTables) {
                    roundState.physicalTables.forEach(t => {
                        delete t.mouseDownHandler;
                    });
                }
            });

            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `tournoi-plan-salles-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function loadLayout() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        
                        if (data.physicalTables) {
                            roundsStore = {
                                'ronde1': {
                                    physicalTables: data.physicalTables,
                                    rooms: data.rooms || [],
                                    nextPhysicalTableId: data.nextPhysicalTableId,
                                    nextRoomId: data.nextRoomId || 1,
                                    nextBoardNumber: data.nextBoardNumber,
                                    historyStack: [],
                                    redoStack: []
                                }
                            };
                            currentRoundKey = 'ronde1';
                            alert('Ancien fichier de plan d√©tect√©, charg√© comme "Ronde 1".');
                            } else if (data.roundsStore && typeof data.roundsStore === 'object' && !Array.isArray(data.roundsStore)) {                            roundsStore = data.roundsStore;
                            currentRoundKey = data.currentRoundKey || 'ronde1';
                            arbiterPassword = data.arbiterPassword || null;
                        } else {
                            throw new Error("Format de fichier non reconnu.");
                        }

                        // Migration
                        Object.values(roundsStore).forEach(roundState => {
                            if (!roundState.physicalTables) roundState.physicalTables = [];
                            if (!roundState.rooms) roundState.rooms = [];
                            if (!roundState.nextRoomId) roundState.nextRoomId = 1;
                            roundState.physicalTables.forEach(pt => {
                                if (!pt.arbiterComment) pt.arbiterComment = { text: "", flag: "none" };
                                pt.boards.forEach(b => {
                                    if (b.score === undefined) b.score = { white: "", black: "" };
                                    // Correction migration
                                    if (b.players && b.players.white && typeof b.players.white === 'string') {
                                        b.players = {
                                            white: { name: b.players.white, elo: (b.players.white_elo || ""), comment: "" },
                                            black: { name: b.players.black, elo: (b.players.black_elo || ""), comment: "" }
                                        };
                                    } else if (b.players) {
                                        if (b.players.white && !b.players.white.elo) b.players.white.elo = "";
                                        if (b.players.white && !b.players.white.comment) b.players.white.comment = "";
                                        if (b.players.black && !b.players.black.elo) b.players.black.elo = "";
                                        if (b.players.black && !b.players.black.comment) b.players.black.comment = "";
                                    }
                                });
                            });
                            if (!roundState.historyStack) roundState.historyStack = [];
                            if (!roundState.redoStack) roundState.redoStack = [];
                        });
                        
                        updateRoundSelector();
                        loadStateFromStore(currentRoundKey);
                        autoSaveToLocalStorage();
                        
                        alert('Tournoi charg√© avec succ√®s !');
                    } catch (error) {
                        alert('Erreur lors du chargement du fichier: ' + error.message);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        function renderAllTables() {
            document.querySelectorAll('.table-element').forEach(el => el.remove());
            physicalTables.forEach(table => createTableElement(table));
        }
        
        function exportToPDF() {
            if (physicalTables.length === 0) {
                alert('Aucune table √† exporter');
                return;
            }
            const totalBoards = physicalTables.reduce((acc, p) => acc + p.boards.length, 0);
            let content = `
                <html><head><title>Liste des Appariements - ${currentRoundKey.replace('r','R')}</title>
                    <style>
                        @media print { @page { size: A4 portrait; margin: 1cm; } }
                        body { font-family: Arial, sans-serif; padding: 20px; }
                        h1 { text-align: center; color: #2c3e50; }
                        .elo { color: #666; font-size: 0.9em; margin-left: 5px; }
                        .score { font-weight: bold; color: #c00; }
                        .lastname { font-weight: bold; text-transform: uppercase; }
                    </style>
                </head><body>
                    <h1>‚ôüÔ∏è Appariements - ${currentRoundKey.replace('r','R')}</h1>
                    <p style="text-align: center; color: #666;">Nombre d'√©chiquiers: ${totalBoards}</p>
                    
                    <div class="pairing-list">
                        <table style="width: 100%; border-collapse: collapse; margin-top: 20px;">
                            <thead><tr style="background: #f0f0f0;">
                                <th style="border: 1px solid #ddd; padding: 8px;">√âch.</th>
                                <th style="border: 1px solid #ddd; padding: 8px;">Joueur Blancs</th>
                                <th style="border: 1px solid #ddd; padding: 8px;">Score</th>
                                <th style="border: 1px solid #ddd; padding: 8px;">Joueur Noirs</th>
                                <th style="border: 1px solid #ddd; padding: 8px;">Score</th>
                            </tr></thead><tbody>`;
            const allBoards = [];
            physicalTables.forEach(t => t.boards.forEach(b => allBoards.push(b)));
            allBoards.sort((a, b) => {
                let numA = parseFloat(a.boardNumber);
                let numB = parseFloat(b.boardNumber);
                if (isNaN(numA)) numA = Infinity;
                if (isNaN(numB)) numB = Infinity;
                if (numA !== numB) return numA - numB;
                return String(a.boardNumber).localeCompare(String(b.boardNumber));
            });
            
            allBoards.forEach(board => {
                const whiteName = board.players ? formatPlayerName(board.players.white.name) : '-';
                const whiteElo = board.players ? board.players.white.elo : '';
                const blackName = board.players ? formatPlayerName(board.players.black.name) : '-';
                const blackElo = board.players ? board.players.black.elo : '';
                const whiteScore = board.score ? board.score.white : '';
                const blackScore = board.score ? board.score.black : '';

                content += `<tr>
                        <td style="border: 1px solid #ddd; padding: 8px; text-align: center; font-weight: bold;">${board.boardNumber}</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">
                            ${whiteName} <span class="elo">(${whiteElo})</span>
                        </td>
                        <td style="border: 1px solid #ddd; padding: 8px; text-align: center; font-weight: bold;">${whiteScore}</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">
                            ${blackName} <span class="elo">(${blackElo})</span>
                        </td>
                        <td style="border: 1px solid #ddd; padding: 8px; text-align: center; font-weight: bold;">${blackScore}</td>
                    </tr>`;
            });
            content += `</tbody></table></div></body></html>`;
            const printWindow = window.open('', '', 'height=800,width=1000');
            printWindow.document.write(content);
            printWindow.document.close();
            printWindow.focus();
            // MODIFI√â: Ligne d'impression automatique supprim√©e
            // setTimeout(() => { printWindow.print(); }, 250); 
        }

        // --- EXPORT PDF VISUEL (CORRIG√â POUR HAUTE R√âSOLUTION / MULTI-PAGE) ---
        function showLoading(isLoading) {
            const overlay = document.getElementById('loadingOverlay');
            overlay.style.display = isLoading ? 'flex' : 'none';
        }

        async function exportVisualPDF() {
            let jsPDF;
            try {
                jsPDF = window.jspdf.jsPDF;
            } catch (e) {
                console.error("Erreur: La biblioth√®que jsPDF n'a pas pu √™tre charg√©e.", e);
                alert("Erreur: La biblioth√®que jsPDF n'a pas pu √™tre charg√©e. V√©rifiez votre connexion internet ou un bloqueur de publicit√©.");
                return;
            }

            if (physicalTables.length === 0 && rooms.length === 0) {
                alert('Rien √† exporter');
                return;
            }

            showLoading(true);
            clearSelection(); 
            document.querySelectorAll('.room-element.selected').forEach(el => el.classList.remove('selected'));

            const orientation = document.getElementById('pdfOrientation').value;
            const canvasElement = document.getElementById('canvas');
            
            // MODIFI√â: Sauvegarder le transform (zoom) actuel
            const originalTransform = canvasElement.style.transform;
            
            // MODIFI√â: R√©initialiser le zoom pour la capture
            canvasElement.style.transform = 'scale(1)';

            await new Promise(resolve => setTimeout(resolve, 50)); // Attendre que le style s'applique

            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            
            physicalTables.forEach(t => {
                minX = Math.min(minX, t.x);
                minY = Math.min(minY, t.y);
                
                const radians = t.rotation * Math.PI / 180;
                const cos = Math.cos(radians);
                const sin = Math.sin(radians);
                const width = t.width || defaultTableWidth;
                const height = 160; 
                
                const xCoords = [ t.x, t.x + width * cos, t.x - height * sin, t.x + width * cos - height * sin ];
                const yCoords = [ t.y, t.y + width * sin, t.y + height * cos, t.y + width * sin + height * cos ];
                
                maxX = Math.max(maxX, ...xCoords);
                maxY = Math.max(maxY, ...yCoords);
            });
            
            rooms.forEach(r => {
                minX = Math.min(minX, r.x);
                minY = Math.min(minY, r.y);
                maxX = Math.max(maxX, r.x + r.width);
                maxY = Math.max(maxY, r.y + r.height);
            });


            if (minX === Infinity) {
                showLoading(false);
                canvasElement.style.transform = originalTransform; // Restaurer
                return;
            }

            const padding = 50; 
            const contentWidth = (maxX - minX) + (padding * 2);
            const contentHeight = (maxY - minY) + (padding * 2);

            html2canvas(canvasElement, {
                logging: false,
                useCORS: true,
                width: contentWidth,
                height: contentHeight,
                x: minX - padding,
                y: minY - padding,
                scale: 2, // Garder une bonne r√©solution
                backgroundColor: '#ecf0f1', // Fond du canvas
                removeContainer: true
            }).then(canvasImage => {
                const imgData = canvasImage.toDataURL('image/png');
                
                const pdf = new jsPDF({
                    orientation: orientation,
                    unit: 'mm',
                    format: 'a4'
                });

                const margin = 10;
                
                const pageFormats = {
                    'a4': { 'p': { w: 210, h: 297 }, 'l': { w: 297, h: 210 } }
                };
                
                // MODIFI√â: Calcul des dimensions de la page
                const pageW_mm = pageFormats['a4'][orientation].w;
                const pageH_mm = pageFormats['a4'][orientation].h;
                const innerPageW_mm = pageW_mm - (margin * 2);
                const innerPageH_mm = pageH_mm - (margin * 2);

                const imgW_px = canvasImage.width;
                const imgH_px = canvasImage.height;
                
                // MODIFI√â: Calcul de l'√©chelle et centrage
                const imgRatio = imgW_px / imgH_px;
                const pageRatio = innerPageW_mm / innerPageH_mm;

                let finalImgW_mm, finalImgH_mm;
                if (imgRatio > pageRatio) {
                    // L'image est plus large que la page
                    finalImgW_mm = innerPageW_mm;
                    finalImgH_mm = innerPageW_mm / imgRatio;
                } else {
                    // L'image est plus haute que la page
                    finalImgH_mm = innerPageH_mm;
                    finalImgW_mm = innerPageH_mm * imgRatio;
                }
                
                // Calcul du centrage
                const posX = margin + (innerPageW_mm - finalImgW_mm) / 2;
                const posY = margin + (innerPageH_mm - finalImgH_mm) / 2;
                
                pdf.addImage(imgData, 'PNG', posX, posY, finalImgW_mm, finalImgH_mm);
                
                pdf.save(`plan-de-salle-${currentRoundKey}-${Date.now()}.pdf`);

            }).catch(err => {
                console.error('Erreur lors de la g√©n√©ration du PDF:', err);
                alert('Une erreur est survenue lors de la cr√©ation du PDF visuel.');
            }).finally(() => {
                showLoading(false); 
                // MODIFI√â: Restaurer le zoom
                canvasElement.style.transform = originalTransform; 
            });
        }

        // ... (apr√®s la fonction syncWithPAPI)

        /**
         * Exporte TOUT le tournoi (toutes les rondes) au format TRF 1.1 de la FIDE.
         * Ce format est un fichier texte √† largeur fixe.
         */
        function exportToTRF() {
            if (Object.keys(roundsStore).length === 0) {
                alert("Aucune donn√©e de tournoi √† exporter.");
                return;
            }

            // --- 1. Collecter tous les joueurs et toutes les rondes ---
            const masterPlayerList = {}; // { "NOM Pr√©nom": { id: 0, name: "", elo: 0, points: 0, games: [] } }
            const playerMap = new Map(); // Map<"NOM Pr√©nom", id>
            const allRoundKeys = Object.keys(roundsStore).sort((a, b) => {
                return parseInt(a.replace('ronde', '')) - parseInt(b.replace('ronde', ''));
            });
            const numRounds = allRoundKeys.length;

            // Fonction pour normaliser le nom (pour servir de cl√© unique)
            const normalizeName = (name) => (name || "").trim().toUpperCase();

            // Premi√®re passe : d√©couvrir tous les joueurs
            let playerIdCounter = 1;
            for (const roundKey of allRoundKeys) {
                const roundData = roundsStore[roundKey];
                if (!roundData.physicalTables) continue;
                
                for (const table of roundData.physicalTables) {
                    for (const board of table.boards) {
                        if (board.players) {
                            const pWhiteName = normalizeName(board.players.white.name);
                            const pBlackName = normalizeName(board.players.black.name);

                            if (pWhiteName && !playerMap.has(pWhiteName)) {
                                playerMap.set(pWhiteName, playerIdCounter);
                                masterPlayerList[pWhiteName] = {
                                    id: playerIdCounter++,
                                    name: board.players.white.name, // Garde le nom original
                                    elo: board.players.white.elo || 0,
                                    points: 0,
                                    games: [] // [ { round: 1, oppId: 2, color: 'w', result: '+' }, ... ]
                                };
                            }
                            if (pBlackName && !playerMap.has(pBlackName)) {
                                playerMap.set(pBlackName, playerIdCounter);
                                masterPlayerList[pBlackName] = {
                                    id: playerIdCounter++,
                                    name: board.players.black.name, // Garde le nom original
                                    elo: board.players.black.elo || 0,
                                    points: 0,
                                    games: []
                                };
                            }
                        }
                    }
                }
            }

            const numPlayers = playerMap.size;
            if (numPlayers === 0) {
                alert("Aucun joueur appari√© trouv√© dans le tournoi.");
                return;
            }

            // --- 2. Seconde passe : collecter tous les r√©sultats et calculer les points ---
            let roundCounter = 1;
            for (const roundKey of allRoundKeys) {
                const roundData = roundsStore[roundKey];
                if (!roundData.physicalTables) continue;

                for (const table of roundData.physicalTables) {
                    for (const board of table.boards) {
                        if (board.players) {
                            const pWhiteName = normalizeName(board.players.white.name);
                            const pBlackName = normalizeName(board.players.black.name);
                            const pWhiteId = playerMap.get(pWhiteName);
                            const pBlackId = playerMap.get(pBlackName);

                            let whiteResultChar = ' ';
                            let blackResultChar = ' ';
                            let whitePoints = 0;
                            let blackPoints = 0;

                            const sWhite = board.score.white;
                            const sBlack = board.score.black;

                            if (sWhite === '1') { whiteResultChar = '+'; whitePoints = 1; }
                            if (sBlack === '1') { blackResultChar = '+'; blackPoints = 1; }
                            if (sWhite === '0') { whiteResultChar = '-'; }
                            if (sBlack === '0') { blackResultChar = '-'; }
                            if (sWhite === '1/2' || sBlack === '1/2') {
                                whiteResultChar = '='; whitePoints = 0.5;
                                blackResultChar = '='; blackPoints = 0.5;
                            }
                            // G√©rer les forfaits (PAPI F-1 vs TRF -)
                            if (sWhite === 'F') { whiteResultChar = '-'; }
                            if (sBlack === 'F') { blackResultChar = '-'; }
                            if (sWhite === '1' && sBlack === 'F') { blackResultChar = '-'; } // F-1
                            if (sBlack === '1' && sWhite === 'F') { whiteResultChar = '-'; } // 1-F
                            
                            // TRF n'a pas de 0-0, c'est F-F (double -)
                            if (sWhite === '0' && sBlack === '0') {
                                whiteResultChar = '-'; blackResultChar = '-';
                            }

                            if (masterPlayerList[pWhiteName]) {
                                masterPlayerList[pWhiteName].points += whitePoints;
                                masterPlayerList[pWhiteName].games[roundCounter - 1] = {
                                    oppId: pBlackId,
                                    color: 'w',
                                    result: whiteResultChar
                                };
                            }
                            if (masterPlayerList[pBlackName]) {
                                masterPlayerList[pBlackName].points += blackPoints;
                                masterPlayerList[pBlackName].games[roundCounter - 1] = {
                                    oppId: pWhiteId,
                                    color: 'b',
                                    result: blackResultChar
                                };
                            }
                        }
                    }
                }
                roundCounter++;
            }

            // --- 3. Trier les joueurs (par points DESC, puis nom ASC) ---
            const sortedPlayers = Object.values(masterPlayerList).sort((a, b) => {
                if (b.points !== a.points) {
                    return b.points - a.points;
                }
                return a.name.localeCompare(b.name);
            });

            // --- 4. Construire le fichier TRF ---
            let trfContent = "";
            const today = new Date().toISOString().split('T')[0].replace(/-/g, '.');

            // En-t√™tes (0xx)
            // MODIF: Utiliser une valeur par d√©faut si tournamentName n'existe plus
            trfContent += "001 " + ("Tournoi ChessRoom").padEnd(60) + "\n";
            trfContent += "010 Lieu Inconnu\n";
            trfContent += "011 FRA\n"; // Placeholder
            trfContent += "012 " + today + "\n"; // Placeholder date d√©but
            trfContent += "013 " + today + "\n"; // Placeholder date fin
            trfContent += "014 " + numPlayers + "\n";
            trfContent += "015 " + numPlayers + "\n"; // Nb joueurs comptant ELO
            trfContent += "016 " + numRounds + "\n";
            trfContent += "021 Arbitre Principal\n"; // Placeholder
            trfContent += "031 10m+0s\n"; // Placeholder
            trfContent += "112 FIDE-Official Rating list used\n";

            // Lignes des joueurs (format principal)
            sortedPlayers.forEach((player, index) => {
                let line = "";
                const rank = index + 1;
                const pointsStr = (player.points % 1 === 0) ? `${player.points}.0` : `${player.points}`;

                line += String(rank).padStart(4) + " ";             // Rang
                line += " ";                                       // Sexe (placeholder)
                line += player.name.padEnd(33) + " ";              // Nom
                line += String(player.elo || 0).padStart(4) + " "; // ELO
                line += "FRA ";                                    // F√©d (placeholder)
                line += pointsStr.padStart(4) + " ";               // Points
                line += String(rank).padStart(4) + "  ";           // Rang (bis)

                // Boucle des rondes
                for (let r = 0; r < numRounds; r++) {
                    const game = player.games[r];
                    if (game) {
                        // Ex: " 123 w +"
                        line += String(game.oppId || 0).padStart(5) + " ";
                        line += (game.color || " ") + " ";
                        line += (game.result || " ") + "  ";
                    } else {
                        // Pas de partie (bye, ou joueur absent)
                        // Placeholder pour un BYE 1pt
                        if (player.games.length < numRounds) {
                            line += "    0 w +  "; 
                            // TODO: Am√©liorer la gestion du bye (il faudrait le stocker)
                        } else {
                             line += "             "; // Espace vide
                        }
                    }
                }
                trfContent += line.trimEnd() + "\n";
            });

            // --- 5. T√©l√©charger le fichier ---
            const blob = new Blob([trfContent], { type: 'text/plain;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            
            link.setAttribute("href", url);
            link.setAttribute("download", "tournoi.trf");
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            
            link.click();
            
            document.body.removeChild(link);
            
            showNotification('Export TRF (FIDE) termin√© !', 'success');
        }

        // --- Stats, Zoom, etc. ---
        function updateStats() {
            let totalBoards = 0, pairedBoards = 0, remainingBoards = 0; // NOUVEAU: Ajout de remainingBoards
            
            physicalTables.forEach(t => {
                totalBoards += t.boards.length;
                t.boards.forEach(b => { 
                    if (b.players) {
                        pairedBoards++; 
                        
                        // NOUVEAU: Calcul des √©chiquiers restants
                        if (b.score.white === '' && b.score.black === '') {
                            remainingBoards++;
                        }
                    }
                });
            });
            
            document.getElementById('totalBoards').textContent = totalBoards;
            document.getElementById('pairedBoards').textContent = pairedBoards;
            document.getElementById('totalPlayers').textContent = pairedBoards * 2;
            document.getElementById('remainingBoards').textContent = remainingBoards; // NOUVEAU: Mise √† jour du HTML
        }
        
        function resetZoom() { applyZoom(1); }
        function fitAllTables() {
            if (physicalTables.length === 0 && rooms.length === 0) return resetZoom();
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            
            physicalTables.forEach(t => {
                minX = Math.min(minX, t.x); minY = Math.min(minY, t.y);
                maxX = Math.max(maxX, t.x + (t.width || defaultTableWidth));
                maxY = Math.max(maxY, t.y + 160); 
            });
            
            rooms.forEach(r => {
                minX = Math.min(minX, r.x); minY = Math.min(minY, r.y);
                maxX = Math.max(maxX, r.x + r.width);
                maxY = Math.max(maxY, r.y + r.height);
            });

            if (minX === Infinity) return resetZoom();
            
            const container = document.getElementById('canvasContainer');
            const cWidth = container.clientWidth, cHeight = container.clientHeight;
            const contentWidth = maxX - minX, contentHeight = maxY - minY;
            const padding = 50; 
            const zoomX = (cWidth - padding * 2) / contentWidth;
            const zoomY = (cHeight - padding * 2) / contentHeight;
            let newZoom = Math.min(zoomX, zoomY);
            newZoom = Math.max(0.1, Math.min(2.0, newZoom));
            applyZoom(newZoom);
            const contentCenterX = (minX + maxX) / 2, contentCenterY = (minY + maxY) / 2;
            container.scrollLeft = (contentCenterX * currentZoom) - (cWidth / 2);
            container.scrollTop = (contentCenterY * currentZoom) - (cHeight / 2);
        }
        function applyZoom(newZoom) {
            if (newZoom) {
                currentZoom = newZoom;
            }
            currentZoom = Math.max(0.1, Math.min(2.0, currentZoom)); 
            
            const canvas = document.getElementById('canvas');
            canvas.style.transform = `scale(${currentZoom})`;
            
            document.getElementById('zoomLevel').textContent = Math.round(currentZoom * 100) + '%';
            document.getElementById('zoomSlider').value = currentZoom * 100;
        }

        // --- √âcouteurs Globaux (Souris, Clavier) ---
        document.addEventListener('mousemove', (e) => {
            if (movingBoard) {
                moveGhost(e);
            }
            if (isDragging && dragContext.isRoom) {
                const dx = (e.clientX - dragContext.startX) / currentZoom;
                const dy = (e.clientY - dragContext.startY) / currentZoom;
                
                const newX = Math.max(0, dragContext.initialX + dx);
                const newY = Math.max(0, dragContext.initialY + dy);
                
                dragContext.room.x = newX;
                dragContext.room.y = newY;
                dragContext.element.style.left = newX + 'px';
                dragContext.element.style.top = newY + 'px';
            }
            else if (isDragging && currentTool === 'select' && !isResizing && dragContext.tables) {
                const dx = (e.clientX - dragContext.startX) / currentZoom;
                const dy = (e.clientY - dragContext.startY) / currentZoom;
                dragContext.tables.forEach(item => {
                    const newX = Math.max(0, item.initialX + dx);
                    const newY = Math.max(0, item.initialY + dy);
                    item.table.x = newX;
                    item.table.y = newY;
                    item.element.style.left = newX + 'px';
                    item.element.style.top = newY + 'px';
                });
            }
            if (selectionBox.active && currentTool === 'multiselect') {
                const container = document.getElementById('canvasContainer');
                const containerRect = container.getBoundingClientRect();
                const currentX = (e.clientX - containerRect.left + container.scrollLeft) / currentZoom;
                const currentY = (e.clientY - containerRect.top + container.scrollTop) / currentZoom;
                const x = Math.min(selectionBox.startX, currentX);
                const y = Math.min(selectionBox.startY, currentY);
                const width = Math.abs(currentX - selectionBox.startX);
                const height = Math.abs(currentY - selectionBox.startY);
                if (selectionBox.element) {
                    selectionBox.element.style.left = x + 'px';
                    selectionBox.element.style.top = y + 'px';
                    selectionBox.element.style.width = width + 'px';
                    selectionBox.element.style.height = height + 'px';
                }
                if (!e.ctrlKey && !e.metaKey) clearSelection();
                physicalTables.forEach(table => {
                    const tableWidth = table.width || defaultTableWidth;
                    if (table.x < x + width && table.x + tableWidth > x &&
                        table.y < y + height && table.y + 180 > y) { 
                        selectTable(table.id);
                    }
                });
            }
            if (canvasDrag.active && currentTool === 'pan') {
                const container = document.getElementById('canvasContainer');
                const dx = e.clientX - canvasDrag.startX;
                const dy = e.clientY - canvasDrag.startY;
                container.scrollLeft = canvasDrag.scrollLeft - dx;
                container.scrollTop = canvasDrag.scrollTop - dy;
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (movingBoard) {
                let dropTargetTableEl = e.target.closest('.table-element');
                if (dropTargetTableEl) {
                    const targetTableId = parseInt(dropTargetTableEl.dataset.tableId);
                    const targetTable = physicalTables.find(t => t.id === targetTableId);
                    
                    const { board: movedBoard, physicalTable: originalTable } = findBoard(movingBoard.boardNumber);
                    if (movedBoard && originalTable) {
                        const originalIndex = originalTable.boards.findIndex(b => b.boardNumber.toString() === movingBoard.boardNumber.toString());
                        
                        if (originalIndex > -1) {
                            saveHistoryState();
                            const [boardToMove] = originalTable.boards.splice(originalIndex, 1);
                            
                            const targetBoardEl = e.target.closest('.board-container');
                            let targetIndex = targetTable.boards.length;
                            
                            if (targetBoardEl && targetTableId === parseInt(targetBoardEl.closest('.table-element').dataset.tableId)) {
                                const targetBoardNumStr = targetBoardEl.dataset.boardNumber;
                                targetIndex = targetTable.boards.findIndex(b => b.boardNumber.toString() === targetBoardNumStr);
                                if (targetIndex === -1) targetIndex = targetTable.boards.length;
                            }
                            
                            targetTable.boards.splice(targetIndex, 0, boardToMove);
                            
                            if (originalTable.id !== targetTable.id) {
                                updateTableDisplay(originalTable.id);
                            }
                            updateTableDisplay(targetTable.id);
                            updateStats();
                        }
                    }
                }
                
                if (movingBoard.element) {
                    document.body.removeChild(movingBoard.element);
                }
                movingBoard = null;
                isDragging = false; 
                document.querySelectorAll('.table-element, .board-container').forEach(el => {
                    el.removeEventListener('mouseenter', handleTableDropEnter);
                    el.removeEventListener('mouseleave', handleTableDropLeave);
                    el.classList.remove('over');
                    if (el.classList.contains('table-element') && !selectedTables.includes(parseInt(el.dataset.tableId))) {
                        el.classList.remove('selected');
                    }
                });
            }
            if (isDragging) {
                if(dragContext.isRoom) {
                     if (dragContext.room.x !== dragContext.initialX || dragContext.room.y !== dragContext.initialY) {
                        saveHistoryState();
                    }
                    dragContext.element.style.zIndex = '5';
                }
                else {
                    const moved = dragContext.tables && dragContext.tables.some(item => 
                        item.table.x !== item.initialX || item.table.y !== item.initialY
                    );
                    if (moved) saveHistoryState();
                    if (dragContext.tables) {
                        dragContext.tables.forEach(item => {
                            if (item.element) item.element.style.zIndex = '10';
                        });
                    }
                }
                dragContext = {}; 
            }
            isDragging = false;
            canvasDrag.active = false;
            if (selectionBox.active) {
                if (selectionBox.element) selectionBox.element.remove();
                selectionBox.element = null;
                selectionBox.active = false;
            }
        });

        document.getElementById('canvas').addEventListener('mousedown', (e) => {
            if (e.target.id === 'canvas' || e.target.classList.contains('canvas')) {
                // MODIFI√â: Autoriser le 'pan' en mode plan joueur
                if (currentTool === 'pan') {
                    canvasDrag.active = true;
                    canvasDrag.startX = e.clientX;
                    canvasDrag.startY = e.clientY;
                    const container = document.getElementById('canvasContainer');
                    canvasDrag.scrollLeft = container.scrollLeft;
                    canvasDrag.scrollTop = container.scrollTop;
                    e.preventDefault();
                } else if (currentTool === 'multiselect' && !isPlayerMode) { // D√©sactiver en mode joueur
                    const container = document.getElementById('canvasContainer');
                    const containerRect = container.getBoundingClientRect();
                    const canvas = document.getElementById('canvas');
                    selectionBox.active = true;
                    selectionBox.startX = (e.clientX - containerRect.left + container.scrollLeft) / currentZoom;
                    selectionBox.startY = (e.clientY - containerRect.top + container.scrollTop) / currentZoom;
                    const box = document.createElement('div');
                    box.className = 'selection-box';
                    box.style.left = selectionBox.startX + 'px';
                    box.style.top = selectionBox.startY + 'px';
                    box.style.width = '0px';
                    box.style.height = '0px';
                    canvas.appendChild(box);
                    selectionBox.element = box;
                    e.preventDefault();
                }
            }
        });

        document.getElementById('canvas').addEventListener('click', (e) => {
            if ((e.target.id === 'canvas' || e.target.classList.contains('canvas-container')) && currentTool !== 'multiselect') {
                clearSelection();
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.target.tagName.toLowerCase() === 'input' || e.target.tagName.toLowerCase() === 'textarea' || e.target.tagName.toLowerCase() === 'select') return;
            
            // MODIFI√â: Gestion Echap am√©lior√©e
            if (e.key === 'Escape') {
                if (document.getElementById('simplifiedScoreModal').style.display === 'flex') {
                    closeSimplifiedScoreModal();
                } else if (isPlayerMode && document.body.classList.contains('player-plan-view-mode')) {
                    returnToPlayerHome();
                } else if (document.querySelector('.modal-overlay[style*="display: flex"]')) {
                    hideScoreModal();
                    cancelQRValidation();
                    stopQRScanner();
                    document.getElementById('arbiterPassModal').style.display = 'none';
                    document.getElementById('playerLoginModal').style.display = 'none';
                    closePlayerLogoutConfirm();
                    closePlayerTextSearch();
                    closePlayerListSearch();
                } else {
                    clearSelection();
                }
                return;
            }
            
            // NOUVEAU: D√©sactiver les raccourcis en mode joueur
            if (isPlayerMode) return;
            
            if (document.getElementById('scoreModal').style.display === 'flex') return;
            
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); }
            if ((e.ctrlKey || e.metaKey) && e.key === 'y') { e.preventDefault(); redo(); }
            
            if ((e.key === 'Delete' || e.key === 'Backspace')) {
                const selectedRoom = document.querySelector('.room-element.selected');
                
                if (selectedTables.length > 0) {
                    e.preventDefault(); 
                    deleteSelected();
                } else if (selectedRoom) {
                     e.preventDefault(); 
                    deleteRoom(parseInt(selectedRoom.dataset.roomId));
                }
            }

            if (e.key === 'd' && (e.ctrlKey || e.metaKey) && selectedTables.length > 0) { e.preventDefault(); duplicateSelected(); }
            if (e.key === 'r' && selectedTables.length > 0) rotateSelected();
            if (e.key === 'p') setTool('pan');
            if (e.key === 's' && !e.ctrlKey && !e.metaKey) setTool('select');
            if (e.key === 'm') setTool('multiselect');
            if (e.key === 'a' && (e.ctrlKey || e.metaKey)) { e.preventDefault(); clearSelection(); physicalTables.forEach(t => selectTable(t.id)); }
        });

        // =====================================================
        //  LOGIQUE QR CODE INT√âGR√âE
        // =====================================================

        // --- Variables globales pour le scanner ---
        let qrStream = null;
        let qrScanInterval = null;
        let qrStagedResult = null; // R√©sultat en attente de validation

        // --- Fonction de Notification ---
        function showNotification(message, type = 'success') {
            const notif = document.getElementById('notification');
            if (!notif) return;
            notif.textContent = message;
            notif.className = `notification ${type} show`;
            setTimeout(() => notif.classList.remove('show'), 3000);
        }

        // --- Fonction de formatage (utilitaire) ---
        function formatResult(result) {
            return result === 'DRAW' ? '¬Ω-¬Ω' : result;
        }

        // --- 1. Logique de G√âN√âRATION de fiches QR ---

        function generateQRFiches() {
            const num = parseInt(document.getElementById('qrNumTables').value);
            if (isNaN(num) || num < 1 || num > 2000) {
                showNotification('Nombre invalide (1-2000)', 'error');
                return;
            }

            const results = ['1-0', 'DRAW', '0-1'];
            const labels = ['‚úÖ Blancs gagnent', '‚öñÔ∏è Nulle', '‚ùå Noirs gagnent'];
            let htmlContent = `
                <!DOCTYPE html><html lang="fr"><head><meta charset="UTF-8">
                <title>Fiches QR - ${num} tables</title>
                <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"><\/script>
                <style>
                    body { font-family: sans-serif; }
                    .qr-set { 
                        border: 3px solid #333; border-radius: 12px; 
                        padding: 20px; margin: 20px; 
                        page-break-inside: avoid; 
                    }
                    .qr-set h3 { text-align: center; font-size: 24px; margin: 0 0 20px 0; padding-bottom: 10px; border-bottom: 2px solid #ddd; }
                    .qr-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; text-align: center; }
                    .qr-item p { font-weight: 600; margin-top: 10px; }
                    @media print {
                        body { margin: 0; }
                        .qr-set { margin: 10px; }
                    }
                </style>
                </head><body>
            `;

            // G√©n√©rer la structure HTML
            for (let i = 1; i <= num; i++) {
                htmlContent += `
                    <div class="qr-set">
                        <h3>Table ${i}</h3>
                        <div class="qr-grid">`;
                results.forEach((result, idx) => {
                    htmlContent += `
                        <div class="qr-item">
                            <div id="qr-${i}-${idx}"></div> 
                            <p>${labels[idx]}</p>
                        </div>`;
                });
                htmlContent += `</div></div>`;
            }

            // Ajouter le script qui va g√©n√©rer les QR codes au chargement de la page d'impression
            htmlContent += `
                <script>
                    window.onload = () => {
                        for (let i = 1; i <= ${num}; i++) {
                            const results = ['1-0', 'DRAW', '0-1'];
                            results.forEach((result, idx) => {
                                const qrData = JSON.stringify({ type: 'result', table: i, result });
                                try {
                                    new QRCode(document.getElementById(\`qr-\${i}-\${idx}\`), {
                                        text: qrData,
                                        width: 128,
                                        height: 128,
                                        colorDark: "#333"
                                    });
                                } catch(e) { console.error(e); }
                            });
                        }
                        
                        // Lancer l'impression
                        setTimeout(() => window.print(), 500);
                    };
                <\/script>
            `;

            htmlContent += `</body></html>`;

            // Ouvrir dans une nouvelle fen√™tre
            const printWindow = window.open('', '_blank');
            printWindow.document.write(htmlContent);
            printWindow.document.close();
            showNotification(`${num} fiches g√©n√©r√©es`, 'success');
        }


        // --- 2. Logique de SCAN de QR Code ---

        async function startQRScanner() {
            // NOUVEAU: Cacher la modale d'accueil si on est en mode joueur
            if (isPlayerMode) {
                document.getElementById('playerHomeModal').style.display = 'none';
            }
            
            const modal = document.getElementById('qrScannerModal');
            modal.style.display = 'flex';
            
            const video = document.getElementById('qrVideo'); 
            
            try {
                qrStream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        facingMode: { ideal: "environment" },
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    }
                });

                video.srcObject = qrStream;
                await video.play();

                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');

                qrScanInterval = setInterval(() => {
                    if (video.readyState === video.HAVE_ENOUGH_DATA) {
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        context.drawImage(video, 0, 0, canvas.width, canvas.height);
                        
                        const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
                        const code = jsQR(imageData.data, imageData.width, imageData.height);
                        
                        if (code && code.data) {
                            clearInterval(qrScanInterval);
                            onScanSuccess(code.data);
                        }
                    }
                }, 300);

            } catch (err) {
                console.error('Erreur cam√©ra:', err);
                showNotification("Erreur cam√©ra. Autorisez l'acc√®s.", 'error');
                stopQRScanner();
            }
        }

        function stopQRScanner() {
            if (qrStream) {
                qrStream.getTracks().forEach(track => track.stop());
                qrStream = null;
            }
            if (qrScanInterval) {
                clearInterval(qrScanInterval);
                qrScanInterval = null;
            }
            document.getElementById('qrScannerModal').style.display = 'none';
            
            // NOUVEAU: R√©-afficher la modale d'accueil si on annule
            if (isPlayerMode && !qrStagedResult) { // Ne pas r√©-afficher si on va valider
                document.getElementById('playerHomeModal').style.display = 'flex';
            }
        }

        function onScanSuccess(data) {
            stopQRScanner();
            
            try {
                const parsed = JSON.parse(data);
                if (parsed.type === 'result' && parsed.table && parsed.result) {
                    
                    qrStagedResult = parsed;
                    const { board } = findBoard(parsed.table);
                    
                    // MODIFI√â: Logique d'affichage de la validation
                    const boardNum = parsed.table;
                    const resultStr = formatResult(parsed.result);
                    let whiteName = "N/A";
                    let blackName = "N/A";

                    // NOUVEAU: V√©rifier si le score est d√©j√† saisi (UNIQUEMENT en mode joueur)
                    if (board && (board.score.white !== '' || board.score.black !== '') && isPlayerMode) {
                        showNotification("Ce r√©sultat a d√©j√† √©t√© saisi.", "info");
                        cancelQRValidation(); // Annule et retourne √† l'accueil
                        return;
                    }

                    if (board && board.players) {
                        whiteName = getSimplePlayerName(board.players.white.name);
                        blackName = getSimplePlayerName(board.players.black.name);
                    } else if (board) {
                        whiteName = "(Table non appari√©e)";
                        blackName = "(Table non appari√©e)";
                    } else {
                        whiteName = "(√âchiquier non trouv√©)";
                        blackName = "(√âchiquier non trouv√©)";
                    }

                    document.getElementById('qrValidateBoard').textContent = boardNum;
                    document.getElementById('qrValidateWhite').textContent = whiteName;
                    document.getElementById('qrValidateBlack').textContent = blackName;
                    document.getElementById('qrValidateResult').textContent = resultStr;
                    
                    document.getElementById('qrValidationModal').style.display = 'flex';

                } else {
                    showNotification('QR Code invalide', 'error');
                    if(isPlayerMode) document.getElementById('playerHomeModal').style.display = 'flex';
                }
            } catch (e) {
                showNotification('QR Code illisible', 'error');
                if(isPlayerMode) document.getElementById('playerHomeModal').style.display = 'flex';
            }
        }

        function cancelQRValidation() {
            document.getElementById('qrValidationModal').style.display = 'none';
            qrStagedResult = null;
            // NOUVEAU: Retour √† l'accueil joueur
            if (isPlayerMode) {
                document.getElementById('playerHomeModal').style.display = 'flex';
            }
        }


        // --- 3. LA FONCTION DE CONNEXION PRINCIPALE ---
        function validateQRResult() {
            if (!qrStagedResult) return;
            
            const tableNum = qrStagedResult.table;
            const result = qrStagedResult.result;
            
            const { board, physicalTable } = findBoard(tableNum);
            
            if (!board) {
                showNotification(`√âchiquier ${tableNum} non trouv√© dans cette ronde.`, 'error');
                cancelQRValidation();
                return;
            }
            
            saveHistoryState();

            if (result === "1-0") {
                board.score.white = "1";
                board.score.black = "0";
            } else if (result === "0-1") {
                board.score.white = "0";
                board.score.black = "1";
            } else if (result === "DRAW") {
                board.score.white = "1/2";
                board.score.black = "1/2";
            }
            
            updateTableDisplay(physicalTable.id);
            updateStats();
            if (window.ChessRoomSave) window.ChessRoomSave.onResultSaved();

            showNotification(`Table ${tableNum} : ${formatResult(result)} enregistr√© !`, 'success');
            cancelQRValidation(); // Retourne √† l'accueil joueur
        }
        
        // --- NOUVELLES FONCTIONS MODE JOUEUR ---
        
        let arbiterPassword = null;
        let isPlayerMode = false;

        function showArbiterPasswordModal() {
            document.getElementById('arbiterPassInput').value = arbiterPassword || '';
            document.getElementById('arbiterPassModal').style.display = 'flex';
        }

        function setArbiterPassword() {
            const pass = document.getElementById('arbiterPassInput').value;
            if (pass.length > 0 && pass.length < 4) {
                alert("Le mot de passe doit faire au moins 4 caract√®res.");
                return;
            }
            arbiterPassword = pass.length > 0 ? pass : null;
            document.getElementById('arbiterPassModal').style.display = 'none';
            if (arbiterPassword) {
                showNotification("Mot de passe arbitre enregistr√©.", "success");
            } else {
                showNotification("Mot de passe arbitre d√©sactiv√©.", "info");
            }
            autoSaveToLocalStorage();
        }

        function showPlayerLoginModal() {
            if (!arbiterPassword) {
                alert("Aucun mot de passe arbitre n'a √©t√© d√©fini. Veuillez d'abord en cr√©er un.");
                return;
            }
            document.getElementById('playerPassInput').value = '';
            document.getElementById('playerLoginError').style.display = 'none';
            document.getElementById('playerLoginModal').style.display = 'flex';
        }

        function loginAsPlayer() {
            const pass = document.getElementById('playerPassInput').value;
            if (pass === arbiterPassword) {
                isPlayerMode = true;
                document.getElementById('playerLoginModal').style.display = 'none';
                document.getElementById('playerHomeModal').style.display = 'flex';
                // Verrouiller les outils
                setTool('pan'); // Mettre dans un mode "s√ªr"
                document.querySelector('.sidebar').style.display = 'none';
                document.querySelector('.toolbar').style.display = 'none';
                document.querySelector('.shortcut-bar').style.display = 'none';
                document.querySelector('.main-content').classList.add('sidebar-collapsed');
                fitAllTables(); // Centrer le plan pour le joueur
            } else {
                document.getElementById('playerLoginError').style.display = 'block';
            }
        }

        function performPlayerLogout() {
            isPlayerMode = false;
            document.getElementById('playerHomeModal').style.display = 'none';
            document.getElementById('playerLogoutConfirmModal').style.display = 'none';
            // D√©verrouiller les outils
            document.querySelector('.sidebar').style.display = 'flex';
            document.querySelector('.toolbar').style.display = 'flex';
            document.querySelector('.shortcut-bar').style.display = 'block';
            document.querySelector('.main-content').classList.remove('sidebar-collapsed');
            setTool('select');
        }

        function promptToLogoutPlayer() {
            document.getElementById('playerLogoutPassInput').value = '';
            document.getElementById('playerLogoutError').style.display = 'none';
            // MODIFI√â: S'assurer que la modale d'accueil est cach√©e
            document.getElementById('playerHomeModal').style.display = 'none';
            document.getElementById('playerLogoutConfirmModal').style.display = 'flex';
        }
        
        // NOUVEAU: Fermer la modale de d√©connexion et revenir
        function closePlayerLogoutConfirm() {
             document.getElementById('playerLogoutConfirmModal').style.display = 'none';
             document.getElementById('playerHomeModal').style.display = 'flex';
        }

        function attemptPlayerLogout() {
            const pass = document.getElementById('playerLogoutPassInput').value;
            if (pass === arbiterPassword) {
                performPlayerLogout();
            } else {
                document.getElementById('playerLogoutError').style.display = 'block';
            }
        }
        
        // --- NOUVEAU: Gestion Saisie sur Plan ---
        function showPlayerPlanView() {
            document.getElementById('playerHomeModal').style.display = 'none';
            document.body.classList.add('player-plan-view-mode');
            setTool('pan'); // Activer le mode 'pan' pour le d√©placement
            renderAllTables(); // NOUVEAU: Re-rendre pour cacher les tables termin√©es
            fitAllTables();
        }
        
        function returnToPlayerHome() {
            document.body.classList.remove('player-plan-view-mode');
            document.getElementById('playerHomeModal').style.display = 'flex';
            renderAllTables(); // Re-rendre pour afficher normalement
        }
        
        // --- NOUVEAU: Gestion Recherche Joueur (Texte) ---
        function showPlayerTextSearch() {
            document.getElementById('playerHomeModal').style.display = 'none';
            document.getElementById('playerSearchInput').value = '';
            populatePlayerSearchSuggestions(); // Pr√©-remplir
            document.getElementById('playerTextSearchModal').style.display = 'flex';
            document.getElementById('playerSearchInput').focus();
        }
        
        function closePlayerTextSearch() {
            document.getElementById('playerTextSearchModal').style.display = 'none';
            document.getElementById('playerHomeModal').style.display = 'flex';
        }

        function populatePlayerSearchSuggestions() {
            const input = document.getElementById('playerSearchInput');
            const suggestionsList = document.getElementById('player-search-suggestions');
            const searchTerm = input.value.toLowerCase();
            
            suggestionsList.innerHTML = '';
            const addedSuggestions = new Set();
            let matchingOptions = [];
            
            physicalTables.forEach(table => {
                table.boards.forEach(board => {
                    // NOUVEAU: Filtre
                    if (board.players && (board.score.white === '' && board.score.black === '')) {
                        const wName = getSimplePlayerName(board.players.white.name);
                        const bName = getSimplePlayerName(board.players.black.name);
                        
                        if (wName !== 'N/A' && !addedSuggestions.has(wName)) {
                            addedSuggestions.add(wName);
                            if (wName.toLowerCase().includes(searchTerm)) {
                                matchingOptions.push(wName);
                            }
                        }
                        if (bName !== 'N/A' && !addedSuggestions.has(bName)) {
                            addedSuggestions.add(bName);
                            if (bName.toLowerCase().includes(searchTerm)) {
                                matchingOptions.push(bName);
                            }
                        }
                    }
                });
            });
            
            // NOUVEAU: Logique d'auto-compl√©tion am√©lior√©e
            if (matchingOptions.length === 1 && searchTerm.length > 2 && matchingOptions[0].toLowerCase() !== searchTerm) {
                 input.value = matchingOptions[0]; // Auto-remplir
            } else {
                matchingOptions.forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    suggestionsList.appendChild(option);
                });
            }
        }
        
        function findPlayerFromTextSearch() {
            const name = document.getElementById('playerSearchInput').value;
            document.getElementById('playerSearchInput').value = ''; // NOUVEAU: Vider le champ
            if (!name || name.trim().length < 2) {
                alert("Veuillez entrer un nom valide.");
                return;
            }
            
            findPlayerByName(name.trim());
            document.getElementById('playerTextSearchModal').style.display = 'none';
        }
        
        // --- NOUVEAU: Gestion Recherche Joueur (Liste) ---
        function showPlayerListSearch() {
            document.getElementById('playerHomeModal').style.display = 'none';
            
            const select = document.getElementById('playerListSelect');
            select.innerHTML = '<option value="">-- S√©lectionnez votre nom --</option>';
            const playerList = [];

            physicalTables.forEach(table => {
                table.boards.forEach(board => {
                    // NOUVEAU: Filtre
                    if (board.players && (board.score.white === '' && board.score.black === '')) {
                        playerList.push({ name: getSimplePlayerName(board.players.white.name), board: board.boardNumber });
                        playerList.push({ name: getSimplePlayerName(board.players.black.name), board: board.boardNumber });
                    }
                });
            });
            
            // Trier la liste par nom
            playerList.sort((a, b) => a.name.localeCompare(b.name));
            
            const addedNames = new Set(); // √âviter doublons si un joueur a 2 parties (rare)
            playerList.forEach(p => {
                if (p.name !== "N/A" && !addedNames.has(p.name)) {
                    const option = document.createElement('option');
                    option.value = p.name; // On utilise le nom pour la recherche
                    option.textContent = `${p.name} (√âch. ${p.board})`;
                    select.appendChild(option);
                    addedNames.add(p.name);
                }
            });
            
            document.getElementById('playerListSearchModal').style.display = 'flex';
        }
        
        function closePlayerListSearch() {
            document.getElementById('playerListSearchModal').style.display = 'none';
            document.getElementById('playerHomeModal').style.display = 'flex';
        }

        function findPlayerFromListSearch() {
            const name = document.getElementById('playerListSelect').value;
            if (!name) {
                alert("Veuillez s√©lectionner votre nom.");
                return;
            }
            
            findPlayerByName(name);
            document.getElementById('playerListSearchModal').style.display = 'none';
        }
        
        // --- NOUVEAU: Logique de recherche commune ---
        function findPlayerByName(name) {
            const searchTerm = name.toLowerCase();
            let foundGame = null;

            for (const physicalTable of physicalTables) {
                for (const board of physicalTable.boards) {
                    // NOUVEAU: Filtre
                    if (board.players && (board.score.white === '' && board.score.black === '')) {
                        if ((board.players.white && getSimplePlayerName(board.players.white.name).toLowerCase() === searchTerm) || 
                            (board.players.black && getSimplePlayerName(board.players.black.name).toLowerCase() === searchTerm)) {
                            
                            foundGame = { board, physicalTable };
                            break;
                        }
                    }
                }
                if (foundGame) break;
            }

            if (foundGame) {
                showSimplifiedScoreModal(foundGame.board, foundGame.physicalTable);
            } else {
                alert(`Aucune partie non termin√©e trouv√©e pour "${name}" dans cette ronde.`);
                document.getElementById('playerHomeModal').style.display = 'flex'; // Retour accueil
            }
        }


        // Afficher la modale de saisie simplifi√©e
        function showSimplifiedScoreModal(board, physicalTable) {
            if (!board.players) return;
            
            const pWhite = getSimplePlayerName(board.players.white.name);
            const pBlack = getSimplePlayerName(board.players.black.name);
            const boardNum = board.boardNumber;

            document.getElementById('simplifiedBoardNum').textContent = boardNum;
            document.getElementById('simplifiedWhitePlayer').textContent = pWhite;
            document.getElementById('simplifiedBlackPlayer').textContent = pBlack;
            
            const btnWhite = document.getElementById('btnWinWhite');
            btnWhite.innerHTML = `<strong>1-0</strong><br>(${pWhite} gagne)`;
            btnWhite.onclick = () => saveSimplifiedScore(boardNum, '1-0');

            const btnDraw = document.getElementById('btnDraw');
            btnDraw.innerHTML = `<strong>¬Ω-¬Ω</strong><br>(Match Nul)`;
            btnDraw.onclick = () => saveSimplifiedScore(boardNum, '1/2-1/2');

            const btnBlack = document.getElementById('btnWinBlack');
            btnBlack.innerHTML = `<strong>0-1</strong><br>(${pBlack} gagne)`;
            btnBlack.onclick = () => saveSimplifiedScore(boardNum, '0-1');

            document.getElementById('simplifiedScoreModal').style.display = 'flex';
        }
        
        // NOUVEAU: Fermer la modale simplifi√©e et retourner
        function closeSimplifiedScoreModal() {
            document.getElementById('simplifiedScoreModal').style.display = 'none';
            // Si on √©tait en mode plan, on y reste. Sinon, on retourne √† l'accueil
            if (!document.body.classList.contains('player-plan-view-mode') && isPlayerMode) {
                document.getElementById('playerHomeModal').style.display = 'flex';
            }
        }

        // Enregistrer le score depuis la modale simplifi√©e
        function saveSimplifiedScore(boardNum, result) {
            const { board, physicalTable } = findBoard(boardNum);
            if (!board) return;

            saveHistoryState();
            
            if (result === "1-0") {
                board.score.white = "1";
                board.score.black = "0";
            } else if (result === "0-1") {
                board.score.white = "0";
                board.score.black = "1";
            } else if (result === "1/2-1/2") {
                board.score.white = "1/2";
                board.score.black = "1/2";
            }
            
            updateTableDisplay(physicalTable.id);
            updateStats();

            if (window.ChessRoomSave) window.ChessRoomSave.onResultSaved();
            
            // MODIFI√â: Logique de fermeture/retour
            document.getElementById('simplifiedScoreModal').style.display = 'none';
            showNotification(`R√©sultat ${result} enregistr√© pour l'√©chiquier ${boardNum} !`, 'success');
            
            // NOUVEAU: Retour automatique √† l'accueil
            if (isPlayerMode) {
                returnToPlayerHome();
            }
        }



        // --- Initialisation ---
            document.addEventListener('DOMContentLoaded', async () => {
                
                // NOUVEAU: Ouvrir le premier accord√©on par d√©faut (SUPPRIM√â)
                /*
                const firstAccordionHeader = document.querySelector('.sidebar-section h3');
                if (firstAccordionHeader) {
                    toggleAccordion(firstAccordionHeader);
                }
                */
                
                // Note: Le chargement des donn√©es est maintenant g√©r√© par chessroom-save-system.js
                // qui s'occupe de charger depuis le serveur ou le localStorage selon la configuration
                
                // Charger l'√©tat par d√©faut si aucune donn√©e n'est charg√©e
                if (Object.keys(roundsStore).length === 0 || !roundsStore['ronde1']) {
                    loadStateFromStore('ronde1');
                }

            document.getElementById('scoreModal').addEventListener('keydown', (e) => {
                if(e.key === 'Escape') {
                    hideScoreModal();
                }
                if(e.key === 'Enter') {
                    saveScoreFromModal();
                }
            });
            
            // NOUVEAU: √âcouteur pour la modale de recherche texte joueur
            document.getElementById('playerTextSearchModal').addEventListener('keydown', (e) => {
                if(e.key === 'Enter') {
                    findPlayerFromTextSearch();
                }
            });
            
            // NOUVEAU: √âcouteur pour la modale de recherche liste joueur
            document.getElementById('playerListSearchModal').addEventListener('keydown', (e) => {
                if(e.key === 'Enter') {
                    findPlayerFromListSearch();
                }
            });
            
            // NOUVEAU: √âcouteur pour la modale de login joueur
             document.getElementById('playerLoginModal').addEventListener('keydown', (e) => {
                if(e.key === 'Enter') {
                    loginAsPlayer();
                }
            });
            
            // NOUVEAU: √âcouteur pour la modale de logout joueur
             document.getElementById('playerLogoutConfirmModal').addEventListener('keydown', (e) => {
                if(e.key === 'Enter') {
                    attemptPlayerLogout();
                }
            });

            setTimeout(() => {
                // MODIFI√â: Vue par d√©faut
                fitAllTables();
            }, 500);
            
            // NOUVEAU: √âcouteur de synchronisation entre onglets
            window.addEventListener('storage', (e) => {
                if (e.key === SAVE_KEY && e.newValue) {
                    
                    if (isPlayerMode) return;
                    
                    if (document.querySelector('.modal-overlay[style*="display: flex"]') || document.getElementById('scoreModal').style.display === 'flex') {
                         console.log('Synchronisation en attente, modale ouverte.');
                         return;
                    }

                    console.log('Changement de sauvegarde d√©tect√©, rafra√Æchissement...');
                    try {
                        const data = JSON.parse(e.newValue);
                        if (data && data.roundsStore) {
                            roundsStore = data.roundsStore;
                            arbiterPassword = data.arbiterPassword || null;
                            
                            if (!roundsStore[currentRoundKey]) {
                                currentRoundKey = data.currentRoundKey || 'ronde1';
                            }
                            
                            loadStateFromStore(currentRoundKey);
                            updateRoundSelector();
                            
                            showNotification('Plan mis √† jour (synchro.)', 'info');
                        }
                    } catch (err) {
                        console.error('Erreur de synchronisation:', err);
                    }
                }
            });
        });
        
// ========================================
// SAUVEGARDE ET SYNCHRONISATION AUTOMATIQUE
// ========================================
// Note: Les intervalles de sauvegarde automatique sont maintenant g√©r√©s
// par chessroom-save-system.js qui configure les timers selon les options
// choisies par l'utilisateur (Mode Arbitre/Spectateur + cases √† cocher)

// --- NOUVELLES FONCTIONS DE GESTION DE TOURNOI ---

function deleteCurrentRound() {
    // 1. V√©rification de s√©curit√©
    const keys = Object.keys(roundsStore);
    if (keys.length <= 1) {
        alert("Impossible de supprimer la seule ronde existante. Pour recommencer √† z√©ro, utilisez le bouton 'Nouveau Tournoi'.");
        return;
    }

    // 2. Demander confirmation
    if (!confirm(`√ätes-vous s√ªr de vouloir supprimer D√âFINITIVEMENT la ${currentRoundKey.replace('r', 'R')} ?\n\n‚ö†Ô∏è IMPORTANT : Les rondes suivantes seront renum√©rot√©es (ex: la Ronde 3 deviendra la Ronde 2).`)) {
        return;
    }

    // 3. R√©cup√©rer toutes les cl√©s et les trier num√©riquement (pour √©viter l'ordre ronde1, ronde10, ronde2)
    const sortedKeys = keys.sort((a, b) => {
        const numA = parseInt(a.replace('ronde', ''));
        const numB = parseInt(b.replace('ronde', ''));
        return numA - numB;
    });

    // 4. Cr√©er une liste des donn√©es des rondes que l'on GARDE (on exclut la ronde actuelle)
    const remainingRoundsData = sortedKeys
        .filter(key => key !== currentRoundKey)
        .map(key => roundsStore[key]);

    // 5. Reconstruire le roundsStore proprement (ronde1, ronde2, ronde3...)
    // On vide l'ancien store et on le remplit avec les nouvelles cl√©s s√©quentielles
    roundsStore = {};
    
    remainingRoundsData.forEach((data, index) => {
        const newKey = `ronde${index + 1}`; // index 0 devient ronde1, index 1 devient ronde2, etc.
        roundsStore[newKey] = data;
    });

    // 6. Basculer vers la derni√®re ronde disponible (souvent celle qui vient d'√™tre renomm√©e)
    const newKeys = Object.keys(roundsStore);
    const lastKey = newKeys[newKeys.length - 1];
    
    // Charger la nouvelle vue
    loadStateFromStore(lastKey);
    updateRoundSelector();
    autoSaveToLocalStorage();
    
    showNotification("Ronde supprim√©e et num√©rotation r√©organis√©e.", "success");
}

function createNewTournament() {
    // On r√©utilise la logique existante de clearAll mais avec un message sp√©cifique
    // clearAll() contient d√©j√† un confirm(), mais pour √™tre s√ªr du message "Nouveau Tournoi":
    
    if (confirm("‚ö†Ô∏è ATTENTION : Vous allez cr√©er un NOUVEAU TOURNOI.\n\nToutes les donn√©es actuelles (toutes les rondes, joueurs, scores, configurations) seront effac√©es.\n\nVoulez-vous vraiment continuer ?")) {
        // On appelle la logique de nettoyage sans redemander confirmation (on bypass le confirm du clearAll en ex√©cutant son contenu directement ou en le modifiant l√©g√®rement, mais ici on va appeler la logique de reset manuellement pour √™tre propre).
        
        localStorage.removeItem(SAVE_KEY);
        localStorage.removeItem(SAVE_KEY_TIMESTAMP);

        // R√©initialisation des variables globales
        physicalTables = [];
        rooms = [];
        nextPhysicalTableId = 1;
        nextRoomId = 1;
        nextBoardNumber = 1;
        historyStack = [];
        redoStack = [];

        // R√©initialisation du store
        roundsStore = {};
        currentRoundKey = 'ronde1'; // On repart √† la ronde 1
        
        // Charger l'√©tat vide
        loadStateFromStore('ronde1');
        updateRoundSelector();

        document.getElementById('canvas').innerHTML = '';
        updateStats();
        
        showNotification("Nouveau tournoi cr√©√©.", "success");
    }
}
    </script>
    
    <script src="chessroom-save-system.js"></script>
</body>
</html>