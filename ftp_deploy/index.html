<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gestionnaire de Plan de Salles d'Échecs</title>

    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>

    <style>
        /* ... [La plupart du CSS est identique] ... */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            height: 100%;
        }



        /* ... [CSS Mode Player identique] ... */
        body.player-plan-view-mode .sidebar,
        body.player-plan-view-mode .toolbar,
        body.player-plan-view-mode .shortcut-bar,
        body.player-plan-view-mode .zoom-controls,
        body.player-plan-view-mode #sidebarToggle {
            display: none !important;
        }

        body.player-plan-view-mode #playerPlanReturnButton {
            display: block;
        }

        /* =====================================================
            NOUVEAU: Verrouillage complet du Mode Spectateur
        =====================================================
        */

        /* 1. Cache tous les boutons d'action DANS les sections (redondant mais sécurisé) */


        /* =====================================================
           SECTION INSCRIPTIONS (REGISTRATION)
        ===================================================== */
        #registrationOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #f8f9fa;
            z-index: 10005;
            /* Au-dessus de tout */
            display: none;
            overflow-y: auto;
            padding: 20px;
            font-family: 'Segoe UI', sans-serif;
            color: #1e293b;
        }

        #registrationOverlay.active {
            display: block;
        }

        .reg-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        .reg-badge {
            padding: 5px 10px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 0.9em;
        }

        .reg-badge-local {
            background: #e0e7ff;
            color: #4338ca;
        }

        .reg-badge-storage {
            background: #fef3c7;
            color: #b45309;
            font-size: 0.8em;
            margin-left: auto;
        }

        .reg-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .reg-card {
            background: white;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .reg-card-label {
            font-size: 0.9em;
            color: #64748b;
            margin-bottom: 5px;
        }

        .reg-card-value {
            font-size: 1.8em;
            font-weight: bold;
        }

        .reg-text-emerald {
            color: #059669;
        }

        .reg-text-amber {
            color: #d97706;
        }

        .reg-text-indigo {
            color: #4f46e5;
        }

        .reg-section {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            margin-bottom: 20px;
        }

        .reg-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: flex-end;
        }

        .reg-control-group {
            flex: 1;
            min-width: 150px;
        }

        .reg-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            margin-top: 5px;
            font-size: 0.95em;
        }

        .reg-btn {
            padding: 8px 16px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-weight: 500;
            transition: background 0.2s;
            font-size: 0.95em;
        }

        .reg-btn-primary {
            background: #4f46e5;
            color: white;
        }

        .reg-btn-primary:hover {
            background: #4338ca;
        }

        .reg-btn-success {
            background: #059669;
            color: white;
        }

        .reg-btn-success:hover {
            background: #047857;
        }

        .reg-btn-danger {
            background: #e11d48;
            color: white;
        }

        .reg-btn-danger:hover {
            background: #be123c;
        }

        .reg-btn-secondary {
            background: #f1f5f9;
            color: #334155;
        }

        .reg-btn-secondary:hover {
            background: #e2e8f0;
        }

        .reg-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.95em;
        }

        .reg-table th {
            text-align: left;
            padding: 10px;
            color: #475569;
            border-bottom: 1px solid #e2e8f0;
            cursor: pointer;
        }

        .reg-table th.sorted {
            color: #1e40af;
            font-weight: bold;
        }

        .reg-table td {
            padding: 10px;
            border-bottom: 1px solid #f1f5f9;
        }

        .reg-table tr.cancelled {
            opacity: 0.5;
            text-decoration: line-through;
        }

        .reg-status-badge {
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 0.85em;
        }

        .bg-emerald-100 {
            background: #d1fae5;
            color: #065f46;
        }

        .bg-rose-100 {
            background: #ffe4e6;
            color: #9f1239;
        }

        .bg-amber-100 {
            background: #fef3c7;
            color: #92400e;
        }

        .bg-indigo-100 {
            background: #e0e7ff;
            color: #3730a3;
        }

        .bg-slate-100 {
            background: #f1f5f9;
            color: #475569;
        }

        /* Spinner */
        .reg-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid currentColor;
            border-right-color: transparent;
            border-radius: 50%;
            display: inline-block;
            animation: spin 0.6s linear infinite;
        }

        /* FIDE Search Results Modal */
        #fideSearchModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10010;
            display: none;
            align-items: center;
            justify-content: center;
        }

        #fideSearchResults {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .fide-result-item {
            padding: 10px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
        }

        .fide-result-item:hover {
            background: #f8f9fa;
        }

        body.projector-mode {
            overflow: hidden;
        }

        body.projector-mode .sidebar,
        body.projector-mode .toolbar,
        body.projector-mode .shortcut-bar,
        body.projector-mode #sidebarToggle,
        body.projector-mode #saveStatus {
            display: none !important;
        }

        body.projector-mode .container {
            height: 100vh;
            max-width: 100vw;
            margin: 0;
            border-radius: 0;
            box-shadow: none;
            padding: 0;
        }

        body.projector-mode .main-content {
            height: 100vh;
        }

        body.projector-mode .canvas-container {
            background: white;
            /* Fond blanc propre */
        }

        /* Bouton Retour Projecteur */
        #projectorReturnBtn {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 10002;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #ccc;
            padding: 5px 10px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.85em;
            display: none;
            transition: background 0.3s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        body.projector-mode #projectorReturnBtn {
            display: block;
        }

        /* --- DARK MODE --- */
        body.dark-mode {
            background-color: #1a1a1a;
            color: #e0e0e0;
        }

        body.dark-mode .sidebar {
            background-color: #2d2d2d;
            border-right-color: #404040;
        }

        body.dark-mode .sidebar-header {
            border-bottom-color: #404040;
        }

        body.dark-mode .sidebar-section-title {
            color: #a0a0a0;
        }

        body.dark-mode .control-group label {
            color: #c0c0c0;
        }

        body.dark-mode input[type="text"],
        body.dark-mode input[type="number"],
        body.dark-mode select {
            background-color: #333;
            color: #fff;
            border-color: #555;
        }

        body.dark-mode .chess-table {
            background-color: #2d2d2d;
            border-color: #404040;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        }

        body.dark-mode .table-header {
            background-color: #333;
            border-bottom-color: #404040;
        }

        body.dark-mode .player-name {
            color: #e0e0e0;
        }

        body.dark-mode .vs {
            color: #888;
        }

        body.dark-mode .modal-content {
            background-color: #2d2d2d;
            color: #e0e0e0;
        }

        body.dark-mode .close {
            color: #aaa;
        }

        body.dark-mode .filter-btn {
            background: #333;
            border-color: #555;
            color: #ddd;
        }

        body.dark-mode .filter-btn.active {
            background: #0056b3;
        }

        /* --- HEARTBEAT --- */
        .grid-tooltip {
            position: fixed;
            background: white;
            color: #333;
            border: 1px solid #ccc;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            padding: 0;
            border-radius: 4px;
            pointer-events: none;
            display: none;
            z-index: 10030;
            font-size: 0.85em;
            max-width: 500px;
        }

        .tooltip-header {
            background: #2c3e50;
            color: white;
            padding: 8px;
            font-weight: bold;
            border-radius: 4px 4px 0 0;
            display: flex;
            justify-content: space-between;
        }

        .tooltip-table {
            width: 100%;
            border-collapse: collapse;
        }

        .tooltip-table th,
        .tooltip-table td {
            padding: 4px 8px;
            border: 1px solid #eee;
            text-align: center;
        }

        .tooltip-table th {
            background: #f8f9fa;
            font-weight: 600;
        }

        .grid-cell-win {
            background-color: #d1fae5;
            color: #065f46;
        }

        .grid-cell-loss {
            background-color: #ffe4e6;
            color: #9f1239;
        }

        .grid-cell-draw {
            background-color: #e0e7ff;
            color: #3730a3;
        }

        /* Bracket Styles */
        .bracket-round {
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            margin: 0 20px;
        }

        .bracket-match {
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
            width: 200px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .bracket-player {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
        }

        .bracket-player.winner {
            font-weight: bold;
            color: #2e7d32;
        }

        #connectionStatus {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #ccc;
            /* Unknown */
            z-index: 10000;
            border: 2px solid #fff;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
            transition: background-color 0.3s;
        }

        #connectionStatus.online {
            background-color: #2ecc71;
        }

        #connectionStatus.offline {
            background-color: #e74c3c;
        }

        #connectionStatus.checking {
            background-color: #f1c40f;
        }

        /* --- FILTERS --- */
        .filter-buttons {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .filter-btn {
            padding: 4px 8px;
            font-size: 12px;
            border: 1px solid #ccc;
            background: #f0f0f0;
            cursor: pointer;
            border-radius: 4px;
        }

        .filter-btn.active {
            background: #007bff;
            color: white;
            border-color: #0056b3;
        }

        .table-element.hidden-by-filter {
            display: none !important;
        }

        #projectorReturnBtn:hover {
            background: rgba(0, 0, 0, 0.8);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            width: 100vw;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-size: 14px;
        }

        /* ... [CSS Mode Player identique] ... */
        body.player-plan-view-mode .sidebar,
        body.player-plan-view-mode .toolbar,
        body.player-plan-view-mode .shortcut-bar,
        body.player-plan-view-mode .zoom-controls,
        body.player-plan-view-mode #sidebarToggle {
            display: none !important;
        }

        body.player-plan-view-mode #playerPlanReturnButton {
            display: block;
        }

        /* =====================================================
            NOUVEAU: Verrouillage complet du Mode Spectateur
        =====================================================
        */

        /* 1. Cache tous les boutons d'action DANS les sections */
        .spectator-mode .sidebar-content button,
        .spectator-mode .sidebar-content input[type="file"],
        .spectator-mode .sidebar-content label.file-upload-label,
        .spectator-mode button[onclick="showArbiterPasswordModal()"],
        .spectator-mode button[onclick="showPlayerLoginModal()"] {
            display: none !important;
        }

        /* 2. Cache les boutons de la barre d'outils (sauf Outils de navigation) */
        .spectator-mode .timer-controls,
        .spectator-mode .tool-btn[onclick*="delete"],
        .spectator-mode .tool-btn[onclick*="duplicate"],
        .spectator-mode .tool-btn[onclick*="rotate"],
        .spectator-mode .tool-btn[onclick*="flip"],
        .spectator-mode .tool-btn[onclick*="undo"],
        .spectator-mode .tool-btn[onclick*="redo"],
        .spectator-mode .btn-success[onclick*="startQRScanner"] {
            display: none !important;
        }

        /* 3. Désactive les interactions sur le plan */
        .spectator-mode .table-element,
        .spectator-mode .room-element,
        .spectator-mode .board-container {
            cursor: default !important;
            pointer-events: none !important;
        }

        /* 4. Cache les poignées de modification */
        .spectator-mode .delete-btn,
        .spectator-mode .rotate-btn,
        .spectator-mode .resize-handle,
        .spectator-mode .flip-btn-single,
        .spectator-mode .arbiter-flag,
        .spectator-mode .room-delete-btn,
        .spectator-mode .room-resize-handle {
            display: none !important;
        }

        /* 5. Cache TOUTES les sections de la sidebar */
        .spectator-mode .sidebar-section {
            display: none !important;
        }

        .spectator-mode #liveFollowSection {
            display: block !important;
        }

        /* 6. Ré-affiche UNIQUEMENT les sections autorisées */
        .spectator-mode .sidebar-section:first-child,
        .spectator-mode #saveControlsSection,
        .spectator-mode #playersSection {
            display: block !important;
        }

        /* 7. Cache la barre de raccourcis */
        .spectator-mode .shortcut-bar {
            display: none !important;
        }

        /* =========================================================
           CORRECTION : Forcer l'affichage du Suivi en Spectateur
        ========================================================= */

        /* Rendre visibles les boutons et le menu déroulant UNIQUEMENT dans la section Suivi */
        .spectator-mode #liveFollowSection button,
        .spectator-mode #liveFollowSection select {
            display: block !important;
        }

        /* S'assurer que le conteneur de suivi reste visible */
        .spectator-mode #liveFollowSection {
            display: block !important;
        }

        .container {
            width: 100%;
            height: 100%;
            margin: 0;
            background: white;
            border-radius: 0;
            box-shadow: none;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .main-content {
            display: flex;
            flex-direction: row !important;
            flex: 1;
            overflow: hidden;
            position: relative;
            width: 100%;
        }

        .sidebar {
            width: 300px;
            background-color: #f8f9fa;
            border-right: 1px solid #dee2e6;
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease;
            z-index: 1000;
            overflow-y: auto;
        }

        .main-content.sidebar-collapsed .sidebar {
            width: 0 !important;
            padding: 0;
            border-right: none;
            overflow: hidden;
        }

        #sidebarToggle {
            position: absolute;
            top: 10px;
            left: 300px;
            /* Largeur sidebar */
            z-index: 1001;
            transition: left 0.3s ease;
            border-radius: 0 4px 4px 0;
            padding: 5px 10px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-left: none;
            cursor: pointer;
            width: auto;
            max-width: 40px;
            min-width: 30px;
            font-size: 14px;
            color: #000;
        }

        .main-content.sidebar-collapsed #sidebarToggle {
            left: 0;
        }

        .main-content.sidebar-collapsed #sidebarToggle {
            left: 0px;
            border-radius: 0 50% 50% 0;
            transform: translateX(0);
        }

        /*
        =====================================================
            NOUVEAU SYSTÈME ACCORDÉON
        =====================================================
        */
        .sidebar-section {
            /* MODIFIÉ: Plus de padding/margin, géré par le contenu */
            margin-bottom: 0;
            border-bottom: 2px solid #e9ecef;
            /* min-width: 270px; */
            /* MODIFIÉ: Supprimé ou commenté */
        }

        .sidebar-section:last-child {
            border-bottom: none;
            /* NOUVEAU: Permet à la dernière section de remplir l'espace */
            flex: 1;
            display: flex;
            flex-direction: column;
            /* CORRECTION: Ajouté pour forcer la contrainte de hauteur */
            min-height: 0;
        }

        .sidebar-section h3 {
            color: #2c3e50;
            font-size: 1.05em;
            display: flex;
            align-items: center;
            gap: 8px;
            /* NOUVEAU: Cliquable */
            padding: 15px;
            margin-bottom: 0;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .sidebar-section h3:hover {
            background-color: #e9ecef;
        }

        .sidebar-section h3.active {
            background-color: #667eea;
            color: white;
        }

        /* NOUVEAU: Conteneur du contenu de l'accordéon */
        .sidebar-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
            padding: 0 15px;
            /* Padding latéral */
            background: #ffffff;
        }

        .sidebar-content.expanded {
            /* NOUVEAU: Hauteur pour le contenu */
            max-height: 70vh;
            /* Hauteur max pour le contenu */
            overflow-y: auto;
            /* Scroll si besoin DANS la section */
            padding: 15px;
            /* Padding complet */
        }

        .sidebar-section:last-child .sidebar-content.expanded {
            /* NOUVEAU: Permet au dernier de s'étendre */
            max-height: none;
            flex: 1;
        }

        /* Fin NOUVEAU SYSTÈME ACCORDÉON */


        .control-group {
            margin-bottom: 12px;
        }

        /* ... [Reste du CSS identique] ... */

        .control-group label {
            display: block;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 4px;
            font-size: 0.9em;
        }

        input[type="number"],
        input[type="text"],
        input[type="file"],
        select,
        input[type="password"] {
            width: 100%;
            padding: 6px 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 0.95em;
            transition: border-color 0.3s;
            background: white;
        }

        .toolbar input[type="number"] {
            width: 60px;
            padding: 4px 8px;
            font-size: 0.9em;
            text-align: center;
        }

        input:focus,
        select:focus {
            outline: none;
            border-color: #667eea;
        }

        button {
            width: 100%;
            padding: 8px 12px;
            font-size: 0.9em;
            font-weight: 600;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 6px;
        }

        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-primary,
        .btn-success,
        .btn-danger,
        .btn-secondary,
        .btn-info {
            color: white;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .btn-success {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        }

        .btn-danger {
            background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #6c757d 0%, #5a6268 100%);
        }

        .btn-info {
            background: linear-gradient(135deg, #17a2b8 0%, #138496 100%);
        }

        .btn-small {
            width: auto;
            padding: 4px 8px;
            font-size: 0.85em;
            margin-left: 5px;
        }

        .stats {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
        }

        .stat-item {
            background: white;
            padding: 8px;
            border-radius: 6px;
            border: 2px solid #e9ecef;
        }

        .stat-label {
            color: #6c757d;
            font-size: 0.85em;
            font-weight: 600;
        }

        .stat-value {
            color: #2c3e50;
            font-weight: 700;
            font-size: 1.3em;
        }

        .workspace {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #ecf0f1;
            position: relative;
            overflow: hidden;
            height: 100%;
        }

        .toolbar {
            background: white;
            padding: 4px 10px;
            /* MODIFIÉ: 10px est devenu 6px */
            border-bottom: 2px solid #e9ecef;
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        .toolbar button {
            width: auto;
            padding: 3px 6px;
            font-size: 0.8em;
            margin: 0;
        }

        .timer-controls {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-left: 15px;
            padding-left: 15px;
            border-left: 2px solid #e9ecef;
        }

        #roundTimer {
            font-size: 1.1em;
            /* MODIFIÉ: 1.3em est devenu 1.1em */
            font-weight: 700;
            color: #2c3e50;
            background: #f8f9fa;
            padding: 3px 6px;
            /* MODIFIÉ: 4px 10px est devenu 3px 8px */
            border-radius: 6px;
            min-width: 70px;
            text-align: center;
        }

        #roundTimer.timer-countdown {
            color: #1565c0;
        }

        #roundTimer.timer-elapsed {
            color: #c62828;
        }

        #roundTimer.timer-flash {
            animation: flash 1s infinite;
        }

        @keyframes flash {

            0%,
            100% {
                background-color: #69f0ae;
            }

            50% {
                background-color: #f8f9fa;
            }
        }

        .tool-btn {
            background: #e9ecef;
            color: #2c3e50;
        }

        .toolbar .tool-btn[onclick="undo()"],
        .toolbar .tool-btn[onclick="redo()"] {
            font-size: 1.1em;
            padding: 6px 8px;
        }

        .tool-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            overflow: auto;
            width: 100%;
            height: 100%;
            background:
                linear-gradient(90deg, #ddd 1px, transparent 1px),
                linear-gradient(#ddd 1px, transparent 1px);
            background-size: 50px 50px;
        }

        .canvas {
            position: relative;
            width: 3000px;
            height: 2000px;
            cursor: default;
            transform-origin: 0 0;
        }

        .canvas.move-mode {
            cursor: grab;
        }

        .canvas.move-mode:active {
            cursor: grabbing;
        }

        .table-element {
            position: absolute;
            background: white;
            border: 3px solid #2c3e50;
            border-radius: 8px;
            padding: 8px;
            cursor: move;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            transition: box-shadow 0.3s, transform 0.3s;
            min-width: 150px;
            user-select: none;
            transform-origin: top left;
            z-index: 10;
        }

        .table-element:hover {
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
            z-index: 100;
        }

        .table-element.selected {
            border-color: #667eea;
            box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.5);
            z-index: 101;
        }

        .table-element.has-pairing {
            background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
            border-color: #4caf50;
        }

        /* STYLE SURBRILLANCE JOUEUR (JAUNE PERMANENT) */
        .table-element.highlight-player {
            background-color: #fff176 !important;
            /* Jaune vif fond */
            border: 4px solid #ff6f00 !important;
            /* Bordure Orange/Rouge */
            box-shadow: 0 0 20px rgba(255, 111, 0, 0.6) !important;
            /* Halo lumineux */
            z-index: 9999 !important;
            /* Toujours au-dessus des autres */
            transform: scale(1.05);
            /* Légèrement grossi */
            transition: all 0.3s ease;
        }

        /* En mode sombre, on adapte pour que ça ne pique pas les yeux */
        body.dark-mode .table-element.highlight-player {
            background-color: #fdd835 !important;
            border-color: #ff6f00 !important;
            color: #000 !important;
            /* Force le texte en noir pour lisibilité */
        }

        body.dark-mode .table-element.highlight-player .player-name {
            color: #000 !important;
        }

        @keyframes pulse-highlight {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }
        }

        .table-content {
            transform-origin: center center;
        }

        .table-element.rotate-0 {
            transform: rotate(0deg);
        }

        .table-element.rotate-90 {
            transform: rotate(90deg);
        }

        .table-element.rotate-180 {
            transform: rotate(180deg);
        }

        .table-element.rotate-270 {
            transform: rotate(270deg);
        }

        .board-container {
            position: relative;
            padding: 4px;
            flex: 1;
            border-right: 1px solid #ddd;
            border-bottom: none;
            min-width: 140px;
            transition: background-color 0.3s, border-color 0.3s;
        }

        .board-container:last-child {
            border-right: none;
            border-bottom: none;
        }

        .board-container.board-scored {
            background-color: #ffebee;
            border-color: #c62828;
        }

        .canvas.moveboard-mode .board-container {
            cursor: grab;
        }

        .canvas.moveboard-mode .board-container:active {
            cursor: grabbing;
        }

        .canvas.moveboard-mode .board-container.over {
            background-color: rgba(102, 126, 234, 0.2);
        }

        body.player-plan-view-mode .board-container.has-players {
            cursor: pointer;
        }

        body.player-plan-view-mode .board-container.has-players:hover {
            background-color: rgba(102, 126, 234, 0.2);
        }


        .board-number {
            font-size: 1.4em;
            font-weight: 700;
            color: #667eea;
            margin-bottom: 5px;
            text-align: center;
        }

        .table-element.has-pairing .board-number {
            color: #2e7d32;
        }

        .table-content-inner {
            display: flex;
            width: 100%;
        }

        .player-comment {
            font-size: 0.9em;
            font-style: italic;
            color: #b71c1c;
            padding: 2px 4px;
            background: #fff9c4;
            border-radius: 3px;
            text-align: center;
            margin-bottom: 3px;
            white-space: normal;
            word-wrap: break-word;
        }

        .player {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 6px;
            font-size: 0.85em;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 5px;
            margin-top: 5px;
            overflow: hidden;
            min-height: 40px;
        }

        .player-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid #2c3e50;
            flex-shrink: 0;
        }

        .player-color.white {
            background: white;
        }

        .player-color.black {
            background: #2c3e50;
        }

        .player-info {
            flex: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
        }

        .player-name {
            font-weight: 400;
            color: #2c3e50;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.2;
            cursor: pointer;
        }

        .player-name:hover {
            color: #667eea;
        }

        .player-name .lastname {
            font-weight: 700;
            text-transform: uppercase;
        }

        .player-elo {
            font-size: 0.9em;
            color: #6c757d;
            white-space: nowrap;
        }

        .player-score {
            font-weight: 700;
            font-size: 1.1em;
            padding: 4px 8px;
            cursor: pointer;
            border-radius: 4px;
            margin-left: auto;
            flex-shrink: 0;
        }

        .player-score:hover {
            background: #e0e0e0;
        }

        .table-element.expanded .player-name {
            white-space: normal;
            overflow: visible;
            text-overflow: clip;
        }

        .delete-btn,
        .rotate-btn {
            position: absolute;
            width: 24px;
            height: 24px;
            color: white;
            border: 2px solid white;
            border-radius: 50%;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            z-index: 5;
        }

        .delete-btn {
            background: #f44336;
            top: -10px;
            right: -10px;
        }

        .rotate-btn {
            background: #2196f3;
            bottom: -10px;
            right: -10px;
            font-size: 12px;
        }

        .arbiter-flag {
            position: absolute;
            width: 24px;
            height: 24px;
            color: #424242;
            border: 2px solid white;
            background: #eeeeee;
            border-radius: 50%;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            z-index: 5;
            top: -10px;
            left: -10px;
        }

        .arbiter-flag.flag-red {
            background: #f44336;
            color: white;
        }

        .arbiter-flag.flag-yellow {
            background: #ffeb3b;
            color: #424242;
        }

        .arbiter-flag.flag-green {
            background: #4caf50;
            color: white;
        }

        .arbiter-flag.flag-none {
            display: none;
        }

        .table-element.selected .arbiter-flag {
            display: flex;
        }

        .table-element .arbiter-flag:not(.flag-none) {
            display: flex;
        }

        .table-element.selected .delete-btn,
        .table-element.selected .rotate-btn {
            display: flex;
        }

        .flip-btn-single {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 20px;
            height: 20px;
            background: #ff9800;
            color: white;
            border: 1px solid white;
            border-radius: 50%;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            padding: 0;
            margin: 0;
            z-index: 5;
        }

        .table-element.selected .flip-btn-single {
            display: flex;
        }

        .flip-btn-single:hover {
            background: #f57c00;
        }

        .resize-handle {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 24px;
            height: 30px;
            background: #2196f3;
            color: white;
            border: 2px solid white;
            border-radius: 5px;
            cursor: ew-resize;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            z-index: 102;
        }

        .resize-handle.handle-left {
            left: -12px;
        }

        .resize-handle.handle-right {
            right: -12px;
        }

        .table-element.rotate-90 .resize-handle,
        .table-element.rotate-270 .resize-handle {
            cursor: ns-resize;
        }

        .table-element.selected .resize-handle {
            display: flex;
        }

        .selection-box {
            position: absolute;
            border: 2px dashed #667eea;
            background: rgba(102, 126, 234, 0.1);
            pointer-events: none;
            z-index: 9999;
        }

        .zoom-controls {
            position: absolute;
            bottom: 35px;
            right: 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            padding: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 1000;
        }

        .zoom-btn {
            width: 32px;
            height: 32px;
            padding: 0;
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1em;
            flex-shrink: 0;
        }

        .zoom-slider {
            width: 120px;
            margin: 0 5px;
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: #ddd;
            outline: none;
            border-radius: 5px;
        }

        .zoom-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #667eea;
            cursor: pointer;
            border-radius: 50%;
        }

        .zoom-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #667eea;
            cursor: pointer;
            border-radius: 50%;
        }

        .file-upload-label {
            width: 100%;
            padding: 8px 14px;
            font-size: 0.9em;
            font-weight: 600;
            border-radius: 6px;
            cursor: pointer;
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
            display: block;
            text-align: center;
            margin-bottom: 6px;
        }

        input[type="file"] {
            display: none;
        }

        #ghost {
            background: white;
            border: 2px dashed #667eea;
            padding: 10px;
            border-radius: 8px;
            pointer-events: none;
        }

        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            font-weight: bold;
            z-index: 9999;
            flex-direction: column;
            gap: 20px;
        }

        #loadingOverlay::before {
            content: '⏳';
            font-size: 3em;
            animation: spin 1.5s linear infinite;
        }

        @keyframes spin {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        /* Modale de Score */
        #scoreModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: none;
            align-items: center;
            justify-content: center;
            /* MODIFICATION Z-INDEX */
            z-index: 10002;
        }

        #scoreModalContent {
            background: white;
            padding: 20px 25px;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            width: 300px;
        }

        #scoreModalContent h4 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        #scoreModalContent p {
            font-size: 0.95em;
            margin-bottom: 10px;
        }

        #scoreModalSelect {
            width: 100%;
            font-size: 1.1em;
            padding: 8px 10px;
            margin-bottom: 20px;
        }

        .score-modal-buttons {
            display: flex;
            gap: 10px;
        }

        .score-modal-buttons button {
            margin-bottom: 0;
        }

        /* Barre d'aide Raccourcis */
        .shortcut-bar {
            background: #4a4a4a;
            color: #f0f0f0;
            padding: 4px 15px;
            font-size: 0.8em;
            text-align: center;
            z-index: 1000;
            position: absolute;
            bottom: 0;
            width: 100%;
            border-top: 1px solid #666;
        }

        .shortcut-bar span {
            margin-left: 50px;
            margin-right: 5px;
            color: #fafafa;
            background: #616161;
            padding: 2px 5px;
            border-radius: 4px;
        }

        /*
        =====================================================
            STYLES CSS QR AJOUTÉS
        =====================================================
        */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: none;
            align-items: center;
            justify-content: center;
            /* MODIFICATION Z-INDEX */
            z-index: 10002;
            /* Mettre au-dessus de playerHomeModal */
        }

        /* CORRECTION: Le scanner QR doit être au-dessus de l'overlay d'inscription (10005) */
        #qrScannerModal {
            z-index: 10020 !important;
        }

        .modal-content {
            background: white;
            padding: 20px 25px;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            width: 90%;
            max-width: 500px;
        }

        .modal-content h2,
        .modal-content h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            text-align: center;
        }

        /* Styles pour la notification */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 16px 24px;
            border-radius: 10px;
            color: white;
            font-weight: 600;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            /* MODIFICATION Z-INDEX */
            z-index: 10003;
            /* Au-dessus de tout */
            opacity: 0;
            transform: translateX(400px);
            transition: all 0.3s;
        }

        .notification.show {
            opacity: 1;
            transform: translateX(0);
        }

        .notification.success {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        }

        .notification.error {
            background: linear-gradient(135deg, #ee0979 0%, #ff6a00 100%);
        }

        .notification.info {
            background: linear-gradient(135deg, #17a2b8 0%, #138496 100%);
        }

        .info-box {
            background: #e7f3ff;
            border-left: 4px solid #2196F3;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }

        /*
        =====================================================
            STYLES CSS SALLES / MURS (MODIFIÉS)
        =====================================================
        */
        .room-element {
            position: absolute;
            background: rgba(102, 126, 234, 0.05);
            border: 3px dashed #667eea;
            border-radius: 10px;
            min-width: 200px;
            min-height: 200px;
            cursor: move;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            user-select: none;
            padding-top: 30px;
            z-index: 1;
        }

        .room-element.selected {
            border-style: solid;
            border-color: #764ba2;
            background: rgba(102, 126, 234, 0.1);
            z-index: 5;
        }

        .room-title {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            background: #667eea;
            color: white;
            padding: 4px 10px;
            font-weight: 600;
            font-size: 0.9em;
            border-radius: 8px 8px 0 0;
            text-align: center;
            cursor: pointer;
        }

        .room-delete-btn {
            position: absolute;
            width: 24px;
            height: 24px;
            color: white;
            border: 2px solid white;
            border-radius: 50%;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            z-index: 6;
            background: #f44336;
            top: -10px;
            right: -10px;
        }

        .room-element.selected .room-delete-btn {
            display: flex;
        }

        .room-resize-handle {
            position: absolute;
            width: 15px;
            height: 15px;
            background: #667eea;
            border: 2px solid white;
            border-radius: 50%;
            z-index: 6;
        }

        .room-resize-handle.br {
            bottom: -8px;
            right: -8px;
            cursor: se-resize;
        }

        .room-resize-handle.bl {
            bottom: -8px;
            left: -8px;
            cursor: sw-resize;
        }

        .room-resize-handle.tr {
            top: -8px;
            right: -8px;
            cursor: ne-resize;
        }

        .room-resize-handle.tl {
            top: -8px;
            left: -8px;
            cursor: nw-resize;
        }

        .room-element:not(.selected) .room-resize-handle {
            display: none;
        }

        #playerPlanReturnButton {
            position: fixed;
            /* MODIFIÉ: en bas au centre et plus petit */
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10002;
            /* MODIFIÉ: padding et font-size */
            padding: 8px 16px;
            font-size: 0.9em;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
            display: none;
            /* Caché par défaut */
            width: auto;
            /* NOUVEAU */
            margin-bottom: 0;
            /* NOUVEAU */
        }

        body.player-plan-view-mode .sidebar,
        body.player-plan-view-mode .toolbar,
        body.player-plan-view-mode .shortcut-bar,
        body.player-plan-view-mode .zoom-controls,
        body.player-plan-view-mode #sidebarToggle {
            display: none !important;
        }

        body.player-plan-view-mode #playerPlanReturnButton {
            display: block;
        }

        /* NOUVEAU: Réduire la taille des boutons dans la sidebar */
        .sidebar-content button {
            font-size: 0.8em;
            /* Plus petit pour s'adapter à 200px */
            padding: 6px 8px;
            /* Ajuster le padding */
        }

        /* NOUVEAU: Styles pour le décompte plein écran */
        #bigTimerOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;

            /* Caché par défaut */
            display: none;

            /* Centrage */
            align-items: center;
            justify-content: center;

            /* Au-dessus du plan, mais sous les modales */
            z-index: 10000;

            /* TRÈS IMPORTANT: Laisse passer les clics ! */
            pointer-events: none;
        }

        #bigTimerDisplay {
            font-size: 15vw;
            /* Taille énorme qui s'adapte à l'écran */
            font-weight: bold;
            color: white;

            /* Ombre pour la lisibilité sur tous les fonds */
            text-shadow: 0 0 25px rgba(0, 0, 0, 0.8), 0 0 10px rgba(0, 0, 0, 0.5);
        }

        /* AJOUT: Cacher les sélecteurs d'outils en mode spectateur */
        .spectator-mode #selectTool,
        .spectator-mode #multiselectTool,
        .spectator-mode #panTool,
        .spectator-mode #moveboardTool {
            display: none !important;
        }

        /* AJOUT: Cacher les "..." des scores non saisis en mode spectateur */
        .spectator-mode .board-container:not(.board-scored) .player-score {
            visibility: hidden;
            /* On cache juste le texte, pas l'espace */
        }

        /* NOUVEAU: Styles pour l'interrupteur (toggle switch) */
        .switch-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-top: 12px;
            margin-bottom: 6px;
            /* Maintient l'espacement */
        }

        .switch-container span {
            font-weight: bold;
            color: #2c3e50;
            font-size: 0.9em;
            /* Correspond à .control-group label */
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 54px;
            /* Taille réduite */
            height: 28px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 28px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked+.slider {
            background-color: #667eea;
            /* Couleur Arbitre */
        }

        input:checked+.slider:before {
            transform: translateX(26px);
        }

        /* --- DARK MODE IMPROVEMENTS --- */
        body.dark-mode {
            background-color: #2a2a2a;
            color: #e0e0e0;
        }

        /* Fix Plan Background */
        body.dark-mode .canvas-container,
        body.dark-mode #canvasContainer {
            background-color: #2a2a2a !important;
            /* Dark background for the plan */
        }

        /* Fix Sidebar Background */
        body.dark-mode .sidebar {
            background-color: #333333;
            border-right-color: #555555;
        }

        /* Fix Sidebar Section Titles */
        body.dark-mode .sidebar-section h3 {
            color: #ffffff !important;
            /* Bright white for section titles */
            font-weight: 600;
        }

        /* Fix Text Contrast for Player Names */
        body.dark-mode .player-name {
            color: #1a1a1a !important;
            /* Dark text on light tables */
            font-weight: 600;
        }

        body.dark-mode .player-elo {
            color: #333333 !important;
            /* Dark grey for ELO */
        }

        body.dark-mode .sidebar-section-title {
            color: #ffffff;
        }

        /* Fix Table Color (Light Beige/Cream) */
        body.dark-mode .table-element {
            background-color: #d4c5b0 !important;
            /* Light beige for better contrast */
            border-color: #8d7a5f;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.6);
        }

        body.dark-mode .board-container {
            background-color: #d4c5b0 !important;
        }

        body.dark-mode .table-header {
            background-color: #8d7a5f !important;
            /* Darker brown header */
            border-bottom-color: #6d5a3f;
            color: #ffffff;
        }

        body.dark-mode .board-number {
            color: #1a1a1a !important;
            /* Dark board numbers */
        }

        /* Fix Inputs */
        body.dark-mode input,
        body.dark-mode select,
        body.dark-mode textarea {
            background-color: #424242;
            color: #fff;
            border: 1px solid #616161;
        }

        /* Fix Modals */
        body.dark-mode .modal-content {
            background-color: #333;
            color: #fff;
            border: 1px solid #555;
        }

        body.dark-mode .close {
            color: #fff;
        }

        /* Fix Stats */
        body.dark-mode .stat-item {
            background-color: #424242;
            border-color: #555;
        }

        body.dark-mode .stat-label {
            color: #bbb;
        }

        body.dark-mode .stat-value {
            color: #fff;
        }

        /* NUCLEAR RESET */
        html,
        body {
            height: 100% !important;
            width: 100% !important;
            margin: 0 !important;
            padding: 0 !important;
            overflow: hidden !important;
        }

        .container {
            height: 100% !important;
            width: 100% !important;
            margin: 0 !important;
            padding: 0 !important;
        }

        /* =====================================================
        CORRECTION : Mode Sombre pour les tables terminées
        ===================================================== */
        body.dark-mode .board-container.board-scored {
            background-color: #4a1a1a !important;
            /* Rouge foncé pour le fond */
            border-color: #ff5252 !important;
            /* Rouge vif pour la bordure */
        }

        body.dark-mode .board-container.board-scored .player-name {
            color: #ffdcdc !important;
            /* Texte clair légèrement rosé */
        }

        body.dark-mode .board-container.board-scored .board-number {
            color: #ff8a80 !important;
            /* Numéro d'échiquier rouge clair */
        }

        /* --- CORRECTIONS MODE SPECTATEUR --- */

        /* 1. Afficher la section des Rondes */
        .spectator-mode #roundsSection {
            display: block !important;
        }

        /* 2. Mais cacher les boutons d'ajout/suppression dedans (Lecture seule) */
        .spectator-mode #roundsSection button,
        .spectator-mode #roundsSection hr {
            display: none !important;
        }

        /* 3. Désactiver le menu déroulant des rondes pour qu'il soit juste informatif */
        .spectator-mode #roundSelector {
            pointer-events: none;
            background-color: #e9ecef;
            color: #6c757d;
        }

        /* =====================================================
       STYLES POPUP INFO JOUEUR (CORRIGÉS & RÉDUITS)
    ===================================================== */
        #playerTableInfoModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 450px;
            /* Plus étroit */
            background: rgba(255, 255, 255, 0.98);
            /* Fond blanc opaque */
            border-radius: 12px;
            padding: 25px 20px;
            text-align: center;
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.5);
            z-index: 10005;
            border: 3px solid #667eea;
            pointer-events: auto;
            /* Clics activés */
        }

        /* Bouton Fermer */
        #closePlayerTableInfoBtn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #eb3349;
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            font-size: 1.2em;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Nom du joueur suivi */
        .info-name-container {
            font-size: 1.6em;
            /* Était 3em -> Réduit de moitié */
            margin-bottom: 10px;
            font-weight: 800;
            color: #2c3e50;
            word-wrap: break-word;
            line-height: 1.2;
        }

        /* "Table X" */
        .info-table-container {
            font-size: 1.4em;
            /* Était 2.5em */
            margin-bottom: 15px;
            color: #34495e;
        }

        #playerTableInfoTable {
            color: #e74c3c;
            font-weight: bold;
            font-size: 1.2em;
        }

        /* Bloc Adversaire */
        .info-opponent-block {
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }

        /* Couleur (Blancs/Noirs) */
        .info-color {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .info-vs {
            font-size: 0.9em;
            color: #7f8c8d;
            font-style: italic;
            margin-bottom: 5px;
        }

        /* Nom de l'adversaire */
        .info-opponent-name {
            font-size: 1.3em;
            /* Était 2em -> Réduit */
            font-weight: bold;
            color: #2c3e50;
            word-wrap: break-word;
            /* Coupe les noms très longs */
        }
    </style>
</head>

<body>
    <script>
        window.onerror = function (msg, url, line) {
            const div = document.createElement('div');
            div.style.cssText = 'position:fixed;top:0;left:0;background:red;color:white;z-index:99999;padding:20px;font-size:20px;';
            div.textContent = 'ERROR: ' + msg + ' at line ' + line;
            document.body.appendChild(div);
        };
    </script>
    <div class="container">
        <!-- HEARTBEAT INDICATOR -->
        <div id="connectionStatus" title="Statut Connexion"></div>
        <button id="projectorReturnBtn" onclick="toggleProjectorMode()">↩ Retour</button>
        <div class="main-content">
            <div class="sidebar">
                <button id="sidebarToggle" onclick="toggleSidebar()" class="btn-secondary"
                    title="Masquer/Afficher le volet">«</button>

                <div class="sidebar-section" id="saveControlsSection">
                    <h3 onclick="toggleAccordion(this)">💾 Mode</h3>
                    <div class="sidebar-content">

                        <div class="switch-container">
                            <span>Mode <strong id="modeSwitchLabel">Arbitre</strong></span>
                            <label class="switch">
                                <input type="checkbox" id="modeSwitch">
                                <span class="slider"></span>
                            </label>
                        </div>

                        <div class="control-group">
                            <label for="saveStrategySelector" style="font-weight: bold;">Sauvegarde :</label>
                            <select id="saveStrategySelector">
                                <option value="server_only" selected>☁️ Serveur</option>
                                <option value="local_only">💾 Local</option>
                            </select>
                        </div>

                        <button id="btnShowHistory" class="btn-secondary" style="margin-top: 8px;">
                            📂 Historique Serveur
                        </button>

                        <button class="btn-info" onclick="showArbiterPasswordModal()">🔐 Changer Mot de
                            Passe</button>
                        <button class="btn-success" onclick="showPlayerLoginModal()">🧑‍🤝‍🧑 Mode Saisie
                            Joueurs</button>

                        <div id="saveStatus"
                            style="margin-top: 10px; padding: 8px; border-radius: 4px; font-size: 0.8em; display: none; word-wrap: break-word;">
                        </div>
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3 onclick="toggleAccordion(this)">⚙️ Gestion</h3>
                    <div class="sidebar-content">
                        <button class="btn-primary" onclick="openRegistrationOverlay()">📋 Inscriptions &
                            Pointages</button>
                        <button class="btn-secondary" onclick="exportToPDF()">📄 Imprimer Appariements</button>
                        <button class="btn-secondary" onclick="exportVisualPDF()">🖼️ Exporter Plan (Image)</button>
                        <button class="btn-secondary" onclick="exportToTRF()">🌍 Exporter TRF (FIDE)</button>
                        <button class="btn-danger" onclick="clearAll()">🗑️ Tout Effacer</button>
                    </div>
                </div>

                <div class="sidebar-section" id="liveFollowSection">
                    <h3 onclick="toggleAccordion(this); setTimeout(updateSpectatorPlayerList, 100);"
                        style="background: #e8f5e9; color: #2e7d32; cursor: pointer;">
                        🕵️ Suivi (Live)
                    </h3>

                    <div class="sidebar-content expanded">
                        <div
                            style="background: #e8f5e9; color: #2e7d32; padding: 5px 10px; font-weight: bold; text-align: center; font-size: 0.9em; border-bottom: 1px solid #c8e6c9; margin-bottom: 10px; border-radius: 4px;">
                            En cours : <span id="spectatorRoundDisplay">--</span>
                        </div>

                        <div id="playerSelectContainer">
                            <label style="font-weight: bold; font-size: 0.9em; color: #555;">Joueur à suivre ?</label>
                            <select id="spectatorPlayerSelect"
                                style="width: 100%; padding: 8px; margin-top: 5px; font-size: 1em; border: 2px solid #2e7d32; background: white;">
                                <option value="">-- Charger la liste --</option>
                            </select>

                            <button class="btn-success" style="margin-top: 10px; width: 100%; font-weight: bold;"
                                onclick="startAutoWatchFromList()">
                                ▶️ Activer le Suivi
                            </button>
                        </div>

                        <div id="playerTrackingContainer" style="display: none; text-align: center;">
                            <div
                                style="background: #2e7d32; color: white; padding: 8px; border-radius: 5px; margin-bottom: 10px;">
                                Suivi de : <strong id="trackingPlayerName" style="font-size: 1.1em;">...</strong>
                            </div>

                            <div id="trackingLiveInfo"
                                style="background: white; border: 2px solid #667eea; padding: 10px; border-radius: 5px; margin-bottom: 10px; min-height: 60px; display: flex; flex-direction: column; justify-content: center;">
                                <span style="font-size: 1.2em; font-weight: bold; color: #666;">⏳ En attente...</span>
                            </div>

                            <button class="btn-danger" style="width: 100%; font-size: 0.9em;" onclick="stopAutoWatch()">
                                ⏹️ Arrêter le suivi
                            </button>
                        </div>
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3 onclick="toggleAccordion(this)">📊 Données</h3>
                    <div class="sidebar-content">
                        <div class="stats-grid">
                            <div class="stat-item" onclick="filterTables('all')" style="cursor: pointer;"
                                title="Tout afficher">
                                <div class="stat-label">Total</div>
                                <div class="stat-value" id="totalBoards">0</div>
                            </div>
                            <div class="stat-item" onclick="filterTables('playing')" style="cursor: pointer;"
                                title="Afficher en cours">
                                <div class="stat-label">En cours</div>
                                <div class="stat-value" id="activeBoards">0</div>
                            </div>
                            <div class="stat-item" onclick="filterTables('finished')" style="cursor: pointer;"
                                title="Afficher terminées">
                                <div class="stat-label">Terminées</div>
                                <div class="stat-value" id="finishedBoards">0</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Restants</div>
                                <div class="stat-value" id="remainingBoards">0</div>
                            </div>
                        </div>

                        <hr style="margin: 10px 0; border: 1px solid #e9ecef;">

                        <div class="control-group">
                            <label>Actions Rapides :</label>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px;">
                                <button class="tool-btn" onclick="toggleProjectorMode()" style="font-size: 0.8em;">📽️
                                    Projecteur</button>
                                <button class="tool-btn" onclick="toggleDarkMode()" style="font-size: 0.8em;">🌙
                                    Sombre</button>
                            </div>
                        </div>

                        <hr style="margin: 10px 0; border: 1px solid #e9ecef;">

                        <button class="btn-info" onclick="exportToPDF()">📄 Résultats (PDF)</button>
                        <button class="btn-secondary" onclick="exportToTRF()" style="margin-top: 5px;">🌍 Export TRF
                            (FIDE)</button>

                        <div class="control-group" style="margin-top: 10px; margin-bottom: 5px;">
                            <label for="pdfOrientation" style="font-size: 0.9em;">Orientation Plan :</label>
                            <select id="pdfOrientation" style="padding: 4px 8px; font-size: 0.9em;">
                                <option value="l">Paysage</option>
                                <option value="p">Portrait</option>
                            </select>
                        </div>
                        <button class="btn-info" id="exportVisualPdfBtn" onclick="exportVisualPDF()">🖨️ Imprimer le
                            Plan</button>

                        <hr style="margin: 10px 0; border: 1px solid #e9ecef;">

                        <!-- <button class="btn-secondary" onclick="saveLayout()">💾 Sauvegarder le Tournoi</button> -->
                        <button class="btn-secondary" onclick="loadLayout()">📂 Charger le Tournoi</button>
                        <button class="btn-success" onclick="downloadCurrentData()" style="margin-top: 5px;">⬇️
                            Télécharger Données Actuelles</button>
                        <button class="btn-danger" onclick="clearAll()">🗑️ Tout effacer</button>

                        <hr style="margin: 10px 0; border: 1px solid #e9ecef;">
                        <label style="font-size: 0.8em; font-weight: bold; color: #666;">Outils Debug :</label>
                        <button class="btn-warning" onclick="forceSaveToServer()"
                            style="font-size: 0.8em; margin-top: 5px;">⚠️ Forcer Sauvegarde Serveur</button>
                    </div>
                </div>



                <div class="sidebar-section" id="playersSection">
                    <h3 onclick="toggleAccordion(this)">🔍 Joueurs</h3>
                    <div class="sidebar-content">
                        <div class="control-group">
                            <label for="searchInput">Chercher échiquier/joueur :</label>
                            <input type="text" id="searchInput" placeholder="Nom ou numéro d'échiquier..."
                                oninput="searchTables()" list="search-suggestions">
                            <datalist id="search-suggestions"></datalist>
                        </div>
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3 onclick="toggleAccordion(this)">⛳️ Rondes</h3>
                    <div class="sidebar-content">
                        <div class="control-group">
                            <label for="roundSelector">Ronde Actuelle :</label>
                            <select id="roundSelector" onchange="switchRound(this.value)"></select>
                        </div>
                        <button class="btn-primary" onclick="addNewRound()">+ Nouvelle Ronde</button>
                        <button class="btn-secondary" onclick="cloneRoundLayout()">+ Cloner la dispo</button>

                        <button class="btn-danger" style="margin-top: 5px;" onclick="deleteCurrentRound()">-
                            Supprimer
                            la Ronde</button>

                        <hr style="margin: 10px 0; border: 1px solid #e9ecef;">

                        <button class="btn-danger" onclick="createNewTournament()">⚠️ Nouveau Tournoi</button>
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3 onclick="toggleAccordion(this)">➕ Disposition</h3>
                    <div class="sidebar-content">

                        <div class="control-group">
                            <label for="boardsPerTable">Échiquiers par table physique :</label>
                            <input type="number" id="boardsPerTable" min="1" max="10" value="1">
                        </div>
                        <div class="control-group">
                            <label for="physicalTablesPerRow">Tables par rangée :</label>
                            <input type="number" id="physicalTablesPerRow" min="1" max="20" value="10">
                        </div>
                        <div class="control-group">
                            <label for="tableLength">Taille des tables :</label>
                            <select id="tableLength">
                                <option value="140">Petite</option>
                                <option value="180" selected>Moyenne</option>
                                <option value="220">Grande</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label for="startCorner">Position de départ :</label>
                            <select id="startCorner">
                                <option value="tl">En haut à gauche</option>
                                <option value="tr">En haut à droite</option>
                                <option value="bl">En bas à gauche</option>
                                <option value="br">En bas à droite</option>
                            </select>
                        </div>
                        <button class="btn-secondary" onclick="autoArrangeTables()">📐 Réorganiser le plan</button>
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3 onclick="toggleAccordion(this)">🏛️ Salles</h3>
                    <div class="sidebar-content">
                        <div class="control-group">
                            <label for="roomNameInput">Nom de la salle/zone :</label>
                            <input type="text" id="roomNameInput" placeholder="Ex: Salle A, Zone Calme...">
                        </div>
                        <button class="btn-info" onclick="addRoom()">+ Ajouter une Salle/Mur</button>

                        <hr style="margin: 10px 0; border: 1px solid #e9ecef;">
                        <label style="font-size: 0.9em; font-weight: bold; margin-bottom: 5px; display: block;">Ajout
                            Rapide :</label>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px;">
                            <button class="btn-secondary" style="font-size: 0.85em; padding: 5px;"
                                onclick="addPredefinedRoom('arbitrage')">Arbitrage</button>
                            <button class="btn-secondary" style="font-size: 0.85em; padding: 5px;"
                                onclick="addPredefinedRoom('toilettes')">Toilettes</button>
                            <button class="btn-secondary" style="font-size: 0.85em; padding: 5px;"
                                onclick="addPredefinedRoom('buvette')">Buvette</button>
                            <button class="btn-secondary" style="font-size: 0.85em; padding: 5px;"
                                onclick="addPredefinedRoom('analyse')">Analyse</button>
                        </div>
                    </div>
                </div>
                <div class="sidebar-section">
                    <h3 onclick="toggleAccordion(this)">🎮 Appariements</h3>
                    <div class="sidebar-content">
                        <div class="control-group">
                            <label>Système d'appariement :</label>
                            <select id="pairingSystemSelect">
                                <option value="swiss">Système Suisse (FIDE)</option>
                                <option value="cup">Système Coupe (KO)</option>
                                <option value="roundrobin">Toutes Rondes (Berger)</option>
                            </select>
                        </div>

                        <div class="control-group">
                            <label style="font-weight: bold;">Appariements :</label>
                            <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                                <button class="btn-primary" onclick="generatePairingsUI()" style="flex: 1;">
                                    🎲 Appariements R+1
                                </button>
                                <button class="btn-info" onclick="openTournamentSettings()" title="Options Avancées"
                                    style="flex: 1;">🛠️</button>
                                <button class="btn-info" onclick="showResultsView()" style="flex: 1;">
                                    🏆 Voir les résultats
                                </button>
                                <button class="btn-success" onclick="showResultsManagement()" style="flex: 1;">
                                    📊 Gérer Résultats
                                </button>
                                <button class="btn-warning" onclick="showCupBracket()" id="btnShowCupBracket"
                                    style="flex: 1; display: none;">
                                    🏆 Voir le Tableau
                                </button>
                            </div>
                            <p id="pairingMsg" style="margin-top: 5px; font-size: 0.9em; font-weight: bold;"></p>
                        </div>

                        <hr style="margin: 15px 0; border: 1px solid #e9ecef;">

                        <label for="pairingFileInput" class="file-upload-label">📁 Charger Papi/Fichier</label>
                        <input type="file" id="pairingFileInput" accept=".html,.htm" onchange="loadPapiFile(event)">

                        <hr style="margin: 10px 0; border: 1px solid #e9ecef;">

                        <div class="control-group">
                            <label for="boardCount">Échiquiers manuels :</label>
                            <input type="number" id="boardCount" min="1" max="2000" value="10">
                        </div>
                        <button class="btn-secondary" onclick="addBoards()">+ Ajouter Tables Vides</button>

                        <hr style="margin: 10px 0; border: 1px solid #e9ecef;">

                        <button class="btn-danger" onclick="clearPairings()">Effacer Appariements</button>
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3 onclick="toggleAccordion(this)">📠 QR-codes</h3>
                    <div class="sidebar-content">
                        <div class="control-group">
                            <label for="qrNumTables">Nombre d'échiquiers à générer :</label>
                            <input type="number" id="qrNumTables" min="1" max="2000" value="50">
                        </div>
                        <button class="btn-info" onclick="generateQRFiches()">🖨️ Générer Fiches QR
                            Résultats</button>
                        <button class="btn-success" onclick="generatePlayerQRCodes()" style="margin-top: 10px;">🎫
                            Générer QR-codes Joueurs</button>
                    </div>
                </div>



            </div>
            <div class="workspace">
                <div class="toolbar">
                    <button class="tool-btn active" onclick="setTool('select')" id="selectTool">
                        &nbsp;&nbsp;&nbsp;🖱️ Sélection
                    </button>
                    <button class="tool-btn" onclick="setTool('multiselect')" id="multiselectTool">
                        ☑️ Plusieurs
                    </button>
                    <button class="tool-btn" onclick="setTool('pan')" id="panTool">
                        ✋ Bouger
                    </button>
                    <button class="tool-btn" onclick="setTool('moveboard')" id="moveboardTool">
                        ⇭ Déplacer
                    </button>

                    <button class="tool-btn" onclick="undo()" id="undoButton" title="Annuler (Ctrl+Z)" disabled>
                        ↶
                    </button>
                    <button class="tool-btn" onclick="redo()" id="redoButton" title="Rétablir (Ctrl+Y)" disabled>
                        ↷
                    </button>

                    <button class="tool-btn" onclick="deleteSelected()" title="Supprimer (Touche Suppr ou Retour)">
                        🗑️ Effacer
                    </button>
                    <button class="tool-btn" onclick="duplicateSelected()" title="Dupliquer (Ctrl+D)">
                        📋 Dupliquer
                    </button>
                    <button class="tool-btn" onclick="rotateSelected()" title="Rotation (R)">
                        ↻ Tourner
                    </button>
                    <button class="tool-btn" onclick="flipPlayersSelected()">
                        🔄 Inverser
                    </button>

                    <button class="btn-success" onclick="startQRScanner()" title="Scanner un résultat par QR Code"
                        style="margin: 0;">
                        📷 QR-codes
                    </button>

                    <div class="timer-controls">
                        <label for="timerMinutes" style="font-size: 0.9em; color: #333;">Minuteur :</label>
                        <input type="number" id="timerMinutes" value="15" min="-240">
                        <button class="btn-success btn-small" onclick="startRoundTimer()">▶</button>
                        <button class="btn-danger btn-small" onclick="stopRoundTimer()">⏹</button>
                        <span id="roundTimer">00:00</span>

                        <button class="btn-secondary btn-small" id="toggleBigTimerBtn" onclick="toggleBigTimer()"
                            title="Masquer/Afficher le chrono plein écran"
                            style="margin-left: 5px; display: none;">👁️</button>
                    </div>
                    <div style="margin-left: auto; color: #6c757d; font-size: 0.9em;">
                        Nb: <span id="selectedCount">0</span> | Z: <span id="zoomLevel">100%</span>
                    </div>
                </div>

                <div class="canvas-container" id="canvasContainer">
                    <div class="canvas" id="canvas"></div>
                </div>

                <div class="zoom-controls">
                    <input type="range" min="10" max="200" value="100" class="zoom-slider" id="zoomSlider"
                        oninput="applyZoom(this.value / 100)" onchange="applyZoom(this.value / 100)">
                    <button class="zoom-btn btn-secondary" onclick="resetZoom()" title="Zoom 100%">⊙</button>
                    <button class="zoom-btn btn-secondary" onclick="fitAllTables()"
                        title="Voir toutes les tables">⛶</button>
                </div>

                <div class="shortcut-bar">
                    <span>S</span> Sél. <span>P</span> Dépl. <span>M</span> Multi-Sél. <span>Ctrl+Z</span> Annuler
                    <span>Suppr/Retour</span> Suppr. <span>R</span> Rotation <span>Ctrl+A</span> Tout Sél.
                </div>

            </div>
        </div>

    </div>
    </div>

    <button id="playerPlanReturnButton" class="btn-secondary" onclick="returnToPlayerHome()">
        ⬅️ Retour à l'accueil
    </button>
    <div id="loadingOverlay">
        <span>Génération du PDF en cours...</span>
    </div>
    <div id="scoreModal">
        <div id="scoreModalContent">
            <h4>Saisir le résultat</h4>
            <p>Pour l'échiquier : <strong id="scoreModalBoardNum"></strong></p>
            <select id="scoreModalSelect">
                <option value="">-- Choisir Résultat --</option>
                <option value="1-0">1-0</option>
                <option value="0-1">0-1</option>
                <option value="1/2-1/2">½-½</option>
                <option value="1-F">1-F (Blanc gagne F)</option>
                <option value="F-1">F-1 (Noir gagne F)</option>
                <option value="1/2-0">½-0</option>
                <option value="0-1/2">0-½</option>
                <option value="0-0">0-0 (Double perte)</option>
                <option value="F-F">F-F (Double forfait)</option>
            </select>
            <div class="score-modal-buttons">
                <button class="btn-success" onclick="saveScoreFromModal()">OK</button>
                <button class="btn-secondary" onclick="hideScoreModal()">Annuler</button>
            </div>
        </div>
    </div>
    <div id="qrScannerModal" class="modal-overlay" style="display:none;">
        <div id="qrScannerContent" class="modal-content">
            <h2>Scanner le QR Code</h2>
            <div id="video-container" style="background: #000; border-radius: 8px; overflow: hidden; margin: 20px 0;">
                <video id="qrVideo" autoplay playsinline style="width: 100%; display: block;"></video>
            </div>
            <div class="info-box">
                Positionnez le QR code dans le cadre de la caméra
            </div>
            <button class="btn-danger" onclick="stopQRScanner()" style="width: 100%;">
                Arrêter et Fermer
            </button>
        </div>
    </div>
    <div id="qrValidationModal" class="modal-overlay" style="display:none;">
        <div id="qrValidationContent" class="modal-content" style="width: 90%; max-width: 450px;">
            <h3>Valider le résultat ?</h3>
            <div id="validation-info"
                style="background: #f8f9fa; border-radius: 8px; padding: 20px; text-align: left; margin: 20px 0; line-height: 1.6;">
                <p style="font-size:1.1em; margin-bottom: 10px;">
                    <strong>Échiquier :</strong> <span id="qrValidateBoard"></span>
                </p>
                <p style="font-size:1.1em; margin-bottom: 5px;">
                    <strong>Blancs :</strong> <span id="qrValidateWhite"></span>
                </p>
                <p style="font-size:1.1em; margin-bottom: 15px; border-bottom: 1px solid #ddd; padding-bottom: 15px;">
                    <strong>Noirs :</strong> <span id="qrValidateBlack"></span>
                </p>
                <p style="font-size:1.4em; color:#667eea; text-align: center;">
                    <strong>Résultat :</strong> <span id="qrValidateResult"></span>
                </p>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                <button class="btn-success" onclick="validateQRResult()">
                    ✅ Valider
                </button>
                <button class="btn-secondary" onclick="cancelQRValidation()">
                    ❌ Annuler
                </button>
            </div>
        </div>
    </div>
    <div id="notification" class="notification"></div>
    <div id="arbiterPassModal" class="modal-overlay">
        <div class="modal-content" style="width: 350px;">
            <h2>Mot de passe Arbitre</h2>
            <p style="font-size: 0.9em; color: #666; margin-bottom: 15px;">
                Définissez un mot de passe pour le "Mode Saisie Joueur".
                Laissez vide pour désactiver ce mode.
            </p>
            <div class="control-group">
                <label for="arbiterPassInput">Nouveau mot de passe :</label>
                <input type="password" id="arbiterPassInput" placeholder="Minimum 4 caractères">
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn-success" onclick="setArbiterPassword()">Enregistrer</button>
                <button class="btn-secondary"
                    onclick="document.getElementById('arbiterPassModal').style.display = 'none'">Annuler</button>
            </div>
        </div>
    </div>

    <div id="switchToArbiterModal" class="modal-overlay" style="display: none;">
        <div class="modal-content" style="width: 350px;">
            <h2>🔐 Passage en Mode Arbitre</h2>
            <p style="margin-bottom: 15px;">Veuillez entrer le mot de passe arbitre pour passer en mode modification.
            </p>
            <div class="control-group">
                <label for="switchArbiterPassInput">Mot de passe :</label>
                <input type="password" id="switchArbiterPassInput" placeholder="Mot de passe arbitre">
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn-success" onclick="validateSwitchToArbiter()">Valider</button>
                <button class="btn-secondary" onclick="cancelSwitchToArbiter()">Annuler</button>
            </div>
        </div>
    </div>

    <div id="playerLoginModal" class="modal-overlay">
        <div class="modal-content" style="width: 350px;">
            <h2>Accès Saisie Résultat</h2>
            <p style="margin-bottom: 15px;">Veuillez entrer le mot de passe arbitre pour continuer.</p>
            <div class="control-group">
                <label for="playerPassInput">Mot de passe :</label>
                <input type="password" id="playerPassInput">
            </div>
            <div id="playerLoginError" style="color: #c00; font-weight: 600; margin-top: 10px; display: none;">
                Mot de passe incorrect.
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn-primary" onclick="loginAsPlayer()">Valider</button>
                <button class="btn-secondary"
                    onclick="document.getElementById('playerLoginModal').style.display = 'none'">Annuler</button>
            </div>
        </div>
    </div>
    <div id="playerHomeModal" class="modal-overlay"
        style="z-index: 10001; flex-direction: column; background: rgba(240, 240, 240, 0.98);">
        <div class="modal-content" style="width: 90%; max-width: 800px; box-shadow: 0 10px 40px rgba(0,0,0,0.3);">
            <h2 style="font-size: 1.8em; text-align: center;">Voir sa table / Encoder un résultat (Ronde: <span
                    id="playerModeRound"></span>)</h2>

            <div style="text-align: center; margin-bottom: 25px; margin-top: 15px;">
                <button class="btn-success" style="font-size: 1.2em; padding: 15px; width: 70%;"
                    onclick="startQRScanner()">
                    📷 Scanner QR Code (résultat)
                </button>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">

                <div style="border: 2px solid #667eea; border-radius: 10px; padding: 20px;">
                    <h3 style="text-align: center; color: #667eea; margin-top: 0; margin-bottom: 20px;">📍 Où est ma
                        table ?</h3>
                    <div style="display: grid; grid-template-columns: 1fr; gap: 15px;">
                        <button class="btn-primary" style="font-size: 1.1em; padding: 12px;"
                            onclick="startPlayerQRScanner()">
                            🎫 Scanner mon QR-code
                        </button>
                        <button class="btn-info" style="font-size: 1.1em; padding: 12px;"
                            onclick="showPlayerListSearch('VIEW')">
                            🧑‍🤝‍🧑 Chercher (Liste)
                        </button>
                        <button class="btn-info" style="font-size: 1.1em; padding: 12px;"
                            onclick="showPlayerTextSearch('VIEW')">
                            🔍 Chercher (Texte)
                        </button>
                    </div>
                </div>

                <div style="border: 2px solid #11998e; border-radius: 10px; padding: 20px;">
                    <h3 style="text-align: center; color: #11998e; margin-top: 0; margin-bottom: 20px;">✍️ Encoder un
                        résultat</h3>
                    <div style="display: grid; grid-template-columns: 1fr; gap: 15px;">
                        <button class="btn-primary" style="font-size: 1.1em; padding: 12px;"
                            onclick="showPlayerPlanView()">
                            🗺️ Saisir (Plan)
                        </button>
                        <button class="btn-info" style="font-size: 1.1em; padding: 12px;"
                            onclick="showPlayerListSearch('ENCODE')">
                            🧑‍🤝‍🧑 Choisir (Liste)
                        </button>
                        <button class="btn-info" style="font-size: 1.1em; padding: 12px;"
                            onclick="showPlayerTextSearch('ENCODE')">
                            🔍 Chercher (Texte)
                        </button>
                    </div>
                </div>

            </div>

            <button class="btn-danger"
                style="margin-top: 30px; width: auto; padding: 10px 20px; display: block; margin-left: auto; margin-right: auto;"
                onclick="promptToLogoutPlayer()">
                Quitter le Mode Saisie
            </button>
        </div>
    </div>
    <div id="playerTextSearchModal" class="modal-overlay" style="z-index: 10002;">
        <div class="modal-content" style="width: 90%; max-width: 500px;">
            <h3>Chercher ma partie</h3>
            <div class="control-group">
                <label for="playerSearchInput">Entrez votre nom :</label>
                <input type="text" id="playerSearchInput" placeholder="Ex: Durand..." list="player-search-suggestions"
                    oninput="populatePlayerSearchSuggestions()">
                <datalist id="player-search-suggestions"></datalist>
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn-primary" onclick="findPlayerFromTextSearch()">Rechercher</button>
                <button class="btn-secondary" onclick="closePlayerTextSearch()">Annuler</button>
            </div>
        </div>
    </div>
    <!-- OVERLAY INSCRIPTIONS -->
    <div id="registrationOverlay">
        <div class="max-w-7xl mx-auto">
            <header class="reg-header"
                style="display: flex; justify-content: space-between; align-items: center; padding: 10px 0; border-bottom: 1px solid #e2e8f0; margin-bottom: 15px;">
                <div style="flex: 1;">
                    <input type="text" id="regTournamentName" placeholder="Nom du Tournoi"
                        style="font-size: 1.2em; font-weight: bold; border: none; background: transparent; width: 100%; color: #1e293b;"
                        onchange="saveTournamentName(this.value)">
                </div>
                <button class="reg-btn reg-btn-secondary" onclick="closeRegistrationOverlay()"
                    style="padding: 6px 12px; font-size: 0.9em;">Fermer ✕</button>
            </header>

            <section class="reg-grid"
                style="display: flex; justify-content: space-between; align-items: center; gap: 15px; margin-bottom: 15px; padding: 10px; background: #f8fafc; border-radius: 8px;">
                <div style="display: flex; gap: 15px;">
                    <div style="display: flex; align-items: center; gap: 5px;">
                        <span style="font-weight: 600; color: #64748b; font-size: 0.9em;">Inscrits:</span>
                        <span id="aggTotal" style="font-weight: bold; font-size: 1em;">0</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 5px;">
                        <span style="font-weight: 600; color: #64748b; font-size: 0.9em;">Pointés:</span>
                        <span id="aggChecked" style="font-weight: bold; font-size: 1em; color: #10b981;">0</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 5px;">
                        <span style="font-weight: 600; color: #64748b; font-size: 0.9em;">Restants:</span>
                        <span id="aggRemaining" style="font-weight: bold; font-size: 1em; color: #f59e0b;">0</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 5px;">
                        <span style="font-weight: 600; color: #64748b; font-size: 0.9em;">Payés:</span>
                        <span id="aggPaid" style="font-weight: bold; font-size: 1em; color: #6366f1;">0</span>
                    </div>
                </div>
                <div style="display: flex; gap: 10px;">
                    <button id="btnImportPapi" class="reg-btn reg-btn-indigo"
                        onclick="document.getElementById('papiFileInput').click()"
                        style="padding: 4px 8px; font-size: 0.8em; width: auto !important; background-color: #6366f1; color: white;">Import
                        liste PAPI</button>
                    <input type="file" id="papiFileInput" accept=".html,.htm" style="display: none;"
                        onchange="importPapiParticipants(this)">
                    <button type="button" class="reg-btn reg-btn-primary" onclick="startRegistrationQRScanner()"
                        style="padding: 4px 8px; font-size: 0.8em; width: auto !important; display: flex; align-items: center; gap: 5px;">
                        Scanner un QR-code de pointage
                    </button>
                </div>
            </section>


            <section class="reg-section" style="margin-bottom: 10px;">
                <!-- Compact FFE Import -->
                <div style="display: flex; gap: 10px; align-items: center; width: 100%; margin-bottom: 10px;">
                    <input id="ffeUrlInput" type="text" class="reg-input" placeholder="Collez l'URL FFE ici..."
                        style="flex: 1; min-width: 0; padding: 6px 10px; font-size: 0.9em; border: 1px solid #cbd5e1; border-radius: 4px;">
                    <button type="button" class="reg-btn reg-btn-primary" onclick="importFromFFE()"
                        style="width: auto !important; padding: 6px 12px; font-size: 0.9em; white-space: nowrap; flex-shrink: 0; cursor: pointer; background-color: #2563eb; font-weight: bold;">
                        📥 Importer
                    </button>
                </div>
                <div id="ffeImportStatus" style="font-size: 0.85em; color: #64748b; min-height: 0; margin-bottom: 5px;">
                </div>

                <!-- Compact Add Form -->
                <form id="formAddReg" class="reg-controls" style="align-items: flex-end; gap: 5px; flex-wrap: nowrap;">
                    <div class="reg-control-group" style="flex: 0 0 auto;">
                        <label class="reg-card-label" style="font-size: 0.8em; margin-bottom: 2px;">Recherche
                            FIDE</label>
                        <div style="display: flex; gap: 2px;">
                            <input id="fideSearchInput" type="text" class="reg-input"
                                onkeydown="if(event.key === 'Enter') searchFIDE()"
                                style="padding: 4px 6px; font-size: 0.9em; width: 120px;">
                            <button type="button" class="reg-btn reg-btn-primary" onclick="searchFIDE()"
                                style="padding: 4px 8px; font-size: 0.9em;">🔍</button>
                        </div>
                    </div>

                    <div class="reg-control-group" style="flex: 1;">
                        <label class="reg-card-label" style="font-size: 0.8em; margin-bottom: 2px;">Nom</label>
                        <input id="regLast" type="text" class="reg-input" required
                            style="padding: 4px 6px; font-size: 0.9em;">
                    </div>
                    <div class="reg-control-group" style="flex: 1;">
                        <label class="reg-card-label" style="font-size: 0.8em; margin-bottom: 2px;">Prénom</label>
                        <input id="regFirst" type="text" class="reg-input" required
                            style="padding: 4px 6px; font-size: 0.9em;">
                    </div>
                    <div class="reg-control-group" style="flex: 0 0 60px;">
                        <label class="reg-card-label" style="font-size: 0.8em; margin-bottom: 2px;">Elo</label>
                        <input id="regElo" type="number" class="reg-input" value="1000"
                            style="padding: 4px 6px; font-size: 0.9em;">
                    </div>
                    <div class="reg-control-group" style="flex: 1;">
                        <label class="reg-card-label" style="font-size: 0.8em; margin-bottom: 2px;">Club / Fed</label>
                        <input id="regClub" type="text" class="reg-input" style="padding: 4px 6px; font-size: 0.9em;">
                    </div>
                    <div class="reg-control-group" style="flex: 0 0 80px;">
                        <label class="reg-card-label" style="font-size: 0.8em; margin-bottom: 2px;">Fide ID</label>
                        <input id="regFideId" type="text" class="reg-input" style="padding: 4px 6px; font-size: 0.9em;">
                    </div>

                    <button type="submit" class="reg-btn reg-btn-success"
                        style="padding: 5px 10px; font-size: 0.9em; margin-bottom: 1px; white-space: nowrap;">Ajouter</button>
                </form>
                <span id="regAddMsg" style="font-size: 0.8em; margin-top: 2px; display: block;"></span>
            </section>

            <section class="reg-section" style="margin-top: 15px;">
                <div class="reg-controls" style="gap: 10px;">
                    <div class="reg-control-group" style="flex: 2;">
                        <label class="reg-card-label" style="font-size: 0.8em; margin-bottom: 2px;">Recherche
                            Locale</label>
                        <input id="regSearch" type="text" class="reg-input" placeholder="Nom ou Licence..."
                            style="padding: 4px 8px; font-size: 0.9em;">
                    </div>
                    <div class="reg-control-group" style="flex: 1;">
                        <label class="reg-card-label" style="font-size: 0.8em; margin-bottom: 2px;">Statut</label>
                        <select id="regFilterStatus" class="reg-input" style="padding: 4px 8px; font-size: 0.9em;">
                            <option value="">Tous</option>
                            <option>Pointé</option>
                            <option>Non pointé</option>
                            <option>Annulé</option>
                        </select>
                    </div>
                    <div class="reg-control-group" style="flex: 1;">
                        <label class="reg-card-label" style="font-size: 0.8em; margin-bottom: 2px;">Paiement</label>
                        <select id="regFilterPayment" class="reg-input" style="padding: 4px 8px; font-size: 0.9em;">
                            <option value="">Tous</option>
                            <option>Réglé</option>
                            <option>Non réglé</option>
                            <option>Exonéré</option>
                        </select>
                    </div>
                </div>
                <!-- Hidden inputs for file operations -->
                <input id="regJsonImportInput" type="file" accept=".json" style="display:none">
            </section>

            <!-- Player List Table -->
            <div
                style="flex: 1; min-height: 300px; overflow-y: auto; margin-top: 15px; background: white; border-radius: 8px; border: 1px solid #eee;">
                <table style="width: 100%; border-collapse: collapse; font-size: 0.9em;">
                    <thead style="position: sticky; top: 0; background: #f8f9fa; z-index: 10;">
                        <tr style="color: #666; text-align: left;">
                            <th style="padding: 10px; border-bottom: 2px solid #eee;">Nom</th>
                            <th style="padding: 10px; border-bottom: 2px solid #eee;">Prénom</th>
                            <th style="padding: 10px; border-bottom: 2px solid #eee;">Elo</th>
                            <th style="padding: 10px; border-bottom: 2px solid #eee;">Club</th>
                            <th style="padding: 10px; border-bottom: 2px solid #eee;">Fide ID</th>
                            <th style="padding: 10px; border-bottom: 2px solid #eee;">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    Statut
                                    <button class="reg-btn reg-btn-success" onclick="checkAll()"
                                        style="padding: 1px 4px; font-size: 0.65em;">Dé/Pointer Tous</button>
                                </div>
                            </th>
                            <th style="padding: 10px; border-bottom: 2px solid #eee;">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    Paiement
                                    <button class="reg-btn reg-btn-indigo" onclick="markAllPaid()"
                                        style="padding: 1px 4px; font-size: 0.65em; background:#e0e7ff; color:#4338ca;">Pas/Tous
                                        €</button>
                                </div>
                            </th>
                            <th style="padding: 10px; border-bottom: 2px solid #eee; text-align: right;">
                                <button id="btnPurgeReg" class="reg-btn reg-btn-danger"
                                    style="padding: 1px 4px; font-size: 0.65em;">Vider</button>
                            </th>
                        </tr>
                    </thead>
                    <tbody id="regTbody">
                        <!-- Players injected here -->
                    </tbody>
                </table>
            </div>

        </div>
        <p style="font-size: 0.8em; color: #666; margin-top: 2px;">Connexion directe FIDE via proxy</p>

    </div>
    </div>

    <!-- Modal Grille Américaine -->
    <!-- FIDE Search Modal -->
    <div id="fideSearchModal" class="modal-overlay" style="z-index: 10030;">
        <div class="modal-content" style="width: 600px; max-width: 90%;">
            <div class="modal-header">
                <h3>Résultats de la recherche FIDE</h3>
                <button class="close-modal"
                    onclick="document.getElementById('fideSearchModal').style.display='none'">×</button>
            </div>
            <div id="fideSearchResults" class="modal-body" style="max-height: 400px; overflow-y: auto;">
                <!-- Results will be injected here -->
            </div>
            <div class="modal-footer">
                <button class="btn-secondary"
                    onclick="document.getElementById('fideSearchModal').style.display='none'">Fermer</button>
            </div>
        </div>
    </div>

    <!-- Modal QR Code Inscription -->
    <div id="regQRCodeModal" class="modal-overlay" style="z-index: 10040;">
        <div class="modal-content" style="width: 400px; max-width: 90%; text-align: center;">
            <div class="modal-header">
                <h3>QR-code Joueur</h3>
                <button class="close-modal"
                    onclick="document.getElementById('regQRCodeModal').style.display='none'">×</button>
            </div>
            <div class="modal-body" style="padding: 20px; display: flex; flex-direction: column; align-items: center;">
                <div id="regQRCodeContainer" style="margin-bottom: 15px;"></div>
                <h4 id="regQRCodeName" style="margin: 10px 0; color: #333;"></h4>
                <p id="regQRCodeInfo" style="color: #666; font-size: 0.9em;"></p>
            </div>
            <div class="modal-footer" style="justify-content: center;">
                <button class="btn-primary" onclick="printRegQRCode()">🖨️ Imprimer</button>
                <button class="btn-secondary"
                    onclick="document.getElementById('regQRCodeModal').style.display='none'">Fermer</button>
            </div>
        </div>
    </div>

    <div id="americanGridModal" class="modal-overlay" style="z-index: 10020;">
        <div class="modal-content"
            style="width: 95%; max-width: 1400px; height: 90%; display: flex; flex-direction: column;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h2>Grille Américaine</h2>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <button class="reg-btn reg-btn-primary" onclick="exportAmericanGridCSV()"
                        style="padding: 8px 16px;">
                        📤 Exporter CSV
                    </button>
                    <button class="close-btn"
                        onclick="document.getElementById('americanGridModal').style.display='none'">&times;</button>
                </div>
            </div>
            <div style="flex: 1; overflow: auto; position: relative;">
                <table id="americanGridTable" style="width: 100%; border-collapse: collapse;">
                    <!-- Généré par JS -->
                </table>
            </div>
            <div id="gridHoverTooltip" class="grid-tooltip"></div>
        </div>
    </div>

    <!-- Modal Tableau Coupe -->
    <div id="cupBracketModal" class="modal-overlay" style="z-index: 10020;">
        <div class="modal-content"
            style="width: 95%; max-width: 1400px; height: 90%; display: flex; flex-direction: column;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h2>Tableau du Tournoi (Coupe)</h2>
                <button class="close-btn"
                    onclick="document.getElementById('cupBracketModal').style.display='none'">&times;</button>
            </div>
            <div id="cupBracketContainer"
                style="flex: 1; overflow: auto; position: relative; display: flex; justify-content: center; align-items: center;">
                <!-- Généré par JS -->
            </div>
        </div>
    </div>

    <!-- Modal Gestion des Résultats (Tabbed Interface) -->
    <div id="resultsManagementModal" class="modal-overlay" style="z-index: 10020;">
        <div class="modal-content"
            style="width: 95%; max-width: 1400px; height: 90%; display: flex; flex-direction: column;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h2>📊 Gestion des Résultats</h2>
                <button class="close-btn"
                    onclick="document.getElementById('resultsManagementModal').style.display='none'">&times;</button>
            </div>

            <!-- Tabs -->
            <div style="display: flex; background: #f8f9fa; border-bottom: 2px solid #dee2e6; margin-bottom: 20px;">
                <button class="results-tab active" onclick="showResultsTab('input')"
                    style="flex: 1; padding: 15px; border: none; background: transparent; cursor: pointer; font-weight: 600;">
                    ✏️ Saisie
                </button>
                <button class="results-tab" onclick="showResultsTab('history')"
                    style="flex: 1; padding: 15px; border: none; background: transparent; cursor: pointer; font-weight: 600;">
                    📜 Historique
                </button>
                <button class="results-tab" onclick="showResultsTab('validation')"
                    style="flex: 1; padding: 15px; border: none; background: transparent; cursor: pointer; font-weight: 600;">
                    ✓ Validation
                </button>
            </div>

            <!-- Tab Content -->
            <div style="flex: 1; overflow: auto;">
                <!-- Saisie Tab -->
                <div id="results-input-tab" class="results-tab-content active">
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <h3 style="margin: 0 0 10px 0;">Ronde <span id="resultsInputRound">1</span></h3>
                        <p style="margin: 0; color: #666;">Saisissez les résultats des parties ci-dessous</p>
                    </div>
                    <div id="resultsInputContainer"></div>
                    <div style="margin-top: 20px; display: flex; gap: 10px;">
                        <button class="reg-btn reg-btn-success" onclick="saveAllResults()">💾 Enregistrer tous les
                            résultats</button>
                        <button class="reg-btn reg-btn-primary" onclick="goToNextRound()">➡️ Ronde suivante</button>
                    </div>
                </div>

                <!-- Historique Tab -->
                <div id="results-history-tab" class="results-tab-content" style="display: none;">
                    <div id="resultsHistoryContainer"></div>
                </div>

                <!-- Validation Tab -->
                <div id="results-validation-tab" class="results-tab-content" style="display: none;">
                    <div id="resultsValidationContainer"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Tournament Settings Modal -->
    <div id="tournamentSettingsModal" class="modal-overlay" style="z-index: 10005;">
        <div class="modal-content" style="width: 500px;">
            <h3>🛠️ Options Avancées du Tournoi</h3>

            <div class="control-group">
                <label style="font-weight: bold;">Départages (Tie-Breaks) :</label>
                <div style="display: flex; flex-direction: column; gap: 5px; margin-top: 5px;">
                    <label><input type="checkbox" id="tbBuchholz" checked> Buchholz (Cut 1)</label>
                    <label><input type="checkbox" id="tbSonneborn" checked> Sonneborn-Berger</label>
                    <label><input type="checkbox" id="tbDirect" checked> Rencontre Directe</label>
                    <label><input type="checkbox" id="tbProgressive"> Progressif</label>
                </div>
            </div>

            <hr style="margin: 15px 0; border: 1px solid #eee;">

            <div class="control-group">
                <label style="font-weight: bold;">Points Fictifs :</label>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 5px;">
                    <div>
                        <label>Bye (Exempt) :</label>
                        <select id="ptsBye" class="reg-input">
                            <option value="1.0">1.0 Point</option>
                            <option value="0.5">0.5 Point</option>
                            <option value="0">0 Point</option>
                        </select>
                    </div>
                    <div>
                        <label>Absent (Forfait) :</label>
                        <select id="ptsAbsent" class="reg-input">
                            <option value="0">0 Point</option>
                            <option value="0.5">0.5 Point</option>
                        </select>
                    </div>
                </div>
            </div>

            <hr style="margin: 15px 0; border: 1px solid #eee;">

            <div class="control-group">
                <label style="font-weight: bold;">Appariements :</label>
                <div style="margin-top: 5px;">
                    <label><input type="checkbox" id="optAcceleration"> Accélération (FIDE)</label>
                    <p style="font-size: 0.8em; color: #666;">(Sépare les forts/faibles dès la ronde 1 pour éviter
                        les
                        écarts trop grands)</p>
                </div>
            </div>

            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn-primary" onclick="saveTournamentSettings()">💾 Enregistrer</button>
                <button class="btn-secondary"
                    onclick="document.getElementById('tournamentSettingsModal').style.display='none'">Annuler</button>
            </div>
        </div>
    </div>

    <div id="playerListSearchModal" class="modal-overlay" style="z-index: 10002;">
        <div class="modal-content" style="width: 90%; max-width: 500px;">
            <h3>Choisir ma partie</h3>
            <div class="control-group">
                <label for="playerListSelect">Sélectionnez votre nom dans la liste :</label>
                <select id="playerListSelect" style="font-size: 1.1em; padding: 8px 10px;">
                    <option value="">-- Chargement... --</option>
                </select>
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn-primary" onclick="findPlayerFromListSearch()">Valider</button>
                <button class="btn-secondary" onclick="closePlayerListSearch()">Annuler</button>
            </div>
        </div>
    </div>
    <div id="simplifiedScoreModal" class="modal-overlay" style="z-index: 10002;">
        <div class="modal-content" style="width: 90%; max-width: 500px;">
            <h3>Saisir Résultat (Échiquier <span id="simplifiedBoardNum"></span>)</h3>

            <div id="simplifiedPlayerInfo"
                style="background: #f8f9fa; border-radius: 8px; padding: 15px; text-align: center; margin-bottom: 20px; font-size: 1.1em;">
                <p><strong>Blancs:</strong> <span id="simplifiedWhitePlayer"></span></p>
                <p><strong>Noirs:</strong> <span id="simplifiedBlackPlayer"></span></p>
            </div>

            <div style="display: grid; grid-template-columns: 1fr; gap: 15px;">
                <button id="btnWinWhite" class="btn-primary"
                    style="font-size: 1.1em; padding: 15px; line-height: 1.4;"></button>
                <button id="btnDraw" class="btn-secondary"
                    style="font-size: 1.1em; padding: 15px; line-height: 1.4;"></button>
                <button id="btnWinBlack" class="btn-primary"
                    style="font-size: 1.1em; padding: 15px; line-height: 1.4;"></button>
            </div>

            <button class="btn-danger" style="margin-top: 25px;" onclick="closeSimplifiedScoreModal()">
                Annuler
            </button>
        </div>
    </div>
    <div id="playerLogoutConfirmModal" class="modal-overlay" style="z-index: 10002;">
        <div class="modal-content" style="width: 350px;">
            <h2>Quitter le Mode Saisie</h2>
            <p style="margin-bottom: 15px;">Veuillez entrer le mot de passe arbitre pour quitter.</p>
            <div class="control-group">
                <label for="playerLogoutPassInput">Mot de passe :</label>
                <input type="password" id="playerLogoutPassInput">
            </div>
            <div id="playerLogoutError" style="color: #c00; font-weight: 600; margin-top: 10px; display: none;">
                Mot de passe incorrect.
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn-danger" onclick="attemptPlayerLogout()">Confirmer</button>
                <button class="btn-secondary" onclick="closePlayerLogoutConfirm()">Annuler</button>
            </div>
        </div>
    </div>
    <div id="playerLogoutConfirmModal" class="modal-overlay" style="z-index: 10002;">
    </div>

    <div id="bigTimerOverlay">
        <span id="bigTimerDisplay">00:00</span>
    </div>

    <div id="playerTableInfoModal">
        <button id="closePlayerTableInfoBtn">×</button>

        <div class="info-name-container">
            <span id="playerTableInfoName"></span>
        </div>

        <div class="info-table-container">
            Table <span id="playerTableInfoTable"></span>
        </div>

        <div class="info-opponent-block">
            <div class="info-color">
                <span id="playerTableInfoColor"></span>
            </div>
            <div class="info-vs">contre</div>
            <div class="info-opponent-name">
                <span id="playerTableInfoOpponent"></span>
            </div>
        </div>
    </div>

    <script>
        // --- NOUVEAU: Gestion Accordéon ---
        function toggleAccordion(headerElement) {
            const content = headerElement.nextElementSibling;
            const isExpanded = content.classList.contains('expanded');

            // Fermer tous les autres
            document.querySelectorAll('.sidebar-content.expanded').forEach(el => {
                if (el !== content) {
                    el.classList.remove('expanded');
                    el.previousElementSibling.classList.remove('active');
                }
            });

            // Ouvrir/Fermer celui-ci
            if (isExpanded) {
                content.classList.remove('expanded');
                headerElement.classList.remove('active');
            } else {
                content.classList.add('expanded');
                headerElement.classList.add('active');
            }
        }
        // --- Fin Gestion Accordéon ---

        // --- Gestion Multi-Rondes ---
        window.roundsStore = {};
        window.currentRoundKey = 'ronde1';

        // --- Templates de salle (Supprimé) ---
        // const roomTemplates = { ... }; // SUPPRIMÉ

        function getCurrentState() {
            if (!roundsStore[currentRoundKey]) {
                roundsStore[currentRoundKey] = {
                    physicalTables: [],
                    rooms: [],
                    nextPhysicalTableId: 1,
                    nextRoomId: 1,
                    nextBoardNumber: 1,
                    historyStack: [],
                    redoStack: [],
                    timerState: { mode: 'stop', targetTime: 0, hidden: false } // <-- MODIFIÉ
                };
            }
            // Compatibilité anciens fichiers
            if (!roundsStore[currentRoundKey].timerState) {
                roundsStore[currentRoundKey].timerState = { mode: 'stop', targetTime: 0, hidden: false }; // <-- MODIFIÉ
            }
            // NOUVEAU: Compatibilité pour la propriété 'hidden'
            if (roundsStore[currentRoundKey].timerState.hidden === undefined) {
                roundsStore[currentRoundKey].timerState.hidden = false;
            }
            // Assurer la compatibilité avec les anciens sauvegardes
            if (!roundsStore[currentRoundKey].rooms) {
                roundsStore[currentRoundKey].rooms = [];
            }
            if (!roundsStore[currentRoundKey].nextRoomId) {
                roundsStore[currentRoundKey].nextRoomId = 1;
            }
            return roundsStore[currentRoundKey];
        }

        // Variables globales pour l'état ACTIF
        let physicalTables = [];
        let rooms = [];
        let nextPhysicalTableId = 1;
        let nextRoomId = 1;
        let nextBoardNumber = 1;
        let historyStack = [];
        let redoStack = [];

        // --- Gestion du Timer ---
        let timerInterval = null;
        let timerTargetTime = 0;
        let timerMode = 'stop';
        let timerStartTime = 0; // NOUVEAU: Pour le mode 'countup'

        let selectedTables = [];
        let currentTool = 'select';
        let isDragging = false;
        let isResizing = false;
        let dragContext = {};
        let canvasDrag = { active: false, startX: 0, startY: 0, scrollLeft: 0, scrollTop: 0 };
        let selectionBox = { active: false, startX: 0, startY: 0, element: null };
        let currentZoom = 1;
        let defaultTableWidth = 200;
        let lastTablePosition = { x: 100, y: 100 };

        let isUndoRedoing = false;
        let movingBoard = null;
        let bigTimerUserHidden = false;

        const CANVAS_WIDTH = 3000;
        const CANVAS_HEIGHT = 2000;
        const START_MARGIN = 100;

        // --- Sauvegarde Auto LocalStorage ---
        window.SAVE_KEY = 'chessRoomManagerSave';
        window.SAVE_KEY_TIMESTAMP = 'chessRoomManagerSaveTimestamp';
        window.SERVER_URL = 'save.php';
        window.USE_SERVER_SYNC = true;
        // NOUVEAU: Clé pour mémoriser la stratégie
        const STRATEGY_KEY = 'chessRoomSaveStrategy';

        // === NOUVEAU SYSTÈME DE SAUVEGARDE ===
        window.currentSaveMode = 'arbiter'; // 'arbiter' ou 'spectator'
        window.localSaveInterval = null;
        window.serverSyncInterval = null;
        window.lastServerTimestamp = 0;
        window.lastLocalSaveTime = 0;

        // ========================================
        // SYNCHRONISATION SERVEUR
        // ========================================
        // Les fonctions de sauvegarde sont maintenant dans chessroom-save-system.js
        // - saveToLocalStorage()
        // - saveToServer()
        // - loadFromServer()
        // - syncFromServerIfNeeded()
        // - Gestion de l'historique
        // - Interface utilisateur de contrôle

        function autoSaveToLocalStorage() {
            try {
                saveCurrentStateToStore();

                const dataToSave = {
                    roundsStore: JSON.parse(JSON.stringify(roundsStore)),
                    currentRoundKey: currentRoundKey,
                    arbiterPassword: arbiterPassword
                };

                Object.values(dataToSave.roundsStore).forEach(roundState => {
                    if (roundState.physicalTables) {
                        roundState.physicalTables.forEach(t => {
                            delete t.mouseDownHandler;
                        });
                    }
                });

                const json = JSON.stringify(dataToSave);
                localStorage.setItem(SAVE_KEY, json);
                localStorage.setItem(SAVE_KEY_TIMESTAMP, Date.now().toString());

            } catch (error) {
                console.error("Erreur lors de la sauvegarde auto:", error);
                if (error.name === 'QuotaExceededError') {
                    alert("Erreur: Impossible de sauvegarder. La mémoire cache du navigateur est pleine.");
                }
            }
        }

        function loadFromLocalStorage() {
            const savedData = localStorage.getItem(SAVE_KEY);
            const savedTimestamp = localStorage.getItem(SAVE_KEY_TIMESTAMP);

            if (!savedData || !savedTimestamp) {
                return false; // Pas de sauvegarde
            }

            try {
                const data = JSON.parse(savedData);

                // NOUVEAU: Formatage de la date
                const timestampStr = new Date(parseInt(savedTimestamp)).toLocaleString('fr-FR', {
                    day: 'numeric', month: 'long', hour: '2-digit', minute: '2-digit'
                });

                // MODIFIÉ: Afficher le confirm() avec la date
                if (data && data.roundsStore && typeof data.roundsStore === 'object' && !Array.isArray(data.roundsStore) && Object.keys(data.roundsStore).length > 0 && confirm(`Une sauvegarde automatique du ${timestampStr} a été trouvée. Voulez-vous la charger ?`)) {
                    roundsStore = data.roundsStore;
                    currentRoundKey = data.currentRoundKey || 'ronde1';
                    arbiterPassword = data.arbiterPassword || null; // NOUVEAU: Charger le mot de passe

                    // Migration (identique à loadLayout)
                    Object.values(roundsStore).forEach(roundState => {
                        if (!roundState.physicalTables) roundState.physicalTables = [];
                        if (!roundState.rooms) roundState.rooms = [];
                        if (!roundState.nextRoomId) roundState.nextRoomId = 1;
                        roundState.physicalTables.forEach(pt => {
                            if (!pt.arbiterComment) pt.arbiterComment = { text: "", flag: "none" };
                            pt.boards.forEach(b => {
                                if (b.score === undefined) b.score = { white: "", black: "" };
                                // Correction migration
                                if (b.players && b.players.white && typeof b.players.white === 'string') {
                                    b.players = {
                                        white: { name: b.players.white, elo: (b.players.white_elo || ""), comment: "" },
                                        black: { name: b.players.black, elo: (b.players.black_elo || ""), comment: "" }
                                    };
                                } else if (b.players) {
                                    if (b.players.white && !b.players.white.elo) b.players.white.elo = "";
                                    if (b.players.white && !b.players.white.comment) b.players.white.comment = "";
                                    if (b.players.black && !b.players.black.elo) b.players.black.elo = "";
                                    if (b.players.black && !b.players.black.comment) b.players.black.comment = "";
                                }
                            });
                        });
                        if (!roundState.historyStack) roundState.historyStack = [];
                        if (!roundState.redoStack) roundState.redoStack = [];
                    });

                    updateRoundSelector();
                    loadStateFromStore(currentRoundKey);

                    showNotification('Sauvegarde automatique chargée !', 'success');
                    return true; // Chargement réussi
                }
                return false; // L'utilisateur a refusé
            } catch (error) {
                console.error("Erreur chargement localStorage:", error);
                localStorage.removeItem(SAVE_KEY); // Supprimer la sauvegarde corrompue
                localStorage.removeItem(SAVE_KEY_TIMESTAMP);
                return false;
            }
        }


        // --- Gestion Multi-Rondes ---
        function saveCurrentStateToStore() {
            let state = getCurrentState();
            state.physicalTables = JSON.parse(JSON.stringify(physicalTables));
            state.rooms = JSON.parse(JSON.stringify(rooms));
            state.nextPhysicalTableId = nextPhysicalTableId;
            state.nextRoomId = nextRoomId;
            state.nextBoardNumber = nextBoardNumber;
            state.historyStack = JSON.parse(JSON.stringify(historyStack));
            state.redoStack = JSON.parse(JSON.stringify(redoStack));

            // NOUVEAU: Sauvegarder l'état du minuteur
            state.timerState = {
                mode: timerMode,
                targetTime: timerTargetTime,
                hidden: bigTimerUserHidden, // <-- NOUVELLE LIGNE
                startTime: timerStartTime // NOUVEAU: Sauvegarder le startTime
            };
        }

        function loadStateFromStore(key) {
            currentRoundKey = key;
            const state = getCurrentState();

            physicalTables = JSON.parse(JSON.stringify(state.physicalTables));
            rooms = JSON.parse(JSON.stringify(state.rooms));
            nextPhysicalTableId = state.nextPhysicalTableId;
            nextRoomId = state.nextRoomId;
            nextBoardNumber = state.nextBoardNumber;
            historyStack = JSON.parse(JSON.stringify(historyStack));
            redoStack = JSON.parse(JSON.stringify(redoStack));

            // Gestion du Timer
            clearInterval(timerInterval);
            timerInterval = null;

            const savedTimerState = state.timerState || { mode: 'stop', targetTime: 0, hidden: false, startTime: 0 };
            timerMode = savedTimerState.mode;
            timerTargetTime = savedTimerState.targetTime;
            bigTimerUserHidden = savedTimerState.hidden;
            timerStartTime = savedTimerState.startTime || 0;

            // Mise à jour icône timer
            const btn = document.getElementById('toggleBigTimerBtn');
            if (btn) {
                btn.innerHTML = bigTimerUserHidden ? '👁️‍🗨️' : '👁️';
                btn.style.display = (timerMode !== 'stop') ? 'inline-block' : 'none';
            }

            if (timerMode !== 'stop') {
                timerInterval = setInterval(updateTimer, 500);
            }
            updateTimer();

            renderAllTables();
            // renderAllTables(); // Doublon supprimé
            renderAllRooms();
            updateStats();
            updateHistoryButtons();

            if (typeof updateSpectatorPlayerList === 'function') {
                updateSpectatorPlayerList();
            }

            // CES LIGNES DOIVENT ÊTRE DANS LA FONCTION (AVANT L'ACCOLADE FERMANTE)
            if (document.getElementById('roundSelector')) {
                document.getElementById('roundSelector').value = key;
            }
            const roundName = key.replace('r', 'R');
            if (document.getElementById('playerModeRound')) {
                document.getElementById('playerModeRound').textContent = roundName;
            }
        }

        function updateRoundSelector() {
            const selector = document.getElementById('roundSelector');
            if (!selector) return;
            selector.innerHTML = '';
            // S'assurer qu'il y a au moins une ronde
            if (Object.keys(roundsStore).length === 0) {
                roundsStore['ronde1'] = {
                    physicalTables: [], rooms: [], nextPhysicalTableId: 1, nextRoomId: 1,
                    nextBoardNumber: 1, historyStack: [], redoStack: []
                };
                currentRoundKey = 'ronde1';
            }
            Object.keys(roundsStore).forEach((key, index) => {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = key.replace('r', 'R');
                selector.appendChild(option);
            });
            selector.value = currentRoundKey;
        }

        function switchRound(key) {
            if (key === currentRoundKey) return;
            saveCurrentStateToStore();
            loadStateFromStore(key);
            autoSaveToLocalStorage();
        }

        function addNewRound() {
            saveCurrentStateToStore();
            const newKey = `ronde${Object.keys(roundsStore).length + 1}`;
            currentRoundKey = newKey;

            roundsStore[newKey] = {
                physicalTables: [],
                rooms: [],
                nextPhysicalTableId: 1,
                nextRoomId: 1,
                nextBoardNumber: 1,
                historyStack: [],
                redoStack: []
            };

            loadStateFromStore(newKey);
            updateRoundSelector();

            // CORRECTION: Sauvegarder l'état vide
            saveHistoryState();
        }

        function cloneRoundLayout() {
            saveCurrentStateToStore();

            const newLayout = JSON.parse(JSON.stringify(physicalTables));
            newLayout.forEach(pt => {
                pt.boards.forEach(b => {
                    // Initialiser avec des joueurs vides (Table Verte)
                    b.players = {
                        white: { name: "", elo: "", comment: "" },
                        black: { name: "", elo: "", comment: "" }
                    };
                });
            });

            const newRooms = JSON.parse(JSON.stringify(rooms));

            const newKey = `ronde${Object.keys(roundsStore).length + 1}`;
            currentRoundKey = newKey;

            roundsStore[newKey] = {
                physicalTables: newLayout,
                rooms: newRooms,
                nextPhysicalTableId: nextPhysicalTableId,
                nextRoomId: nextRoomId,
                nextBoardNumber: nextBoardNumber,
                historyStack: [],
                redoStack: []
            };

            loadStateFromStore(newKey);
            updateRoundSelector();

            // CORRECTION: Sauvegarder l'état cloné
            saveHistoryState();
        }


        // --- Fonctions du Timer ---
        function startRoundTimer() {
            clearInterval(timerInterval);

            // NOUVEAU: Réinitialiser l'état masqué
            bigTimerUserHidden = false;
            const btn = document.getElementById('toggleBigTimerBtn');
            if (btn) btn.innerHTML = '👁️';

            const minutes = parseInt(document.getElementById('timerMinutes').value) || 0;

            if (minutes > 0) {
                // CAS 1: DÉCOMPTE (Ex: 15)
                // AFFICHE le grand minuteur
                document.getElementById('bigTimerOverlay').style.display = 'flex';
                timerTargetTime = Date.now() + (minutes * 60 * 1000);
                timerMode = 'countdown'; // MODIFIÉ: Nouveau mode 'countdown'
            } else {
                // CAS 2: COMPTEUR (Ex: 0 ou -5)
                // N'affiche PAS le grand minuteur
                document.getElementById('bigTimerOverlay').style.display = 'none';
                timerStartTime = Date.now(); // NOUVEAU: Enregistrer le début du compte à rebours
                timerMode = 'countup'; // MODIFIÉ: Nouveau mode 'countup'
            }

            // Afficher le bouton toggle
            const btnToggle = document.getElementById('toggleBigTimerBtn');
            if (btnToggle) btnToggle.style.display = 'inline-block';

            updateTimer(); // Met à jour l'affichage immédiatement
            timerInterval = setInterval(updateTimer, 500);
            saveHistoryState(); // <-- NOUVEAU: Déclencher la synchronisation
        }
        // NOUVELLE FONCTION POUR MASQUER LE CHRONO PLEIN ÉCRAN
        function toggleBigTimer() {
            bigTimerUserHidden = !bigTimerUserHidden; // Inverse l'état

            // Met à jour l'icône du bouton
            const btn = document.getElementById('toggleBigTimerBtn');
            if (btn) {
                // 👁️‍🗨️ est l'icône "œil barré"
                btn.innerHTML = bigTimerUserHidden ? '👁️‍🗨️' : '👁️';
            }

            // Applique le changement d'affichage immédiatement
            // Afficher le bouton toggle
            const btnToggle = document.getElementById('toggleBigTimerBtn');
            if (btnToggle) btnToggle.style.display = 'inline-block';

            updateTimer();
            saveHistoryState();
        }
        // CORRECTION: CETTE FONCTION ÉTAIT MANQUANTE
        function stopRoundTimer() {
            clearInterval(timerInterval); // <-- LIGNE AJOUTÉE
            timerInterval = null;         // <-- LIGNE AJOUTÉE
            timerMode = 'stop';
            timerTargetTime = 0; // NOUVEAU: Réinitialiser
            bigTimerUserHidden = false; // NOUVEAU: Réinitialiser
            timerStartTime = 0; // NOUVEAU: Réinitialiser

            const timerDisplay = document.getElementById('roundTimer');
            timerDisplay.textContent = '00:00';
            timerDisplay.className = '';
            // Cacher le bouton toggle
            const btn = document.getElementById('toggleBigTimerBtn');
            if (btn) {
                btn.innerHTML = '👁️';
                btn.style.display = 'none';
            }
            saveHistoryState(); // <-- NOUVEAU: Déclencher la synchronisation

            // CACHE et réinitialise le grand minuteur (comme demandé)
            document.getElementById('bigTimerOverlay').style.display = 'none';
            document.getElementById('bigTimerDisplay').textContent = '00:00';
        }

        function updateTimer() {
            const timerDisplay = document.getElementById('roundTimer');
            const bigTimerDisplay = document.getElementById('bigTimerDisplay');
            const bigTimerOverlay = document.getElementById('bigTimerOverlay'); // <-- NOUVEAU: Récupérer l'overlay
            const now = Date.now();

            // --- NOUVEAU BLOC AJOUTÉ ---
            // Gérer le cas 'stop' explicitement pour forcer l'arrêt
            if (timerMode === 'stop') {
                clearInterval(timerInterval);
                timerInterval = null;
                timerDisplay.textContent = '00:00';
                timerDisplay.className = '';
                bigTimerOverlay.style.display = 'none';
                bigTimerDisplay.textContent = '00:00';
                return; // Fin
            }
            // --- FIN DU NOUVEAU BLOC ---

            if (timerMode === 'countdown') { // MODIFIÉ: Utiliser 'countdown'
                let remainingMs = timerTargetTime - now;

                if (remainingMs <= 0) {
                    // --- MODIFICATION: Passer automatiquement en AJOUT DE TEMPS ---
                    timerMode = 'countup';
                    // On définit le start time pour que ça commence à 0
                    timerStartTime = now;
                    timerDisplay.className = 'timer-elapsed'; // Rouge
                    timerDisplay.textContent = "00:00";
                    if (bigTimerDisplay) {
                        bigTimerDisplay.textContent = "00:00";
                        bigTimerDisplay.style.color = "#ff4444";
                    }
                    return; // On laisse le prochain cycle faire l'affichage
                }

                const seconds = Math.floor((remainingMs / 1000) % 60);
                const minutes = Math.floor((remainingMs / 1000 / 60) % 60);
                const newTime = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                timerDisplay.textContent = newTime;
                bigTimerDisplay.textContent = newTime;
                timerDisplay.className = 'timer-countdown';

                // --- NOUVELLE LOGIQUE DE MASQUAGE ---
                if (bigTimerUserHidden) {
                    bigTimerOverlay.style.display = 'none';
                } else {
                    bigTimerOverlay.style.display = 'flex';
                }
                // --- FIN ---

            } else if (timerMode === 'countup') { // MODIFIÉ: Utiliser 'countup'
                // NOUVEAU: S'assurer qu'il est aussi caché si on compte vers le haut
                bigTimerOverlay.style.display = 'none';

                let elapsedMs = now - timerStartTime; // MODIFIÉ: Utiliser timerStartTime
                // ... (le reste de la logique 'up')

                // CORRECTION: Les calculs étaient manquants
                const totalSeconds = Math.floor(elapsedMs / 1000);
                const seconds = totalSeconds % 60;
                const totalMinutes = Math.floor(totalSeconds / 60);
                const minutes = totalMinutes % 60;
                const hours = Math.floor(totalMinutes / 60);

                let newTime = '';
                if (hours > 0) {
                    newTime = `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                } else {
                    newTime = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }
                timerDisplay.textContent = newTime;
                timerDisplay.className = 'timer-elapsed'; // Style rouge
            }
        }


        // --- Template (Supprimé) ---
        function applyTemplate(templateName) {
            // SUPPRIMÉ
            alert("Cette fonctionnalité a été retirée.");
        }
        // --- Fonctions d'historique (Modifiées pour le store) ---
        function saveHistoryState() {
            if (isUndoRedoing) return;
            const state = {
                physicalTables: JSON.parse(JSON.stringify(physicalTables)),
                rooms: JSON.parse(JSON.stringify(rooms)),
                nextPhysicalTableId: nextPhysicalTableId,
                nextRoomId: nextRoomId,
                nextBoardNumber: nextBoardNumber,
                timerState: { // NOUVEAU: Sauvegarder l'état du minuteur dans l'historique
                    mode: timerMode,
                    targetTime: timerTargetTime,
                    hidden: bigTimerUserHidden,
                    startTime: timerStartTime
                }
            };
            historyStack.push(state);
            redoStack = [];
            if (historyStack.length > 50) {
                historyStack.shift();
            }
            updateHistoryButtons();
            autoSaveToLocalStorage();

            // NOUVEAU: Déclencher la sauvegarde serveur (si activée)
            // CORRECTION: C'est le SEUL endroit où onResultSaved() doit être appelé.
            if (window.ChessRoomSave) window.ChessRoomSave.onResultSaved();
        }
        function restoreState(state) {
            isUndoRedoing = true;
            physicalTables = JSON.parse(JSON.stringify(state.physicalTables));
            rooms = state.rooms ? JSON.parse(JSON.stringify(state.rooms)) : [];
            nextPhysicalTableId = state.nextPhysicalTableId;
            nextRoomId = state.nextRoomId || 1;
            nextBoardNumber = state.nextBoardNumber;

            // NOUVEAU: Restaurer l'état du minuteur
            const savedTimerState = state.timerState || { mode: 'stop', targetTime: 0, hidden: false, startTime: 0 };
            timerMode = savedTimerState.mode;
            timerTargetTime = savedTimerState.targetTime;
            bigTimerUserHidden = savedTimerState.hidden;
            timerStartTime = savedTimerState.startTime;

            clearInterval(timerInterval);
            timerInterval = null;
            if (timerMode !== 'stop') {
                timerInterval = setInterval(updateTimer, 500);
            }
            updateTimer(); // Mettre à jour l'affichage immédiatement

            // Mettre à jour l'icône et la visibilité du bouton toggle
            const btn = document.getElementById('toggleBigTimerBtn');
            if (btn) {
                btn.innerHTML = bigTimerUserHidden ? '👁️‍🗨️' : '👁️';
                btn.style.display = (timerMode !== 'stop') ? 'inline-block' : 'none';
            }


            renderAllTables();
            renderAllRooms();
            updateStats();
            clearSelection();
            isUndoRedoing = false;
        }
        function undo() {
            if (historyStack.length < 2) return;
            const currentState = historyStack.pop();
            redoStack.push(currentState);
            const prevState = historyStack[historyStack.length - 1];
            restoreState(prevState);
            updateHistoryButtons();
            autoSaveToLocalStorage();
        }
        function redo() {
            if (redoStack.length === 0) return;
            const nextState = redoStack.pop();
            historyStack.push(nextState);
            restoreState(nextState);
            updateHistoryButtons();
            autoSaveToLocalStorage();
        }
        function updateHistoryButtons() {
            document.getElementById('undoButton').disabled = historyStack.length < 2;
            document.getElementById('redoButton').disabled = redoStack.length === 0;
        }

        // --- Toggle Sidebar ---
        function toggleSidebar() {
            const mainContent = document.querySelector('.main-content');
            const btn = document.getElementById('sidebarToggle');
            mainContent.classList.toggle('sidebar-collapsed');
            if (mainContent.classList.contains('sidebar-collapsed')) {
                btn.innerHTML = '»';
            } else {
                btn.innerHTML = '«';
            }
        }

        // --- Fonctions Utilitaires ---
        function findBoard(boardNum) {
            const searchKey = boardNum.toString();
            for (const physicalTable of physicalTables) {
                const board = physicalTable.boards.find(b => b.boardNumber.toString() === searchKey);
                if (board) {
                    return { board, physicalTable };
                }
            }
            return { board: null, physicalTable: null };
        }

        // --- Format des Noms (NOM Prénom) ---
        function formatPlayerName(fullName) {
            if (!fullName) return '';
            const parts = fullName.trim().split(/\s+/);
            const lastName = parts.pop() || '';
            const firstName = parts.join(' ');
            return `<strong class="lastname">${lastName.toUpperCase()}</strong> ${firstName}`;
        }

        // NOUVEAU: Obtenir le nom simple
        function getSimplePlayerName(fullName) {
            if (!fullName) return 'N/A';
            const parts = fullName.trim().split(/\s+/);
            const lastName = parts.pop() || '';
            const firstName = parts.join(' ');
            return `${firstName} ${lastName.toUpperCase()}`;
        }


        function getLayoutConfig() {
            const corner = document.getElementById('startCorner').value;
            const physicalTablesPerRow = parseInt(document.getElementById('physicalTablesPerRow').value) || 10;
            const tableLengthCm = parseInt(document.getElementById('tableLength').value) || 180;

            const boardsPerTable = parseInt(document.getElementById('boardsPerTable').value) || 1;

            const minWidthPerBoard = 150;
            const estimatedTableWidth = Math.max(tableLengthCm * 1.2, minWidthPerBoard * boardsPerTable);
            const estimatedRowWidth = (estimatedTableWidth + 30) * physicalTablesPerRow - 30;
            const estimatedTableHeight = 160;

            switch (corner) {
                case 'tr':
                    return {
                        startX: CANVAS_WIDTH - START_MARGIN,
                        startY: START_MARGIN,
                        xDir: -1,
                        yDir: 1
                    };
                case 'bl':
                    return {
                        startX: START_MARGIN,
                        startY: CANVAS_HEIGHT - START_MARGIN - estimatedTableHeight,
                        xDir: 1,
                        yDir: -1
                    };
                case 'br':
                    return {
                        startX: CANVAS_WIDTH - START_MARGIN,
                        startY: CANVAS_HEIGHT - START_MARGIN - estimatedTableHeight,
                        xDir: -1,
                        yDir: -1
                    };
                case 'tl':
                default:
                    return {
                        startX: START_MARGIN,
                        startY: START_MARGIN,
                        xDir: 1,
                        yDir: 1
                    };
            }
        }


        // --- NOUVEAU: Ajout Salle Prédéfinie ---
        function addPredefinedRoom(type) {
            let name = "Nouvelle Salle";
            let color = "#e0e0e0";
            let width = 200;
            let height = 150;

            switch (type) {
                case 'arbitrage':
                    name = "Table d'Arbitrage";
                    color = "#ffcdd2"; // Rouge clair
                    break;
                case 'toilettes':
                    name = "Toilettes";
                    color = "#bbdefb"; // Bleu clair
                    width = 120;
                    height = 100;
                    break;
                case 'buvette':
                    name = "Buvette";
                    color = "#ffe0b2"; // Orange clair
                    break;
                case 'analyse':
                    name = "Salle d'Analyse";
                    color = "#c8e6c9"; // Vert clair
                    break;
            }

            const room = {
                id: nextRoomId++,
                name: name,
                x: lastTablePosition.x + 50,
                y: lastTablePosition.y + 50,
                width: width,
                height: height,
                color: color
            };

            rooms.push(room);
            renderAllRooms();
            saveHistoryState();
            showNotification(`Zone "${name}" ajoutée`, 'success');
        }

        // --- Gestion des Outils ---
        function setTool(tool) {
            // NOUVEAU: Ne pas changer d'outil en mode joueur
            if (isPlayerMode && !document.body.classList.contains('player-plan-view-mode')) return;

            currentTool = tool;
            const canvas = document.getElementById('canvas');

            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(tool + 'Tool').classList.add('active');

            canvas.classList.remove('move-mode', 'moveboard-mode');

            if (tool === 'pan') {
                canvas.classList.add('move-mode');
                canvas.style.cursor = 'grab';
            } else if (tool === 'multiselect') {
                canvas.style.cursor = 'crosshair';
            } else if (tool === 'moveboard') {
                canvas.classList.add('moveboard-mode');
                canvas.style.cursor = 'default';
            } else {
                canvas.style.cursor = 'default';
            }
        }

        // --- Création/Disposition des Tables ---
        function addBoards() {
            // CORRECTION: Sauvegarde APRÈS modification
            try {
                const boardCount = parseInt(document.getElementById('boardCount').value);
                const boardsPerTable = parseInt(document.getElementById('boardsPerTable').value) || 1;
                const physicalTablesPerRow = parseInt(document.getElementById('physicalTablesPerRow').value) || 10;
                const tableLengthCm = parseInt(document.getElementById('tableLength').value) || 180;

                const minWidthPerBoard = 150;

                if (!boardCount || boardCount < 1 || boardCount > 2000) {
                    alert('Veuillez saisir un nombre d\'échiquiers entre 1 et 2000');
                    return;
                }

                const physicalTableCount = Math.ceil(boardCount / boardsPerTable);
                const spacingY = 160;
                const newTables = [];

                let currentX, currentY, currentCol, xDir, yDir;

                if (physicalTables.length === 0) {
                    nextBoardNumber = 1;      // On repart à l'échiquier 1
                    nextPhysicalTableId = 1;  // On repart à l'ID interne 1
                    // ==============================

                    let layout = getLayoutConfig();
                    currentX = layout.startX;
                    currentY = layout.startY;
                    xDir = layout.xDir;
                    yDir = layout.yDir;
                    currentCol = 0;
                } else {
                    xDir = 1; yDir = 1;
                    const totalExistingTables = physicalTables.length;
                    const lastCompleteRow = Math.floor((totalExistingTables - 1) / physicalTablesPerRow);
                    const lastCol = (totalExistingTables - 1) % physicalTablesPerRow;

                    if (lastCol === physicalTablesPerRow - 1) {
                        currentX = START_MARGIN;
                        currentY = START_MARGIN + ((lastCompleteRow + 1) * spacingY);
                        currentCol = 0;
                    } else {
                        const lastTableInRow = physicalTables.find(t => t.y === (START_MARGIN + (lastCompleteRow * spacingY)) && (physicalTables.indexOf(t) % physicalTablesPerRow === lastCol));
                        const lastTableWidth = lastTableInRow ? (lastTableInRow.width || defaultTableWidth) : defaultTableWidth;

                        currentX = (lastTableInRow ? lastTableInRow.x : START_MARGIN) + lastTableWidth + 30;
                        currentY = START_MARGIN + (lastCompleteRow * spacingY);
                        currentCol = lastCol + 1;
                    }
                }

                let currentBoardCount = physicalTables.reduce((acc, p) => acc + p.boards.length, 0);
                const totalBoardTarget = boardCount + currentBoardCount;

                for (let i = 0; i < physicalTableCount; i++) {
                    const col = (currentCol + i) % physicalTablesPerRow;

                    if (col === 0 && i > 0) {
                        currentX = (physicalTables.length === 0) ? getLayoutConfig().startX : START_MARGIN;
                        currentY += spacingY * yDir;
                    }

                    const actualBoardsForThisTable = Math.min(boardsPerTable, totalBoardTarget - currentBoardCount);
                    if (actualBoardsForThisTable <= 0) break;

                    const tableWidth = Math.max(tableLengthCm * 1.2, minWidthPerBoard * actualBoardsForThisTable);

                    const tableX = (xDir === 1) ? currentX : currentX - tableWidth;
                    const tableY = (yDir === 1) ? currentY : currentY;

                    const physicalTable = {
                        id: nextPhysicalTableId++,
                        x: tableX,
                        y: tableY,
                        rotation: 0,
                        width: tableWidth,
                        arbiterComment: { text: "", flag: "none" },
                        boards: []
                    };

                    for (let j = 0; j < actualBoardsForThisTable; j++) {
                        physicalTable.boards.push({
                            boardNumber: nextBoardNumber++,
                            // CORRECTION: Initialiser avec des joueurs vides (Table Verte)
                            players: {
                                white: { name: "", elo: "", comment: "" },
                                black: { name: "", elo: "", comment: "" }
                            },
                            flipped: false,
                            score: { white: "", black: "" }
                        });
                        currentBoardCount++;
                    }

                    if (physicalTable.boards.length > 0) {
                        physicalTables.push(physicalTable);
                        newTables.push(physicalTable);
                        createTableElement(physicalTable);
                        lastTablePosition = { x: tableX, y: tableY };
                        currentX += (tableWidth + 30) * xDir;
                    }
                }
                updateStats();

                if (newTables.length > 0) {
                    saveHistoryState(); // Sauvegarder APRÈS que les tables ont été ajoutées
                    setTimeout(() => centerViewOnTables(newTables), 100);
                }

            } catch (error) {
                console.error('Error in addBoards:', error);
                alert('Une erreur est survenue: ' + error.message);
            }
        }

        function centerViewOnTables(tablesToCenter) {
            if (tablesToCenter.length === 0) return;
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            tablesToCenter.forEach(pTable => {
                minX = Math.min(minX, pTable.x);
                minY = Math.min(minY, pTable.y);
                maxX = Math.max(maxX, pTable.x + (pTable.width || 200));
                maxY = Math.max(maxY, pTable.y + 160);
            });
            const margin = 100;
            minX -= margin; minY -= margin; maxX += margin; maxY += margin;
            const centerX = (minX + maxX) / 2; const centerY = (minY + maxY) / 2;
            const container = document.getElementById('canvasContainer');
            const containerWidth = container.clientWidth; const containerHeight = container.clientHeight;
            const contentWidth = maxX - minX; const contentHeight = maxY - minY;
            const zoomX = containerWidth / contentWidth; const zoomY = containerHeight / contentHeight;
            const suggestedZoom = Math.min(zoomX, zoomY, 1) * 0.9;
            if (suggestedZoom < currentZoom) {
                applyZoom(Math.max(0.1, suggestedZoom));
            }
            container.scrollLeft = (centerX * currentZoom) - containerWidth / 2;
            container.scrollTop = (centerY * currentZoom) - containerHeight / 2;
        }

        function createTableElement(physicalTable) {
            try {
                const canvas = document.getElementById('canvas');
                if (!canvas) return;

                const element = document.createElement('div');
                element.className = `table-element rotate-${physicalTable.rotation}`;
                element.id = `phys-table-${physicalTable.id}`;
                element.style.left = physicalTable.x + 'px';
                element.style.top = physicalTable.y + 'px';
                element.style.width = (physicalTable.width || defaultTableWidth) + 'px';
                element.style.setProperty('--rotation', `${physicalTable.rotation}deg`);
                element.dataset.tableId = physicalTable.id;

                const contentInner = document.createElement('div');
                contentInner.className = 'table-content-inner';

                element.prepend(contentInner);

                element.innerHTML += `
                    <div class="delete-btn" onclick="event.stopPropagation(); deleteTable(${physicalTable.id})">×</div>
                    <div class="rotate-btn" onclick="event.stopPropagation(); rotateTable(${physicalTable.id})">↻</div>
                    <div class="resize-handle handle-left" onmousedown="event.stopPropagation(); startResize(event, ${physicalTable.id}, 'left')">⬌</div>
                    <div class="resize-handle handle-right" onmousedown="event.stopPropagation(); startResize(event, ${physicalTable.id}, 'right')">⬌</div>
                `;

                updateTableDisplay(physicalTable.id, element);

                physicalTable.mouseDownHandler = (e) => handleTableMouseDown(e, physicalTable.id);
                element.addEventListener('mousedown', physicalTable.mouseDownHandler);
                element.addEventListener('click', (e) => {
                    // NOUVEAU: Désactivé en mode joueur
                    if (isPlayerMode) return;
                    if (e.target.classList.contains('player-name')) element.classList.toggle('expanded');
                });

                canvas.appendChild(element);
            } catch (error) { console.error('Error in createTableElement:', error); }
        }

        // --- Drag/Drop Échiquier ---
        function startMoveBoard(e, boardNumber, tableId) {
            if (isDragging || movingBoard) return;
            isDragging = true;

            const { board } = findBoard(boardNumber);
            if (!board) return;

            const sourceElement = e.currentTarget;

            const ghost = sourceElement.cloneNode(true);
            ghost.id = 'ghost';
            ghost.style.position = 'absolute';
            ghost.style.opacity = '0.7';
            ghost.style.zIndex = '2000';
            ghost.style.width = sourceElement.offsetWidth + 'px';
            document.body.appendChild(ghost);

            movingBoard = {
                boardNumber,
                originalTableId: tableId,
                element: ghost,
                offsetX: e.offsetX,
                offsetY: e.offsetY
            };

            moveGhost(e);

            document.querySelectorAll('.table-element').forEach(tableEl => {
                tableEl.addEventListener('mouseenter', handleTableDropEnter);
                tableEl.addEventListener('mouseleave', handleTableDropLeave);
            });
        }

        function moveGhost(e) {
            if (!movingBoard) return;
            movingBoard.element.style.left = (e.clientX - movingBoard.offsetX) + 'px';
            movingBoard.element.style.top = (e.clientY - movingBoard.offsetY) + 'px';
        }

        function handleTableDropEnter(e) {
            if (!movingBoard) return;
            e.currentTarget.classList.add('selected');
        }

        function handleTableDropLeave(e) {
            if (!movingBoard) return;
            const tableId = parseInt(e.currentTarget.dataset.tableId);
            if (!selectedTables.includes(tableId)) {
                e.currentTarget.classList.remove('selected');
            }
        }


        // --- Modification des Éléments ---

        // Commentaire Arbitre (Échiquier)
        function editArbiterComment(boardNum) {
            const { board, physicalTable } = findBoard(boardNum);
            if (!board) return;

            if (!board.arbiterComment) {
                board.arbiterComment = { text: "", flag: "none" };
            }

            const currentText = board.arbiterComment.text || '';
            const newText = prompt(`Ajouter/modifier le commentaire arbitre pour l'échiquier ${boardNum}:`, currentText);

            if (newText !== null) {
                const currentFlag = board.arbiterComment.flag || 'none';
                const newFlag = prompt("Couleur du drapeau (none, red, yellow, green):", currentFlag);

                // CORRECTION: Modifier AVANT de sauvegarder
                board.arbiterComment.text = newText.trim();
                board.arbiterComment.flag = newFlag ? newFlag.trim().toLowerCase() : 'none';

                updateTableDisplay(physicalTable.id);
                saveHistoryState();
            }
        }

        function editPlayerComment(boardNum, color) {
            if (isPlayerMode) return;

            const { board, physicalTable } = findBoard(boardNum);
            if (!board || !board.players) return;

            const player = board.players[color];
            const currentValue = player.comment || '';
            const newValue = prompt(`Ajouter/modifier le commentaire pour ${player.name}:`, currentValue);

            if (newValue !== null) {
                // CORRECTION: Modifier AVANT de sauvegarder
                player.comment = newValue.trim();
                updateTableDisplay(physicalTable.id);

                saveHistoryState();
            }
        }

        // --- Saisie de score par Modale ---
        function editScore(boardNum) {
            // NOUVEAU: Si on est en mode joueur, utiliser la modale simplifiée
            if (isPlayerMode) {
                const { board, physicalTable } = findBoard(boardNum);
                // NOUVEAU: Vérifier si le score est déjà saisi
                if (board && (board.score.white !== '' || board.score.black !== '')) {
                    showNotification("Ce résultat a déjà été saisi.", "info");
                    return;
                }
                if (board && board.players) {
                    showSimplifiedScoreModal(board, physicalTable);
                }
                return;
            }

            // Logique arbitre (modale complète)
            const { board } = findBoard(boardNum);
            if (!board) return;
            showScoreModal(boardNum);
        }

        function showScoreModal(boardNum) {
            const { board } = findBoard(boardNum);
            if (!board) return;

            const modal = document.getElementById('scoreModal');
            const select = document.getElementById('scoreModalSelect');
            const boardNumEl = document.getElementById('scoreModalBoardNum');

            boardNumEl.textContent = boardNum;
            modal.dataset.boardNum = boardNum;

            let currentValue = "";
            if (board.score.white && board.score.black) {
                // Gérer le cas 1/2-1/2
                if (board.score.white === "1/2" && board.score.black === "1/2") {
                    currentValue = "1/2-1/2";
                } else {
                    currentValue = `${board.score.white}-${board.score.black}`;
                }
            }

            select.value = currentValue;
            if (select.value !== currentValue) {
                select.value = "";
            }

            modal.style.display = 'flex';
            select.focus();
        }

        function hideScoreModal() {
            document.getElementById('scoreModal').style.display = 'none';
        }

        function saveScoreFromModal() {
            const modal = document.getElementById('scoreModal');
            const select = document.getElementById('scoreModalSelect');
            const boardNum = modal.dataset.boardNum;
            const value = select.value;

            const { board, physicalTable } = findBoard(boardNum);
            if (!board) {
                hideScoreModal();
                return;
            }

            // CORRECTION: Modifier AVANT de sauvegarder
            if (value === "") {
                board.score.white = "";
                board.score.black = "";
                delete board.scoreTimestamp; // Supprimer timestamp si effacé
            } else {
                const parts = value.split('-');
                board.score.white = parts[0] || "";
                board.score.black = parts[1] || "";
                board.scoreTimestamp = Date.now(); // Ajouter timestamp
            }

            updateTableDisplay(physicalTable.id);
            updateStats();

            saveHistoryState(); // Sauvegarder APRÈS

            // --- NOUVEAU: Sauvegarde Atomique ---
            // On lance la mise à jour serveur spécifique
            if (typeof updateScoreOnServer === 'function') {
                updateScoreOnServer(currentRoundKey, boardNum, value);
            }

            // On sauvegarde en local pour ne pas perdre la donnée si on refresh
            // Mais on ÉVITE saveToServer() complet pour ne pas écraser les autres
            if (typeof saveToLocalStorage === 'function') {
                saveToLocalStorage();
            }

            hideScoreModal();
        }


        // --- Validation "Entrée" pour le numéro d'échiquier ---
        function editBoardNumber(oldNumber) {
            // NOUVEAU: Désactivé en mode joueur
            if (isPlayerMode) return;

            try {
                const { board, physicalTable } = findBoard(oldNumber);
                if (!board) return;

                const physicalTableEl = document.getElementById(`phys-table-${physicalTable.id}`);
                const boardEl = physicalTableEl.querySelector(`[data-board-number="${oldNumber.toString().replace(/"/g, '\\"')}"]`);
                const numberDisplay = boardEl.querySelector('.board-number-display');
                const originalText = numberDisplay.textContent.trim();

                const input = document.createElement('input');
                input.type = 'text';
                input.value = oldNumber;
                input.style.cssText = `
                    width: 100px; text-align: center; margin: 0 auto; display: block;
                    border: 2px solid #667eea; font-size: 1.2em; padding: 4px; font-weight: 700;
                `;

                numberDisplay.innerHTML = '';
                numberDisplay.appendChild(input);
                input.focus();
                input.select();

                // Fonction de sauvegarde (closure)
                function saveEdit() {
                    input.removeEventListener('blur', saveEdit);
                    input.removeEventListener('keydown', handleKeydown);

                    const newNumberStr = input.value.trim();
                    const originalNumber = oldNumber;

                    if (newNumberStr === "") {
                        numberDisplay.innerHTML = originalText;
                        return;
                    }

                    const newNumberValue = parseInt(newNumberStr);
                    let newNumber;

                    if (isNaN(newNumberValue) || newNumberValue.toString() !== newNumberStr) {
                        newNumber = newNumberStr;
                    } else {
                        newNumber = newNumberValue;
                    }

                    if (newNumber.toString() === originalNumber.toString()) {
                        numberDisplay.innerHTML = newNumber;
                        return;
                    }

                    const { board: targetBoard } = findBoard(originalNumber);

                    if (targetBoard) {
                        // CORRECTION: Modifier AVANT de sauvegarder
                        targetBoard.boardNumber = newNumber;

                        numberDisplay.innerHTML = newNumber;
                        boardEl.dataset.boardNumber = newNumber;

                        const boardNumForEvent = (typeof newNumber === 'string') ? `'${newNumber.replace(/'/g, "\\'")}'` : newNumber;

                        numberDisplay.setAttribute('onDblClick', `event.stopPropagation(); editBoardNumber(${boardNumForEvent})`);
                        boardEl.querySelector('.flip-btn-single').setAttribute('onclick', `event.stopPropagation(); flipSingleBoard(${boardNumForEvent})`);

                        boardEl.querySelectorAll('.player-name').forEach(nameEl => {
                            const player = nameEl.closest('.player');
                            if (player) {
                                const color = player.dataset.color;
                                nameEl.setAttribute('onclick', `event.stopPropagation(); editPlayerComment(${boardNumForEvent}, '${color}')`);
                            }
                        });
                        boardEl.querySelectorAll('.player-score').forEach(scoreEl => {
                            scoreEl.setAttribute('onclick', `event.stopPropagation(); editScore(${boardNumForEvent})`);
                        });

                        saveHistoryState(); // Sauvegarder APRÈS

                    } else {
                        numberDisplay.innerHTML = originalText;
                    }
                }

                // Gestionnaire de clavier
                function handleKeydown(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        saveEdit();
                    } else if (e.key === 'Escape') {
                        input.removeEventListener('blur', saveEdit);
                        input.removeEventListener('keydown', handleKeydown);
                        numberDisplay.innerHTML = originalText;
                    }
                }

                input.addEventListener('blur', saveEdit);
                input.addEventListener('keydown', handleKeydown);

            } catch (error) { console.error('Error in editBoardNumber:', error); }
        }

        function handleTableMouseDown(e, tableId) {
            try {
                // MODIFIÉ: Logique de clic en mode joueur simplifiée (gérée par le clic sur .board-container)
                if (isPlayerMode && document.body.classList.contains('player-plan-view-mode')) {
                    // Laisser le clic remonter jusqu'au .board-container si c'est la cible
                    if (e.target.closest('.board-container')) {
                        return;
                    }
                    // Empêcher d'autres actions
                    e.stopPropagation();
                    e.preventDefault();
                    return;
                }

                if (e.target.classList.contains('delete-btn') ||
                    e.target.classList.contains('rotate-btn') ||
                    e.target.classList.contains('resize-handle') ||
                    e.target.classList.contains('flip-btn-single') ||
                    e.target.classList.contains('arbiter-flag') ||
                    e.target.classList.contains('player-name') ||
                    e.target.classList.contains('player-score') ||
                    (e.target.closest('.board-container') && currentTool === 'moveboard') ||
                    e.target.tagName.toLowerCase() === 'input') {
                    return;
                }

                // Ne pas sélectionner la table si on clique sur une salle (car la salle est derrière)
                if (e.target.classList.contains('room-element') || e.target.classList.contains('room-title')) {
                    return;
                }

                if (currentTool === 'select') {
                    isDragging = true;
                    if (!e.ctrlKey && !e.metaKey && !selectedTables.includes(tableId)) {
                        clearSelection(true); // MODIFIÉ: Ne pas désélectionner les salles
                        selectTable(tableId);
                    } else if (e.ctrlKey || e.metaKey) {
                        toggleTableSelection(tableId);
                    }

                    dragContext = {
                        isRoom: false,
                        tables: [],
                        startX: e.clientX,
                        startY: e.clientY
                    };

                    selectedTables.forEach(id => {
                        const table = physicalTables.find(t => t.id === id);
                        const element = document.getElementById(`phys-table-${id}`);
                        if (table && element) {
                            dragContext.tables.push({ table, element, initialX: table.x, initialY: table.y });
                            element.style.zIndex = '1000';
                        }
                    });

                    e.preventDefault();
                    e.stopPropagation();
                }
            } catch (error) { console.error('Error in handleTableMouseDown:', error); }
        }

        function selectTable(tableId) {
            if (selectedTables.includes(tableId)) return;
            selectedTables.push(tableId);
            const element = document.getElementById(`phys-table-${tableId}`);
            if (element) element.classList.add('selected');
            updateSelectedCount();
        }

        function toggleTableSelection(tableId) {
            const index = selectedTables.indexOf(tableId);
            if (index > -1) {
                selectedTables.splice(index, 1);
                const element = document.getElementById(`phys-table-${tableId}`);
                if (element) element.classList.remove('selected');
            } else {
                selectTable(tableId);
            }
            updateSelectedCount();
        }

        function clearSelection(keepRooms = false) {
            selectedTables.forEach(id => {
                const element = document.getElementById(`phys-table-${id}`);
                if (element) element.classList.remove('selected');
            });
            selectedTables = [];
            updateSelectedCount();

            if (!keepRooms) {
                document.querySelectorAll('.room-element.selected').forEach(el => el.classList.remove('selected'));
            }
        }

        function updateSelectedCount() {
            document.getElementById('selectedCount').textContent = selectedTables.length;
        }

        function deleteTable(tableId, addToHistory = true) {
            // CORRECTION: Sauvegarde gérée par deleteSelected ou appelée après modification
            try {
                const index = physicalTables.findIndex(t => t.id === tableId);
                if (index !== -1) {
                    physicalTables.splice(index, 1);
                    const element = document.getElementById(`phys-table-${tableId}`);
                    if (element) element.remove();
                    const selIndex = selectedTables.indexOf(tableId);
                    if (selIndex > -1) {
                        selectedTables.splice(selIndex, 1);
                        updateSelectedCount();
                    }
                    updateStats();

                    if (addToHistory) {
                        saveHistoryState(); // Sauvegarder APRÈS
                    }
                }
            } catch (error) { console.error('Error in deleteTable:', error); }
        }

        function deleteSelected() {
            if (selectedTables.length === 0) return;
            try {
                [...selectedTables].forEach(id => deleteTable(id, false));
                clearSelection();
                saveHistoryState(); // Sauvegarder APRÈS
            } catch (error) { console.error('Error in deleteSelected:', error); }
        }
        function rotateSelected() {
            if (selectedTables.length === 0) return;
            try {
                selectedTables.forEach(id => rotateTable(id, false));
                saveHistoryState(); // Sauvegarder APRÈS
            } catch (error) { console.error('Error in rotateSelected:', error); }
        }

        function flipSingleBoard(boardNumber) {
            if (isPlayerMode) return;

            try {
                const { board, physicalTable } = findBoard(boardNumber);
                if (board && board.players) {
                    board.flipped = !board.flipped;
                    updateTableDisplay(physicalTable.id);
                    saveHistoryState(); // Sauvegarder APRÈS
                }
            } catch (error) { console.error('Error in flipSingleBoard:', error); }
        }

        function flipPlayersSelected() {
            if (selectedTables.length === 0) return;
            try {
                selectedTables.forEach(id => {
                    const table = physicalTables.find(t => t.id === id);
                    if (table) {
                        table.boards.forEach(board => {
                            board.flipped = !board.flipped;
                        });
                        updateTableDisplay(id);
                    }
                });

                saveHistoryState(); // Sauvegarder APRÈS
            } catch (error) { console.error('Error in flipPlayersSelected:', error); }
        }

        // --- FONCTION DE RENDU PRINCIPALE (MODIFIÉE POUR SUIVI PERSISTANT) ---
        // --- FONCTION DE RENDU AVEC SURBRILLANCE ROBUSTE ---
        function updateTableDisplay(tableId, element) {
            try {
                const table = physicalTables.find(t => t.id === tableId);
                if (!table) return;

                if (!element) element = document.getElementById(`phys-table-${tableId}`);
                if (!element) return;

                // 1. Récupération du nom suivi (nettoyage accents/espaces)
                const rawWatchedName = localStorage.getItem('chessRoomWatchedPlayer');
                const normalize = (str) => str ? str.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").trim() : "";
                const targetName = normalize(rawWatchedName);

                const contentInner = element.querySelector('.table-content-inner');
                if (!contentInner) return;
                contentInner.innerHTML = '';

                let allPaired = table.boards.length > 0;
                let hasVisibleBoards = false;
                let tableIsHighlight = false; // Pour savoir si on allume toute la table

                // --- LOGIQUE INVERSION TABLE 1 (Layout TR/BR) ---
                let boardsToRender = [...table.boards];
                const corner = document.getElementById('startCorner') ? document.getElementById('startCorner').value : 'tl';
                // Si la table contient l'échiquier 1 ET que le layout commence à droite (tr ou br)
                const hasBoard1 = table.boards.some(b => b.boardNumber === 1);
                if (hasBoard1 && (corner === 'tr' || corner === 'br')) {
                    boardsToRender.reverse();
                }

                boardsToRender.forEach((board) => {
                    const isInverted = (table.rotation === 180 && !board.flipped) || (table.rotation !== 180 && board.flipped);
                    if (board.players === null) allPaired = false;
                    const boardNumForEvent = (typeof board.boardNumber === 'string') ? `'${board.boardNumber.replace(/'/g, "\\'")}'` : board.boardNumber;
                    let playersHTML = '';
                    let boardHasPlayers = false;

                    // === DÉTECTION DU JOUEUR SUR CET ÉCHIQUIER ===
                    let isBoardHighlight = false;
                    if (targetName && board.players) {
                        const pWhite = normalize(board.players.white.name);
                        const pBlack = normalize(board.players.black.name);

                        // On vérifie si le nom suivi est contenu dans le nom du joueur (ex: "Dupont" dans "DUPONT Jean")
                        if ((pWhite && pWhite.includes(targetName)) || (pBlack && pBlack.includes(targetName))) {
                            isBoardHighlight = true;
                            tableIsHighlight = true;
                        }
                    }

                    if (board.players) {
                        boardHasPlayers = true;
                        const buildPlayerHTML = (player, color, score) => {
                            if (!player) return '';
                            let displayNameHTML = (!player.name || player.name.trim() === "")
                                ? `<span style="color: #999; font-style: italic;">${color === 'white' ? 'Blancs' : 'Noirs'}</span>`
                                : formatPlayerName(player.name);

                            // Ajout du commentaire joueur
                            let commentHTML = '';
                            if (player.comment && player.comment.trim() !== "") {
                                commentHTML = `<div class="player-comment">${player.comment}</div>`;
                            }

                            return `
                        <div class="player" data-color="${color}">
                            <div class="player-color ${color}"></div>
                            <div class="player-info">
                                <div class="player-name" title="${player.name}" onclick="event.stopPropagation(); editPlayerComment(${boardNumForEvent}, '${color}')">${displayNameHTML}</div>
                                <div class="player-elo">${player.elo || '----'}</div>
                                ${commentHTML}
                            </div>
                            <div class="player-score" onclick="event.stopPropagation(); editScore(${boardNumForEvent})">${score || '...'}</div>
                        </div>`;
                        };
                        const whiteHTML = buildPlayerHTML(board.players.white, 'white', board.score.white);
                        const blackHTML = buildPlayerHTML(board.players.black, 'black', board.score.black);
                        playersHTML = isInverted ? (blackHTML + whiteHTML) : (whiteHTML + blackHTML);
                    } else {
                        playersHTML = `<div class="player" style="opacity:0.5">...</div>`;
                    }

                    const hasScore = (board.score && (board.score.white !== '' || board.score.black !== ''));
                    if (!isPlayerMode || !document.body.classList.contains('player-plan-view-mode') || !hasScore) hasVisibleBoards = true;

                    // === APPLICATION DU STYLE JAUNE DIRECTEMENT ICI ===
                    const highlightStyle = isBoardHighlight ?
                        'background-color: #fff59d !important; border: 3px solid #ff6f00 !important; box-shadow: 0 0 15px #ff6f00 !important;' : '';

                    // --- DRAPEAU ARBITRE ---
                    let flagHTML = '';
                    if (board.arbiterComment && board.arbiterComment.flag && board.arbiterComment.flag !== 'none') {
                        flagHTML = `<div class="arbiter-flag ${board.arbiterComment.flag}" onclick="event.stopPropagation(); editArbiterComment(${boardNumForEvent})"></div>`;
                    }

                    // --- TIMESTAMP ---
                    let timestampHTML = '';
                    if (board.scoreTimestamp && (board.score.white !== '' || board.score.black !== '')) {
                        const date = new Date(board.scoreTimestamp);
                        const timeStr = date.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
                        timestampHTML = `<div style="position: absolute; bottom: 2px; left: 50%; transform: translateX(-50%); font-size: 0.7em; color: #888; pointer-events: none;">🕒 ${timeStr}</div>`;
                    }

                    const boardHTML = `
                <div class="board-container ${isBoardHighlight ? 'highlight-player' : ''} ${hasScore ? 'board-scored' : ''} ${boardHasPlayers ? 'has-players' : ''}" 
                     style="${highlightStyle}"
                     onclick="if(isPlayerMode && document.body.classList.contains('player-plan-view-mode')) { showSimplifiedScoreModal(findBoard(${boardNumForEvent}).board, findBoard(${boardNumForEvent}).physicalTable); }">
                    
                    <div class="board-header">
                        <span class="board-number" onclick="event.stopPropagation(); editBoardNumber(${boardNumForEvent})">${board.boardNumber}</span>
                        ${flagHTML}
                    </div>

                    <div class="players-container">${playersHTML}</div>
                    ${timestampHTML}
                </div>
            `;
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = boardHTML;
                    const boardEl = tempDiv.firstElementChild;

                    boardEl.addEventListener('mousedown', (e) => {
                        if (currentTool === 'moveboard') {
                            e.stopPropagation();
                            startMoveBoard(e, board.boardNumber, tableId);
                        }
                    });

                    // Clic pour voir les détails en mode joueur OU saisir le score
                    boardEl.addEventListener('click', (e) => {
                        if (isPlayerMode && boardHasPlayers) {
                            e.stopPropagation();
                            // NOUVEAU: Clic n'importe où sur l'échiquier ouvre la saisie de score
                            if (document.body.classList.contains('player-plan-view-mode')) {
                                showSimplifiedScoreModal(board, table);
                            }
                        }
                    });
                    contentInner.appendChild(boardEl);
                });

                // Mise à jour de l'état visuel de la table (pairing, highlight)
                if (allPaired && table.boards.length > 0) {
                    element.classList.add('has-pairing');
                } else {
                    element.classList.remove('has-pairing');
                }

                if (tableIsHighlight) {
                    element.classList.add('highlight-player');
                } else {
                    element.classList.remove('highlight-player');
                }

            } catch (error) { console.error(`Erreur updateTableDisplay ${tableId}:`, error); }
        }

        // --- Rotation ---
        function rotateTable(tableId, addToHistory = true) {
            // CORRECTION: Sauvegarde gérée par rotateSelected ou appelée après modification
            try {
                const table = physicalTables.find(t => t.id === tableId);
                if (table) {
                    table.rotation = (table.rotation === 0) ? 90 : 0;

                    const element = document.getElementById(`phys-table-${tableId}`);
                    if (element) {
                        element.className = element.className.replace(/rotate-\d+/, `rotate-${table.rotation}`);
                        element.style.setProperty('--rotation', `${table.rotation}deg`);

                        element.classList.remove('vertical-layout');

                        const contentInner = element.querySelector('.table-content-inner');
                        if (contentInner) {
                            contentInner.style.transform = 'rotate(0deg)';
                        }
                    }

                    if (addToHistory) {
                        saveHistoryState(); // Sauvegarder APRÈS
                    }
                }
            } catch (error) { console.error('Error in rotateTable:', error); }
        }


        // --- Redimensionnement ---
        function startResize(e, tableId, handleSide) {
            isResizing = true;
            const table = physicalTables.find(t => t.id === tableId);
            const element = document.getElementById(`phys-table-${tableId}`);

            const startX = e.clientX;
            const startY = e.clientY;
            const startWidth = table.width || defaultTableWidth;
            const startXPos = table.x;
            const startYPos = table.y;

            function onMouseMove(e) {
                if (!isResizing) return;

                const deltaX = (e.clientX - startX) / currentZoom;
                const deltaY = (e.clientY - startY) / currentZoom;

                let delta = 0;

                switch (table.rotation) {
                    case 0: delta = (handleSide === 'left') ? -deltaX : deltaX; break;
                    case 90: delta = (handleSide === 'left') ? -deltaY : deltaY; break;
                    case 180: delta = (handleSide === 'left') ? deltaX : -deltaX; break;
                    case 270: delta = (handleSide === 'left') ? deltaY : -deltaY; break;
                }

                let newWidth = startWidth + delta;
                const minWidth = (table.boards.length * 150);
                newWidth = Math.max(minWidth, Math.min(2000, newWidth));

                const widthChange = newWidth - startWidth;

                table.width = newWidth;
                element.style.width = newWidth + 'px';

                if (handleSide === 'left') {
                    const radians = table.rotation * Math.PI / 180;
                    const cos = Math.cos(radians);
                    const sin = Math.sin(radians);

                    table.x = startXPos - (widthChange * cos);
                    table.y = startYPos - (widthChange * sin);

                    element.style.left = table.x + 'px';
                    element.style.top = table.y + 'px';
                }
            }

            function onMouseUp() {
                if (isResizing) {
                    if (table.width !== startWidth || table.x !== startXPos || table.y !== startYPos) {
                        saveHistoryState(); // Sauvegarder APRÈS
                    }
                }
                isResizing = false;
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }

            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            e.preventDefault();
        }

        function duplicateSelected() {
            if (selectedTables.length === 0) return;
            try {
                const newTables = [];
                selectedTables.forEach(id => {
                    const original = physicalTables.find(t => t.id === id);
                    if (original) {
                        const newTable = JSON.parse(JSON.stringify(original));
                        newTable.id = nextPhysicalTableId++;
                        newTable.x = original.x + 50;
                        newTable.y = original.y + 50;
                        newTable.boards.forEach(board => {
                            board.boardNumber = nextBoardNumber++;
                        });
                        physicalTables.push(newTable);
                        newTables.push(newTable.id);
                        createTableElement(newTable);
                    }
                });
                clearSelection();
                newTables.forEach(id => selectTable(id));
                updateStats();
                saveHistoryState(); // Sauvegarder APRÈS
            } catch (error) { console.error('Error in duplicateSelected:', error); }
        }

        function autoArrangeTables() {
            if (physicalTables.length === 0) {
                alert("Il n'y a aucune table à réorganiser. Chargez d'abord les appariements ou ajoutez des tables vierges.");
                return;
            }
            if (!confirm("Voulez-vous vraiment réorganiser toutes les tables en fonction des paramètres actuels ? Les positions et rotations manuelles seront perdues.")) {
                return;
            }

            try {
                const boardsPerTable = parseInt(document.getElementById('boardsPerTable').value) || 1;
                const physicalTablesPerRow = parseInt(document.getElementById('physicalTablesPerRow').value) || 10;
                const tableLengthCm = parseInt(document.getElementById('tableLength').value) || 180;

                let allBoards = [];
                physicalTables.forEach(pt => {
                    allBoards.push(...pt.boards);
                });

                allBoards.sort((a, b) => {
                    let numA = parseFloat(a.boardNumber);
                    let numB = parseFloat(b.boardNumber);
                    if (isNaN(numA)) numA = Infinity;
                    if (isNaN(numB)) numB = Infinity;
                    if (numA !== numB) return numA - numB;
                    return String(a.boardNumber).localeCompare(String(b.boardNumber));
                });

                physicalTables = [];
                document.getElementById('canvas').innerHTML = '';
                renderAllRooms(); // <-- S'assurer que les salles sont re-rendues
                nextPhysicalTableId = 1;

                const layout = getLayoutConfig();
                let currentX = layout.startX;
                let currentY = layout.startY;
                const xDir = layout.xDir;
                const yDir = layout.yDir;
                const spacingY = 160 * yDir;
                const minWidthPerBoard = 150;
                let col = 0;

                for (let i = 0; i < allBoards.length; i += boardsPerTable) {
                    const boardsForThisTable = allBoards.slice(i, i + boardsPerTable);

                    const tableWidth = Math.max(tableLengthCm * 1.2, minWidthPerBoard * boardsForThisTable.length);

                    if (col === 0) {
                        currentX = layout.startX;
                    }

                    const tableX = (xDir === 1) ? currentX : currentX - tableWidth;
                    const tableY = (yDir === 1) ? currentY : currentY - 160;

                    const physicalTable = {
                        id: nextPhysicalTableId++,
                        x: tableX,
                        y: tableY,
                        rotation: 0,
                        width: tableWidth,
                        arbiterComment: { text: "", flag: "none" },
                        boards: boardsForThisTable
                    };

                    physicalTables.push(physicalTable);

                    currentX += (tableWidth + 30) * xDir;
                    col++;
                    if (col >= physicalTablesPerRow) {
                        col = 0;
                        currentY += spacingY;
                    }
                }

                renderAllTables();
                updateStats();
                saveHistoryState(); // Sauvegarder APRÈS
                setTimeout(fitAllTables, 100);

            } catch (e) {
                console.error("Error during autoArrange:", e);
                alert("Une erreur est survenue lors de la réorganisation.");
            }
        }

        // --- NOUVELLES FONCTIONS SALLES / MURS (MODIFIÉES) ---

        function addRoom() {
            const name = document.getElementById('roomNameInput').value.trim() || "Nouvelle Salle";

            const newRoom = {
                id: nextRoomId++,
                name: name,
                x: 100,
                y: 100,
                width: 500,
                height: 500
            };

            // --- NOUVEAU: Calculer la bounding box de toutes les tables ---
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

            if (physicalTables.length > 0) {
                physicalTables.forEach(t => {
                    minX = Math.min(minX, t.x);
                    minY = Math.min(minY, t.y);
                    maxX = Math.max(maxX, t.x + (t.width || defaultTableWidth));
                    maxY = Math.max(maxY, t.y + 160); // Hauteur approx d'une table
                });

                // Marges
                const padding = 50;
                const topMargin = 80; // Un peu plus haut pour le titre

                newRoom.x = minX - padding;
                newRoom.y = minY - topMargin;
                newRoom.width = (maxX - minX) + (padding * 2);
                newRoom.height = (maxY - minY) + (padding * 2);
            } else {
                // Valeurs par défaut si pas de tables
                newRoom.x = 100;
                newRoom.y = 100;
                newRoom.width = 500;
                newRoom.height = 500;
            }

            rooms.push(newRoom);
            createRoomElement(newRoom);
            document.getElementById('roomNameInput').value = '';

            saveHistoryState(); // Sauvegarder APRÈS
        }

        function createRoomElement(room) {
            const canvas = document.getElementById('canvas');
            const element = document.createElement('div');
            element.className = 'room-element';
            element.id = `room-${room.id}`;
            element.style.left = room.x + 'px';
            element.style.top = room.y + 'px';
            element.style.width = room.width + 'px';
            element.style.height = room.height + 'px';
            element.dataset.roomId = room.id;

            // NOUVEAU: Centrage du texte
            element.style.display = 'flex';
            element.style.alignItems = 'center';
            element.style.justifyContent = 'center';
            element.style.textAlign = 'center';

            element.innerHTML = `
                <div class="room-title" ondblclick="event.stopPropagation(); renameRoom(${room.id})" title="Double-cliquez pour renommer" 
                     style="font-size: 2em; font-weight: bold; width: 100%; pointer-events: none;">
                    ${room.name}
                </div>
                <div class="room-delete-btn" onclick="event.stopPropagation(); deleteRoom(${room.id})">×</div>
                <div class="room-resize-handle tl" onmousedown="event.stopPropagation(); startRoomResize(event, ${room.id}, 'tl')"></div>
                <div class="room-resize-handle tr" onmousedown="event.stopPropagation(); startRoomResize(event, ${room.id}, 'tr')"></div>
                <div class="room-resize-handle bl" onmousedown="event.stopPropagation(); startRoomResize(event, ${room.id}, 'bl')"></div>
                <div class="room-resize-handle br" onmousedown="event.stopPropagation(); startRoomResize(event, ${room.id}, 'br')"></div>
            `;

            element.addEventListener('mousedown', (e) => handleRoomMouseDown(e, room.id));

            // Placer avant les tables (qui ont un z-index >= 10)
            canvas.prepend(element);
        }

        function renameRoom(roomId) {
            const room = rooms.find(r => r.id === roomId);
            if (!room) return;

            const newName = prompt("Nouveau nom pour la salle :", room.name);
            if (newName !== null && newName.trim() !== "") {
                room.name = newName.trim();
                const element = document.getElementById(`room-${roomId}`);
                if (element) {
                    element.querySelector('.room-title').textContent = room.name;
                }
                saveHistoryState(); // Sauvegarder APRÈS
            }
        }

        function deleteRoom(roomId, addToHistory = true) {
            const index = rooms.findIndex(r => r.id === roomId);
            if (index > -1) {
                rooms.splice(index, 1);
                const element = document.getElementById(`room-${roomId}`);
                if (element) {
                    element.remove();
                }

                if (addToHistory) {
                    saveHistoryState(); // Sauvegarder APRÈS
                }
            }
        }

        function renderAllRooms() {
            // D'abord, supprimer les anciens éléments de salle
            document.querySelectorAll('.room-element').forEach(el => el.remove());
            // Puis, recréer
            rooms.forEach(room => createRoomElement(room));
        }

        function handleRoomMouseDown(e, roomId) {
            if (e.target.classList.contains('room-resize-handle') || e.target.classList.contains('room-delete-btn')) return;
            if (currentTool !== 'select') return;

            clearSelection(); // Désélectionner les tables
            document.querySelectorAll('.room-element.selected').forEach(el => el.classList.remove('selected'));

            const element = document.getElementById(`room-${roomId}`);
            element.classList.add('selected');

            isDragging = true;
            const room = rooms.find(r => r.id === roomId);

            dragContext = {
                isRoom: true,
                room,
                element,
                initialX: room.x,
                initialY: room.y,
                startX: e.clientX,
                startY: e.clientY
            };

            element.style.zIndex = '5';
            e.preventDefault();
            e.stopPropagation();
        }

        function startRoomResize(e, roomId, handle) {
            isResizing = true;
            const room = rooms.find(r => r.id === roomId);
            const element = document.getElementById(`room-${roomId}`);

            const startX = e.clientX;
            const startY = e.clientY;
            const startWidth = room.width;
            const startHeight = room.height;
            const startXPos = room.x;
            const startYPos = room.y;

            function onMouseMove(e) {
                if (!isResizing) return;

                const deltaX = (e.clientX - startX) / currentZoom;
                const deltaY = (e.clientY - startY) / currentZoom;

                if (handle.includes('r')) {
                    room.width = Math.max(100, startWidth + deltaX);
                    element.style.width = room.width + 'px';
                }
                if (handle.includes('b')) {
                    room.height = Math.max(100, startHeight + deltaY);
                    element.style.height = room.height + 'px';
                }
                if (handle.includes('l')) {
                    room.width = Math.max(100, startWidth - deltaX);
                    room.x = startXPos + deltaX;
                    element.style.width = room.width + 'px';
                    element.style.left = room.x + 'px';
                }
                if (handle.includes('t')) {
                    room.height = Math.max(100, startHeight - deltaY);
                    room.y = startYPos + deltaY;
                    element.style.height = room.height + 'px';
                    element.style.top = room.y + 'px';
                }
            }

            function onMouseUp() {
                if (isResizing) {
                    saveHistoryState(); // Sauvegarder APRÈS
                }
                isResizing = false;
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }

            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            e.preventDefault();
        }


        // --- Appariements, CSV, Recherche ---

        function loadPapiFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (physicalTables.length > 0) {
                if (!confirm("Charger ce fichier PAPI remplacera les appariements de la ronde actuelle. Continuer ?")) {
                    event.target.value = '';
                    return;
                }
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    parsePapiFile(e.target.result);
                } catch (error) {
                    console.error('Error parsing PAPI file:', error);
                    alert('Erreur lors du traitement du fichier HTML: ' + error.message);
                }
            };
            reader.readAsText(file, 'ISO-8859-1');
            event.target.value = '';
        }

        function parsePapiFile(htmlContent) {
            // CORRECTION: Sauvegarde déplacée à la fin

            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlContent, 'text/html');
            const rows = doc.querySelectorAll('tr[class^="papi_small_"]');
            const pairings = {};
            let maxBoardNum = 0;

            rows.forEach(row => {
                try {
                    if (row.children.length < 10) return;

                    const player1Name = row.children[1].textContent.trim();
                    const player1Elo = row.children[2].textContent.trim().replace(/\s/g, ' ');
                    const tableInfo = row.children[5].textContent.trim();
                    const colorInfo = row.children[6].textContent.trim();
                    const player2Name = row.children[8].textContent.trim();
                    const player2Elo = row.children[9].textContent.trim().replace(/\s/g, ' ');

                    if (!tableInfo.startsWith('TABLE')) return;

                    const boardNumStr = tableInfo.replace('TABLE', '').trim();
                    const boardNum = parseInt(boardNumStr);

                    if (isNaN(boardNum) || boardNum <= 0) {
                        return;
                    }

                    if (!pairings[boardNum]) {
                        let papiWhite, papiBlack, papiWhiteElo, papiBlackElo;
                        if (colorInfo.includes('blancs')) {
                            papiWhite = player1Name;
                            papiWhiteElo = player1Elo;
                            papiBlack = player2Name;
                            papiBlackElo = player2Elo;
                        } else {
                            papiWhite = player2Name;
                            papiWhiteElo = player2Elo;
                            papiBlack = player1Name;
                            papiBlackElo = player1Elo;
                        }

                        // On stocke les joueurs selon le fichier PAPI, pas l'assignation finale
                        pairings[boardNum] = {
                            papiW: { name: papiWhite, elo: papiWhiteElo, comment: "" },
                            papiB: { name: papiBlack, elo: papiBlackElo, comment: "" }
                        };

                        if (boardNum > maxBoardNum) maxBoardNum = boardNum;
                    }
                } catch (e) {
                    console.warn('Skipped a row during PAPI parse:', e);
                }
            });

            const boardNumbers = Object.keys(pairings).map(Number).sort((a, b) => a - b);

            if (boardNumbers.length === 0) {
                alert('Aucun appariement valide trouvé dans le fichier.');
                return;
            }

            // Si la disposition est vide, on la crée
            if (physicalTables.length === 0) {
                physicalTables = [];
                document.getElementById('canvas').innerHTML = '';
                renderAllRooms(); // <-- S'assurer que les salles sont re-rendues
                nextPhysicalTableId = 1;
                nextBoardNumber = maxBoardNum + 1;

                const boardsPerTable = parseInt(document.getElementById('boardsPerTable').value) || 1;
                const physicalTablesPerRow = parseInt(document.getElementById('physicalTablesPerRow').value) || 10;
                const tableLengthCm = parseInt(document.getElementById('tableLength').value) || 180;

                const minWidthPerBoard = 150;

                const layout = getLayoutConfig();
                let currentX = layout.startX;
                let currentY = layout.startY;
                const xDir = layout.xDir;
                const yDir = layout.yDir;

                const spacingY = 160 * yDir;
                let col = 0;

                for (let i = 0; i < boardNumbers.length; i += boardsPerTable) {
                    const boardsForThisTable = boardNumbers.slice(i, i + boardsPerTable);
                    const tableWidth = Math.max(tableLengthCm * 1.2, minWidthPerBoard * boardsForThisTable.length);

                    if (col === 0) {
                        currentX = layout.startX;
                    }

                    const tableX = (xDir === 1) ? currentX : currentX - tableWidth;
                    const tableY = (yDir === 1) ? currentY : currentY - 160;

                    const physicalTable = {
                        id: nextPhysicalTableId++,
                        x: tableX,
                        y: tableY,
                        rotation: 0,
                        width: tableWidth,
                        arbiterComment: { text: "", flag: "none" },
                        boards: []
                    };

                    boardsForThisTable.forEach(boardNum => {
                        const pairingData = pairings[boardNum];

                        // Pour une nouvelle disposition, on assigne PAPI-Blanc -> Blanc
                        const finalPlayers = {
                            white: pairingData.papiW,
                            black: pairingData.papiB
                        };

                        physicalTable.boards.push({
                            boardNumber: boardNum,
                            players: finalPlayers,
                            flipped: false, // Correct, c'est un nouveau plan
                            score: { white: "", black: "" }
                        });
                    });

                    physicalTables.push(physicalTable);

                    currentX += (tableWidth + 30) * xDir;
                    col++;
                    if (col >= physicalTablesPerRow) {
                        col = 0;
                        currentY += spacingY;
                    }
                }
                setTimeout(fitAllTables, 100);

            } else {
                // La disposition existe, on fusionne les appariements
                physicalTables.forEach(pt => {
                    pt.boards.forEach(b => {
                        const pairingData = pairings[b.boardNumber];

                        if (pairingData) {
                            // --- LOGIQUE CORRIGÉE ---
                            // On assigne STRICTEMENT selon l'appariement (Blanc = Blanc)
                            // L'état 'b.flipped' ne change que l'affichage visuel, pas les données.
                            b.players = {
                                white: pairingData.papiW,
                                black: pairingData.papiB
                            };

                            // On conserve l'état 'flipped' existant pour l'affichage
                            // (on ne touche pas à b.flipped)

                            b.score = { white: "", black: "" };
                        }
                    });
                });
            }


            renderAllTables();
            updateStats();

            saveHistoryState(); // Sauvegarder APRÈS

            alert(`${boardNumbers.length} appariements chargés dans la ronde actuelle !`);
        }


        function clearPairings() {
            physicalTables.forEach(t => {
                t.boards.forEach(b => {
                    // Réinitialiser avec structure vide (Table Verte)
                    b.players = {
                        white: { name: "", elo: "", comment: "" },
                        black: { name: "", elo: "", comment: "" }
                    };
                    b.score = { white: '', black: '' };
                });
            });

            renderAllTables();
            updateStats();

            saveHistoryState(); // Sauvegarder APRÈS
        }

        function searchTables() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase().trim();
            const suggestionsList = document.getElementById('search-suggestions');
            suggestionsList.innerHTML = '';

            document.querySelectorAll('.table-element').forEach(el => {
                el.style.opacity = '1';
                el.style.transform = el.style.transform.replace(/scale\([^)]*\)/, '');
                el.style.zIndex = '10'; // Retour au z-index de base
            });

            if (!searchTerm) return;

            let foundTable = null;
            const addedSuggestions = new Set(); // NOUVEAU: Éviter les doublons

            physicalTables.forEach(table => {
                const element = document.getElementById(`phys-table-${table.id}`);
                let tableMatches = false;
                table.boards.forEach(board => {
                    let matches = false;
                    let matchValue = '';
                    if (board.boardNumber.toString().toLowerCase().includes(searchTerm)) {
                        matches = true;
                        matchValue = `Échiquier ${board.boardNumber}`;
                    }
                    if (board.players) {
                        if (board.players.white.name.toLowerCase().includes(searchTerm)) {
                            matches = true;
                            matchValue = getSimplePlayerName(board.players.white.name); // MODIFIÉ
                        } else if (board.players.black.name.toLowerCase().includes(searchTerm)) {
                            matches = true;
                            matchValue = getSimplePlayerName(board.players.black.name); // MODIFIÉ
                        }
                    }
                    if (matches) {
                        tableMatches = true;
                        // MODIFIÉ: Gérer les doublons
                        if (matchValue && !addedSuggestions.has(matchValue)) {
                            const option = document.createElement('option');
                            option.value = matchValue;
                            suggestionsList.appendChild(option);
                            addedSuggestions.add(matchValue);
                        }
                    }
                });
                if (tableMatches) {
                    if (!foundTable) foundTable = table;
                    element.style.transform = 'scale(1.1)';
                    element.style.zIndex = '999';
                } else {
                    element.style.opacity = '0.3';
                }
            });
            if (foundTable) scrollToTable(foundTable);
        }
        function scrollToTable(table) {
            if (!table) return;
            const container = document.getElementById('canvasContainer');
            const containerWidth = container.clientWidth, containerHeight = container.clientHeight;
            const tableWidth = table.width || defaultTableWidth;
            const tableCenterX = (table.x + tableWidth / 2) * currentZoom;
            const tableCenterY = (table.y + 160 / 2) * currentZoom;
            container.scrollLeft = tableCenterX - containerWidth / 2;
            container.scrollTop = tableCenterY - containerHeight / 2;
        }

        // --- Sauvegarde, Chargement, PDF ---
        function clearAll() {
            if (confirm('Êtes-vous sûr de vouloir effacer TOUT le tournoi (toutes les rondes) ?')) {
                localStorage.removeItem(SAVE_KEY);
                localStorage.removeItem(SAVE_KEY_TIMESTAMP);

                physicalTables = [];
                rooms = [];
                nextPhysicalTableId = 1;
                nextRoomId = 1;
                nextBoardNumber = 1;
                historyStack = [];
                redoStack = [];

                roundsStore = {};
                currentRoundKey = 'ronde1';
                loadStateFromStore('ronde1');
                updateRoundSelector();

                document.getElementById('canvas').innerHTML = '';
                updateStats();
                saveHistoryState(); // Sauvegarder l'état vide
            }
        }

        function saveLayout() {
            saveCurrentStateToStore();
            const data = {
                roundsStore: JSON.parse(JSON.stringify(roundsStore)),
                currentRoundKey: currentRoundKey,
                arbiterPassword: arbiterPassword,
                registrations: RegDB.getAll(), // Include registrations
                tournamentConfig: tournamentConfig
            };

            Object.values(data.roundsStore).forEach(roundState => {
                if (roundState.physicalTables) {
                    roundState.physicalTables.forEach(t => {
                        delete t.mouseDownHandler;
                    });
                }
            });

            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `tournoi-complet-${new Date().toISOString().slice(0, 10)}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function downloadCurrentData() {
            // Try to fetch from server first to get the absolute latest state including timestamps
            fetch(SERVER_URL)
                .then(response => {
                    if (response.ok) return response.json();
                    throw new Error('Server load failed');
                })
                .then(data => {
                    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `tournoi-serveur-${new Date().toISOString().slice(0, 10)}.json`;
                    a.click();
                    URL.revokeObjectURL(url);
                    showSaveStatus('success', '✅ Données téléchargées depuis le serveur');
                })
                .catch(err => {
                    console.warn('Download from server failed, falling back to local state', err);
                    // Fallback to local state if server fails
                    saveLayout();
                });
        }

        function loadLayout() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);

                        if (data.physicalTables) {
                            roundsStore = {
                                'ronde1': {
                                    physicalTables: data.physicalTables,
                                    rooms: data.rooms || [],
                                    nextPhysicalTableId: data.nextPhysicalTableId,
                                    nextRoomId: data.nextRoomId || 1,
                                    nextBoardNumber: data.nextBoardNumber,
                                    historyStack: [],
                                    redoStack: []
                                }
                            };
                            currentRoundKey = 'ronde1';
                            alert('Ancien fichier de plan détecté, chargé comme "Ronde 1".');
                        } else if (data.roundsStore && typeof data.roundsStore === 'object' && !Array.isArray(data.roundsStore)) {
                            roundsStore = data.roundsStore;
                            currentRoundKey = data.currentRoundKey || 'ronde1';
                            arbiterPassword = data.arbiterPassword || null;

                            // RESTAURATION DES INSCRITS
                            if (data.registrations && Array.isArray(data.registrations)) {
                                // Migration: Ensure status and payment fields exist
                                const migratedRegistrations = data.registrations.map(r => {
                                    if (!r.status) r.status = r.isCheckedIn ? 'Pointé' : 'Inscrit';
                                    if (!r.payment) r.payment = r.isPaid ? 'Réglé' : 'En attente';
                                    return r;
                                });
                                RegDB.setAll(migratedRegistrations);
                                loadRegistrations(); // Mise à jour de l'interface
                            }

                            // RESTAURATION DE LA CONFIGURATION
                            if (data.tournamentConfig) {
                                tournamentConfig = data.tournamentConfig;
                                localStorage.setItem('chessroom-tournamentConfig', JSON.stringify(tournamentConfig));
                            }

                        } else {
                            throw new Error("Format de fichier non reconnu.");
                        }

                        // Migration
                        Object.values(roundsStore).forEach(roundState => {
                            if (!roundState.physicalTables) roundState.physicalTables = [];
                            if (!roundState.rooms) roundState.rooms = [];
                            if (!roundState.nextRoomId) roundState.nextRoomId = 1;
                            roundState.physicalTables.forEach(pt => {
                                if (!pt.arbiterComment) pt.arbiterComment = { text: "", flag: "none" };
                                pt.boards.forEach(b => {
                                    if (b.score === undefined) b.score = { white: "", black: "" };
                                    // Correction migration
                                    if (b.players && b.players.white && typeof b.players.white === 'string') {
                                        b.players = {
                                            white: { name: b.players.white, elo: (b.players.white_elo || ""), comment: "" },
                                            black: { name: b.players.black, elo: (b.players.black_elo || ""), comment: "" }
                                        };
                                    } else if (b.players) {
                                        if (b.players.white && !b.players.white.elo) b.players.white.elo = "";
                                        if (b.players.white && !b.players.white.comment) b.players.white.comment = "";
                                        if (b.players.black && !b.players.black.elo) b.players.black.elo = "";
                                        if (b.players.black && !b.players.black.comment) b.players.black.comment = "";
                                    }
                                });
                            });
                            if (!roundState.historyStack) roundState.historyStack = [];
                            if (!roundState.redoStack) roundState.redoStack = [];
                        });

                        updateRoundSelector();
                        loadStateFromStore(currentRoundKey);
                        autoSaveToLocalStorage();
                        saveHistoryState(); // Sauvegarder l'état chargé

                        alert('Tournoi chargé avec succès !');
                    } catch (error) {
                        alert('Erreur lors du chargement du fichier: ' + error.message);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        function renderAllTables() {
            document.querySelectorAll('.table-element').forEach(el => el.remove());
            physicalTables.forEach(table => createTableElement(table));
            if (typeof checkAndRedirectPlayer === 'function') {
                checkAndRedirectPlayer();
            }
        }


        function exportToPDF() {
            if (physicalTables.length === 0) {
                alert('Aucune table à exporter');
                return;
            }
            const totalBoards = physicalTables.reduce((acc, p) => acc + p.boards.length, 0);
            let content = `
                <html><head><title>Liste des Appariements - ${currentRoundKey.replace('r', 'R')}</title>
                    <style>
                        @media print { @page { size: A4 portrait; margin: 1cm; } }
                        body { font-family: Arial, sans-serif; padding: 20px; }
                        h1 { text-align: center; color: #2c3e50; }
                        .elo { color: #666; font-size: 0.9em; margin-left: 5px; }
                        .score { font-weight: bold; color: #c00; }
                        .lastname { font-weight: bold; text-transform: uppercase; }
                    </style>
                </head><body>
                    <h1>♟️ Appariements - ${currentRoundKey.replace('r', 'R')}</h1>
                    <p style="text-align: center; color: #666;">Nombre d'échiquiers: ${totalBoards}</p>
                    
                    <div class="pairing-list">
                        <table style="width: 100%; border-collapse: collapse; margin-top: 20px;">
                            <thead><tr style="background: #f0f0f0;">
                                <th style="border: 1px solid #ddd; padding: 8px;">Éch.</th>
                                <th style="border: 1px solid #ddd; padding: 8px;">Joueur Blancs</th>
                                <th style="border: 1px solid #ddd; padding: 8px;">Score</th>
                                <th style="border: 1px solid #ddd; padding: 8px;">Joueur Noirs</th>
                                <th style="border: 1px solid #ddd; padding: 8px;">Score</th>
                            </tr></thead><tbody>`;
            const allBoards = [];
            physicalTables.forEach(t => t.boards.forEach(b => allBoards.push(b)));
            allBoards.sort((a, b) => {
                let numA = parseFloat(a.boardNumber);
                let numB = parseFloat(b.boardNumber);
                if (isNaN(numA)) numA = Infinity;
                if (isNaN(numB)) numB = Infinity;
                if (numA !== numB) return numA - numB;
                return String(a.boardNumber).localeCompare(String(b.boardNumber));
            });

            allBoards.forEach(board => {
                const whiteName = board.players && board.players.white ? formatPlayerName(board.players.white.name) : '-';
                const whiteElo = board.players && board.players.white ? board.players.white.elo : '';
                const blackName = board.players && board.players.black ? formatPlayerName(board.players.black.name) : '-';
                const blackElo = board.players && board.players.black ? board.players.black.elo : '';
                const whiteScore = board.score ? board.score.white : '';
                const blackScore = board.score ? board.score.black : '';

                content += `<tr>
                        <td style="border: 1px solid #ddd; padding: 8px; text-align: center; font-weight: bold;">${board.boardNumber}</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">
                            ${whiteName} <span class="elo">(${whiteElo})</span>
                        </td>
                        <td style="border: 1px solid #ddd; padding: 8px; text-align: center; font-weight: bold;">${whiteScore}</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">
                            ${blackName} <span class="elo">(${blackElo})</span>
                        </td>
                        <td style="border: 1px solid #ddd; padding: 8px; text-align: center; font-weight: bold;">${blackScore}</td>
                    </tr>`;
            });
            content += `</tbody></table></div></body></html>`;
            const printWindow = window.open('', '', 'height=800,width=1000');
            printWindow.document.write(content);
            printWindow.document.close();
            printWindow.focus();
            // MODIFIÉ: Ligne d'impression automatique supprimée
            // setTimeout(() => { printWindow.print(); }, 250); 
        }

        // --- EXPORT PDF VISUEL (CORRIGÉ POUR HAUTE RÉSOLUTION / MULTI-PAGE) ---
        function showLoading(isLoading) {
            const overlay = document.getElementById('loadingOverlay');
            overlay.style.display = isLoading ? 'flex' : 'none';
        }

        async function exportVisualPDF() {
            let jsPDF;
            try {
                jsPDF = window.jspdf.jsPDF;
            } catch (e) {
                console.error("Erreur: La bibliothèque jsPDF n'a pas pu être chargée.", e);
                alert("Erreur: La bibliothèque jsPDF n'a pas pu être chargée. Vérifiez votre connexion internet ou un bloqueur de publicité.");
                return;
            }

            if (physicalTables.length === 0 && rooms.length === 0) {
                alert('Rien à exporter');
                return;
            }

            showLoading(true);
            clearSelection();
            document.querySelectorAll('.room-element.selected').forEach(el => el.classList.remove('selected'));

            const orientation = document.getElementById('pdfOrientation').value;
            const canvasElement = document.getElementById('canvas');

            // MODIFIÉ: Sauvegarder le transform (zoom) actuel
            const originalTransform = canvasElement.style.transform;

            // MODIFIÉ: Réinitialiser le zoom pour la capture
            canvasElement.style.transform = 'scale(1)';

            await new Promise(resolve => setTimeout(resolve, 50)); // Attendre que le style s'applique

            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

            physicalTables.forEach(t => {
                minX = Math.min(minX, t.x);
                minY = Math.min(minY, t.y);

                const radians = t.rotation * Math.PI / 180;
                const cos = Math.cos(radians);
                const sin = Math.sin(radians);
                const width = t.width || defaultTableWidth;
                const height = 160;

                const xCoords = [t.x, t.x + width * cos, t.x - height * sin, t.x + width * cos - height * sin];
                const yCoords = [t.y, t.y + width * sin, t.y + height * cos, t.y + width * sin + height * cos];

                maxX = Math.max(maxX, ...xCoords);
                maxY = Math.max(maxY, ...yCoords);
            });

            rooms.forEach(r => {
                minX = Math.min(minX, r.x);
                minY = Math.min(minY, r.y);
                maxX = Math.max(maxX, r.x + r.width);
                maxY = Math.max(maxY, r.y + r.height);
            });


            if (minX === Infinity) {
                showLoading(false);
                canvasElement.style.transform = originalTransform; // Restaurer
                return;
            }

            const padding = 50;
            const contentWidth = (maxX - minX) + (padding * 2);
            const contentHeight = (maxY - minY) + (padding * 2);

            html2canvas(canvasElement, {
                logging: false,
                useCORS: true,
                width: contentWidth,
                height: contentHeight,
                x: minX - padding,
                y: minY - padding,
                scale: 2, // Garder une bonne résolution
                backgroundColor: '#ecf0f1', // Fond du canvas
                removeContainer: true
            }).then(canvasImage => {
                const imgData = canvasImage.toDataURL('image/png');

                const pdf = new jsPDF({
                    orientation: orientation,
                    unit: 'mm',
                    format: 'a4'
                });

                const margin = 10;

                const pageFormats = {
                    'a4': { 'p': { w: 210, h: 297 }, 'l': { w: 297, h: 210 } }
                };

                // MODIFIÉ: Calcul des dimensions de la page
                const pageW_mm = pageFormats['a4'][orientation].w;
                const pageH_mm = pageFormats['a4'][orientation].h;
                const innerPageW_mm = pageW_mm - (margin * 2);
                const innerPageH_mm = pageH_mm - (margin * 2);

                const imgW_px = canvasImage.width;
                const imgH_px = canvasImage.height;

                // MODIFIÉ: Calcul de l'échelle et centrage
                const imgRatio = imgW_px / imgH_px;
                const pageRatio = innerPageW_mm / innerPageH_mm;

                let finalImgW_mm, finalImgH_mm;
                if (imgRatio > pageRatio) {
                    // L'image est plus large que la page
                    finalImgW_mm = innerPageW_mm;
                    finalImgH_mm = innerPageW_mm / imgRatio;
                } else {
                    // L'image est plus haute que la page
                    finalImgH_mm = innerPageH_mm;
                    finalImgW_mm = innerPageH_mm * imgRatio;
                }

                // Calcul du centrage
                const posX = margin + (innerPageW_mm - finalImgW_mm) / 2;
                const posY = margin + (innerPageH_mm - finalImgH_mm) / 2;

                pdf.addImage(imgData, 'PNG', posX, posY, finalImgW_mm, finalImgH_mm);

                pdf.save(`plan-de-salle-${currentRoundKey}-${Date.now()}.pdf`);

            }).catch(err => {
                console.error('Erreur lors de la génération du PDF:', err);
                alert('Une erreur est survenue lors de la création du PDF visuel.');
            }).finally(() => {
                showLoading(false);
                // MODIFIÉ: Restaurer le zoom
                canvasElement.style.transform = originalTransform;
            });
        }

        // ... (après la fonction syncWithPAPI)

        /**
         * Exporte TOUT le tournoi (toutes les rondes) au format TRF 1.1 de la FIDE.
         * Ce format est un fichier texte à largeur fixe.
         */
        function exportToTRF() {
            if (Object.keys(roundsStore).length === 0) {
                alert("Aucune donnée de tournoi à exporter.");
                return;
            }

            // --- 1. Collecter tous les joueurs et toutes les rondes ---
            const masterPlayerList = {}; // { "NOM Prénom": { id: 0, name: "", elo: 0, points: 0, games: [] } }
            const playerMap = new Map(); // Map<"NOM Prénom", id>
            const allRoundKeys = Object.keys(roundsStore).sort((a, b) => {
                return parseInt(a.replace('ronde', '')) - parseInt(b.replace('ronde', ''));
            });
            const numRounds = allRoundKeys.length;

            let playerId = 1;

            // Parcourir toutes les rondes pour collecter les joueurs et leurs parties
            allRoundKeys.forEach((roundKey, roundIndex) => {
                const roundData = roundsStore[roundKey];
                if (!roundData || !roundData.physicalTables) return;

                roundData.physicalTables.forEach(table => {
                    table.boards.forEach(board => {
                        if (!board.players) return;

                        const whiteName = (board.players.white && board.players.white.name) ? board.players.white.name.trim() : "";
                        const blackName = (board.players.black && board.players.black.name) ? board.players.black.name.trim() : "";
                        const whiteElo = (board.players.white && board.players.white.elo) ? parseInt(board.players.white.elo) : 0;
                        const blackElo = (board.players.black && board.players.black.elo) ? parseInt(board.players.black.elo) : 0;

                        // Enregistrer le joueur blanc
                        if (whiteName && !playerMap.has(whiteName)) {
                            playerMap.set(whiteName, playerId);
                            masterPlayerList[whiteName] = {
                                id: playerId,
                                name: whiteName,
                                elo: whiteElo,
                                points: 0,
                                games: []
                            };
                            playerId++;
                        }

                        // Enregistrer le joueur noir
                        if (blackName && !playerMap.has(blackName)) {
                            playerMap.set(blackName, playerId);
                            masterPlayerList[blackName] = {
                                id: playerId,
                                name: blackName,
                                elo: blackElo,
                                points: 0,
                                games: []
                            };
                            playerId++;
                        }

                        // Enregistrer la partie pour chaque joueur
                        if (whiteName && blackName) {
                            const whiteId = playerMap.get(whiteName);
                            const blackId = playerMap.get(blackName);

                            // Déterminer le résultat
                            let whiteResult = " ", blackResult = " ";
                            if (board.score && board.score.white && board.score.black) {
                                const ws = board.score.white;
                                const bs = board.score.black;

                                if (ws === "1" && bs === "0") {
                                    whiteResult = "+";
                                    blackResult = "-";
                                    masterPlayerList[whiteName].points += 1;
                                } else if (ws === "0" && bs === "1") {
                                    whiteResult = "-";
                                    blackResult = "+";
                                    masterPlayerList[blackName].points += 1;
                                } else if (ws === "1/2" && bs === "1/2") {
                                    whiteResult = "=";
                                    blackResult = "=";
                                    masterPlayerList[whiteName].points += 0.5;
                                    masterPlayerList[blackName].points += 0.5;
                                } else if (ws === "1" && bs === "F") {
                                    whiteResult = "+";
                                    blackResult = "-";
                                    masterPlayerList[whiteName].points += 1;
                                } else if (ws === "F" && bs === "1") {
                                    whiteResult = "-";
                                    blackResult = "+";
                                    masterPlayerList[blackName].points += 1;
                                } else if (ws === "1/2" && bs === "0") {
                                    whiteResult = "+";
                                    blackResult = "-";
                                    masterPlayerList[whiteName].points += 0.5;
                                } else if (ws === "0" && bs === "1/2") {
                                    whiteResult = "-";
                                    blackResult = "+";
                                    masterPlayerList[blackName].points += 0.5;
                                } else if (ws === "0" && bs === "0") {
                                    whiteResult = "-";
                                    blackResult = "-";
                                } else if (ws === "F" && bs === "F") {
                                    whiteResult = "-";
                                    blackResult = "-";
                                }
                            }

                            // Ajouter la partie pour le joueur blanc
                            while (masterPlayerList[whiteName].games.length < roundIndex) {
                                masterPlayerList[whiteName].games.push(null);
                            }
                            masterPlayerList[whiteName].games[roundIndex] = {
                                oppId: blackId,
                                color: "w",
                                result: whiteResult
                            };

                            // Ajouter la partie pour le joueur noir
                            while (masterPlayerList[blackName].games.length < roundIndex) {
                                masterPlayerList[blackName].games.push(null);
                            }
                            masterPlayerList[blackName].games[roundIndex] = {
                                oppId: whiteId,
                                color: "b",
                                result: blackResult
                            };
                        }
                    });
                });
            });

            // --- 2. Trier les joueurs par points décroissants ---
            const sortedPlayers = Object.values(masterPlayerList).sort((a, b) => {
                if (b.points !== a.points) return b.points - a.points;
                return a.name.localeCompare(b.name);
            });

            const numPlayers = sortedPlayers.length;

            // --- 3. Construire le contenu TRF ---
            let trfContent = "";
            trfContent += "012 Tournoi d'Échecs\n"; // Nom du tournoi
            trfContent += "022 FRA\n"; // Pays
            trfContent += "032 " + new Date().toISOString().split('T')[0].replace(/-/g, '/') + "\n"; // Date début
            trfContent += "042 " + new Date().toISOString().split('T')[0].replace(/-/g, '/') + "\n"; // Date fin
            trfContent += "015 " + numPlayers + "\n"; // Nb joueurs comptant ELO
            trfContent += "016 " + numRounds + "\n";
            trfContent += "021 Arbitre Principal\n"; // Placeholder
            trfContent += "031 10m+0s\n"; // Placeholder
            trfContent += "112 FIDE-Official Rating list used\n";

            // Lignes des joueurs (format principal)
            sortedPlayers.forEach((player, index) => {
                let line = "";
                const rank = index + 1;
                const pointsStr = (player.points % 1 === 0) ? `${player.points}.0` : `${player.points}`;

                line += String(rank).padStart(4) + " ";             // Rang
                line += " ";                                       // Sexe (placeholder)
                line += player.name.padEnd(33) + " ";              // Nom
                line += String(player.elo || 0).padStart(4) + " "; // ELO
                line += "FRA ";                                    // Féd (placeholder)
                line += pointsStr.padStart(4) + " ";               // Points
                line += String(rank).padStart(4) + "  ";           // Rang (bis)

                // Boucle des rondes
                for (let r = 0; r < numRounds; r++) {
                    const game = player.games[r];
                    if (game) {
                        // Ex: " 123 w +"
                        line += String(game.oppId || 0).padStart(5) + " ";
                        line += (game.color || " ") + " ";
                        line += (game.result || " ") + "  ";
                    } else {
                        // Pas de partie (bye, ou joueur absent)
                        // Placeholder pour un BYE 1pt
                        if (player.games.length < numRounds) {
                            line += "    0 w +  ";
                            // TODO: Améliorer la gestion du bye (il faudrait le stocker)
                        } else {
                            line += "             "; // Espace vide
                        }
                    }
                }
                trfContent += line.trimEnd() + "\n";
            });

            // --- 5. Télécharger le fichier ---
            const blob = new Blob([trfContent], { type: 'text/plain;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);

            link.setAttribute("href", url);
            link.setAttribute("download", "tournoi.trf");
            link.style.visibility = 'hidden';
            document.body.appendChild(link);

            link.click();

            document.body.removeChild(link);

            showNotification('Export TRF (FIDE) terminé !', 'success');
        }

        // --- Stats, Zoom, etc. ---
        function updateStats() {
            let pairedBoards = 0, remainingBoards = 0;

            physicalTables.forEach(t => {
                t.boards.forEach(b => {
                    // CORRECTION: On ne compte que si un nom est présent
                    if (b.players && (b.players.white.name || b.players.black.name)) {
                        pairedBoards++;

                        if (b.score.white === '' && b.score.black === '') {
                            remainingBoards++;
                        }
                    }
                });
            });

            const elPaired = document.getElementById('pairedBoards');
            const elRemaining = document.getElementById('remainingBoards');

            if (elPaired) elPaired.textContent = pairedBoards;
            if (elRemaining) elRemaining.textContent = remainingBoards;
        }
        function resetZoom() { applyZoom(1); }
        function fitAllTables() {
            if (physicalTables.length === 0 && rooms.length === 0) return resetZoom();
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

            physicalTables.forEach(t => {
                minX = Math.min(minX, t.x); minY = Math.min(minY, t.y);
                maxX = Math.max(maxX, t.x + (t.width || defaultTableWidth));
                maxY = Math.max(maxY, t.y + 160);
            });

            rooms.forEach(r => {
                minX = Math.min(minX, r.x); minY = Math.min(minY, r.y);
                maxX = Math.max(maxX, r.x + r.width);
                maxY = Math.max(maxY, r.y + r.height);
            });

            if (minX === Infinity) return resetZoom();

            const container = document.getElementById('canvasContainer');
            const cWidth = container.clientWidth, cHeight = container.clientHeight;
            const contentWidth = maxX - minX, contentHeight = maxY - minY;
            const padding = 50;
            const zoomX = (cWidth - padding * 2) / contentWidth;
            const zoomY = (cHeight - padding * 2) / contentHeight;
            let newZoom = Math.min(zoomX, zoomY);
            newZoom = Math.max(0.1, Math.min(2.0, newZoom));
            applyZoom(newZoom);
            const contentCenterX = (minX + maxX) / 2, contentCenterY = (minY + maxY) / 2;
            container.scrollLeft = (contentCenterX * currentZoom) - (cWidth / 2);
            container.scrollTop = (contentCenterY * currentZoom) - (cHeight / 2);
        }
        function applyZoom(newZoom) {
            if (newZoom) {
                currentZoom = newZoom;
            }
            currentZoom = Math.max(0.1, Math.min(2.0, currentZoom));

            const canvas = document.getElementById('canvas');
            canvas.style.transform = `scale(${currentZoom})`;

            document.getElementById('zoomLevel').textContent = Math.round(currentZoom * 100) + '%';
            document.getElementById('zoomSlider').value = currentZoom * 100;
        }

        // --- Écouteurs Globaux (Souris, Clavier) ---
        document.addEventListener('mousemove', (e) => {
            if (movingBoard) {
                moveGhost(e);
            }
            if (isDragging && dragContext.isRoom) {
                const dx = (e.clientX - dragContext.startX) / currentZoom;
                const dy = (e.clientY - dragContext.startY) / currentZoom;

                const newX = Math.max(0, dragContext.initialX + dx);
                const newY = Math.max(0, dragContext.initialY + dy);

                dragContext.room.x = newX;
                dragContext.room.y = newY;
                dragContext.element.style.left = newX + 'px';
                dragContext.element.style.top = newY + 'px';
            }
            else if (isDragging && currentTool === 'select' && !isResizing && dragContext.tables) {
                const dx = (e.clientX - dragContext.startX) / currentZoom;
                const dy = (e.clientY - dragContext.startY) / currentZoom;
                dragContext.tables.forEach(item => {
                    const newX = Math.max(0, item.initialX + dx);
                    const newY = Math.max(0, item.initialY + dy);
                    item.table.x = newX;
                    item.table.y = newY;
                    item.element.style.left = newX + 'px';
                    item.element.style.top = newY + 'px';
                });
            }
            if (selectionBox.active && currentTool === 'multiselect') {
                const container = document.getElementById('canvasContainer');
                const containerRect = container.getBoundingClientRect();
                const currentX = (e.clientX - containerRect.left + container.scrollLeft) / currentZoom;
                const currentY = (e.clientY - containerRect.top + container.scrollTop) / currentZoom;
                const x = Math.min(selectionBox.startX, currentX);
                const y = Math.min(selectionBox.startY, currentY);
                const width = Math.abs(currentX - selectionBox.startX);
                const height = Math.abs(currentY - selectionBox.startY);
                if (selectionBox.element) {
                    selectionBox.element.style.left = x + 'px';
                    selectionBox.element.style.top = y + 'px';
                    selectionBox.element.style.width = width + 'px';
                    selectionBox.element.style.height = height + 'px';
                }
                if (!e.ctrlKey && !e.metaKey) clearSelection();
                physicalTables.forEach(table => {
                    const tableWidth = table.width || defaultTableWidth;
                    if (table.x < x + width && table.x + tableWidth > x &&
                        table.y < y + height && table.y + 180 > y) {
                        selectTable(table.id);
                    }
                });
            }
            if (canvasDrag.active && currentTool === 'pan') {
                const container = document.getElementById('canvasContainer');
                const dx = e.clientX - canvasDrag.startX;
                const dy = e.clientY - canvasDrag.startY;
                container.scrollLeft = canvasDrag.scrollLeft - dx;
                container.scrollTop = canvasDrag.scrollTop - dy;
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (movingBoard) {
                let dropTargetTableEl = e.target.closest('.table-element');
                if (dropTargetTableEl) {
                    const targetTableId = parseInt(dropTargetTableEl.dataset.tableId);
                    const targetTable = physicalTables.find(t => t.id === targetTableId);

                    const { board: movedBoard, physicalTable: originalTable } = findBoard(movingBoard.boardNumber);
                    if (movedBoard && originalTable) {
                        const originalIndex = originalTable.boards.findIndex(b => b.boardNumber.toString() === movingBoard.boardNumber.toString());

                        if (originalIndex > -1) {
                            const [boardToMove] = originalTable.boards.splice(originalIndex, 1);

                            const targetBoardEl = e.target.closest('.board-container');
                            let targetIndex = targetTable.boards.length;

                            if (targetBoardEl && targetTableId === parseInt(targetBoardEl.closest('.table-element').dataset.tableId)) {
                                const targetBoardNumStr = targetBoardEl.dataset.boardNumber;
                                targetIndex = targetTable.boards.findIndex(b => b.boardNumber.toString() === targetBoardNumStr);
                                if (targetIndex === -1) targetIndex = targetTable.boards.length;
                            }

                            targetTable.boards.splice(targetIndex, 0, boardToMove);

                            if (originalTable.id !== targetTable.id) {
                                updateTableDisplay(originalTable.id);
                            }
                            updateTableDisplay(targetTable.id);
                            updateStats();

                            saveHistoryState(); // Sauvegarder APRÈS
                        }
                    }
                }

                if (movingBoard.element) {
                    document.body.removeChild(movingBoard.element);
                }
                movingBoard = null;
                isDragging = false;
                document.querySelectorAll('.table-element, .board-container').forEach(el => {
                    el.removeEventListener('mouseenter', handleTableDropEnter);
                    el.removeEventListener('mouseleave', handleTableDropLeave);
                    el.classList.remove('over');
                    if (el.classList.contains('table-element') && !selectedTables.includes(parseInt(el.dataset.tableId))) {
                        el.classList.remove('selected');
                    }
                });
            }
            if (isDragging) {
                if (dragContext.isRoom) {
                    if (dragContext.room.x !== dragContext.initialX || dragContext.room.y !== dragContext.initialY) {
                        saveHistoryState(); // Sauvegarder APRÈS
                    }
                    dragContext.element.style.zIndex = '5';
                }
                else {
                    const moved = dragContext.tables && dragContext.tables.some(item =>
                        item.table.x !== item.initialX || item.table.y !== item.initialY
                    );
                    if (moved) {
                        saveHistoryState(); // Sauvegarder APRÈS
                    }
                    if (dragContext.tables) {
                        dragContext.tables.forEach(item => {
                            if (item.element) item.element.style.zIndex = '10';
                        });
                    }
                }
                dragContext = {};
            }
            isDragging = false;
            canvasDrag.active = false;
            if (selectionBox.active) {
                if (selectionBox.element) selectionBox.element.remove();
                selectionBox.element = null;
                selectionBox.active = false;
            }
        });

        document.getElementById('canvas').addEventListener('mousedown', (e) => {
            if (e.target.id === 'canvas' || e.target.classList.contains('canvas')) {
                // MODIFIÉ: Autoriser le 'pan' en mode plan joueur
                if (currentTool === 'pan') {
                    canvasDrag.active = true;
                    canvasDrag.startX = e.clientX;
                    canvasDrag.startY = e.clientY;
                    const container = document.getElementById('canvasContainer');
                    canvasDrag.scrollLeft = container.scrollLeft;
                    canvasDrag.scrollTop = container.scrollTop;
                    e.preventDefault();
                } else if (currentTool === 'multiselect' && !isPlayerMode) { // Désactiver en mode joueur
                    const container = document.getElementById('canvasContainer');
                    const containerRect = container.getBoundingClientRect();
                    const canvas = document.getElementById('canvas');
                    selectionBox.active = true;
                    selectionBox.startX = (e.clientX - containerRect.left + container.scrollLeft) / currentZoom;
                    selectionBox.startY = (e.clientY - containerRect.top + container.scrollTop) / currentZoom;
                    const box = document.createElement('div');
                    box.className = 'selection-box';
                    box.style.left = selectionBox.startX + 'px';
                    box.style.top = selectionBox.startY + 'px';
                    box.style.width = '0px';
                    box.style.height = '0px';
                    canvas.appendChild(box);
                    selectionBox.element = box;
                    e.preventDefault();
                }
            }
        });

        document.getElementById('canvas').addEventListener('click', (e) => {
            if ((e.target.id === 'canvas' || e.target.classList.contains('canvas-container')) && currentTool !== 'multiselect') {
                clearSelection();
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.target.tagName.toLowerCase() === 'input' || e.target.tagName.toLowerCase() === 'textarea' || e.target.tagName.toLowerCase() === 'select') return;

            // MODIFIÉ: Gestion Echap améliorée
            if (e.key === 'Escape') {
                if (document.getElementById('simplifiedScoreModal').style.display === 'flex') {
                    closeSimplifiedScoreModal();
                } else if (isPlayerMode && document.body.classList.contains('player-plan-view-mode')) {
                    returnToPlayerHome();
                } else if (document.querySelector('.modal-overlay[style*="display: flex"]')) {
                    hideScoreModal();
                    cancelQRValidation();
                    stopQRScanner();
                    document.getElementById('arbiterPassModal').style.display = 'none';
                    document.getElementById('playerLoginModal').style.display = 'none';
                    closePlayerLogoutConfirm();
                    closePlayerTextSearch();
                    closePlayerListSearch();
                } else {
                    clearSelection();
                }
                return;
            }

            // NOUVEAU: Désactiver les raccourcis en mode joueur
            if (isPlayerMode || (window.currentSaveMode && window.currentSaveMode === 'spectator')) return;

            if (document.getElementById('scoreModal').style.display === 'flex') return;

            if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); }
            if ((e.ctrlKey || e.metaKey) && e.key === 'y') { e.preventDefault(); redo(); }

            if ((e.key === 'Delete' || e.key === 'Backspace')) {
                const selectedRoom = document.querySelector('.room-element.selected');

                if (selectedTables.length > 0) {
                    e.preventDefault();
                    deleteSelected();
                } else if (selectedRoom) {
                    e.preventDefault();
                    deleteRoom(parseInt(selectedRoom.dataset.roomId));
                }
            }

            if (e.key === 'd' && (e.ctrlKey || e.metaKey) && selectedTables.length > 0) { e.preventDefault(); duplicateSelected(); }
            if (e.key === 'r' && selectedTables.length > 0) rotateSelected();
            if (e.key === 'p') setTool('pan');
            if (e.key === 's' && !e.ctrlKey && !e.metaKey) setTool('select');
            if (e.key === 'm') setTool('multiselect');
            if (e.key === 'a' && (e.ctrlKey || e.metaKey)) { e.preventDefault(); clearSelection(); physicalTables.forEach(t => selectTable(t.id)); }
        });

        // =====================================================
        //  LOGIQUE QR CODE INTÉGRÉE
        // =====================================================

        // --- Variables globales pour le scanner ---
        let qrStream = null;
        let qrScanInterval = null;
        let qrStagedResult = null; // Résultat en attente de validation
        // CORRECTION: Distinguer le type de scan
        let currentScanMode = 'RESULT'; // 'RESULT' ou 'PLAYER_ID'

        // --- Fonction de Notification ---
        function showNotification(message, type = 'success') {
            const notif = document.getElementById('notification');
            if (!notif) return;
            notif.textContent = message;
            notif.className = `notification ${type} show`;
            setTimeout(() => notif.classList.remove('show'), 3000);
        }

        // --- Fonction de formatage (utilitaire) ---
        function formatResult(result) {
            return result === 'DRAW' ? '½-½' : result;
        }

        // --- 1. Logique de GÉNÉRATION de fiches QR ---

        function generateQRFiches() {
            const num = parseInt(document.getElementById('qrNumTables').value);
            if (isNaN(num) || num < 1 || num > 2000) {
                showNotification('Nombre invalide (1-2000)', 'error');
                return;
            }

            const results = ['1-0', 'DRAW', '0-1'];
            const labels = ['✅ Blancs gagnent', '⚖️ Nulle', '❌ Noirs gagnent'];
            let htmlContent = `
                <!DOCTYPE html><html lang="fr"><head><meta charset="UTF-8">
                <title>Fiches QR - ${num} tables</title>
                <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"><\/script>
                <style>
                    body { font-family: sans-serif; }
                    .qr-set { 
                        border: 3px solid #333; border-radius: 12px; 
                        padding: 20px; margin: 20px; 
                        page-break-inside: avoid; 
                    }
                    .qr-set h3 { text-align: center; font-size: 24px; margin: 0 0 20px 0; padding-bottom: 10px; border-bottom: 2px solid #ddd; }
                    .qr-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; text-align: center; }
                    .qr-item p { font-weight: 600; margin-top: 10px; }
                    @media print {
                        body { margin: 0; }
                        .qr-set { margin: 10px; }
                    }
                </style>
                </head><body>
            `;

            // Générer la structure HTML
            for (let i = 1; i <= num; i++) {
                htmlContent += `
                    <div class="qr-set">
                        <h3>Table ${i}</h3>
                        <div class="qr-grid">`;
                results.forEach((result, idx) => {
                    htmlContent += `
                        <div class="qr-item">
                            <div id="qr-${i}-${idx}"></div> 
                            <p>${labels[idx]}</p>
                        </div>`;
                });
                htmlContent += `</div></div>`;
            }

            // Ajouter le script qui va générer les QR codes au chargement de la page d'impression
            htmlContent += `
                <script>
                    window.onload = () => {
                        for (let i = 1; i <= ${num}; i++) {
                            const results = ['1-0', 'DRAW', '0-1'];
                            results.forEach((result, idx) => {
                                const qrData = JSON.stringify({ type: 'result', table: i, result });
                                try {
                                    new QRCode(document.getElementById(\`qr-\${i}-\${idx}\`), {
                                        text: qrData,
                                        width: 128,
                                        height: 128,
                                        colorDark: "#333"
                                    });
                                } catch(e) { console.error(e); }
                            });
                        }
                        
                        // Lancer l'impression
                        setTimeout(() => window.print(), 500);
                    };
                <\/script>
            `;

            htmlContent += `</body></html>`;

            // Ouvrir dans une nouvelle fenêtre
            const printWindow = window.open('', '_blank');
            printWindow.document.write(htmlContent);
            printWindow.document.close();
            showNotification(`${num} fiches générées`, 'success');
        }

        // --- NOUVELLE FONCTION: Générer les QR-codes d'identification des joueurs ---
        function generatePlayerQRCodes() {

            // Récupérer tous les joueurs de la ronde 1
            if (!roundsStore['ronde1']) {
                showNotification('Aucune ronde 1 trouvée. Importez d\'abord les appariements.', 'error');
                return;
            }

            const ronde1State = roundsStore['ronde1'];
            const players = [];

            // Parcourir tous les échiquiers de la ronde 1 pour extraire les joueurs
            ronde1State.physicalTables.forEach(pt => {
                pt.boards.forEach(board => {
                    if (board.players) {
                        // Ajouter le joueur blanc
                        if (board.players.white && board.players.white.name) {
                            const whiteName = board.players.white.name.trim();
                            const whiteElo = board.players.white.elo || '';
                            if (!players.find(p => p.name === whiteName)) {
                                players.push({ name: whiteName, elo: whiteElo });
                            }
                        }
                        // Ajouter le joueur noir
                        if (board.players.black && board.players.black.name) {
                            const blackName = board.players.black.name.trim();
                            const blackElo = board.players.black.elo || '';
                            if (!players.find(p => p.name === blackName)) {
                                players.push({ name: blackName, elo: blackElo });
                            }
                        }
                    }
                });
            });

            if (players.length === 0) {
                showNotification('Aucun joueur trouvé dans la ronde 1. Importez d\'abord les appariements.', 'error');
                return;
            }

            // Trier les joueurs par nom
            players.sort((a, b) => a.name.localeCompare(b.name));

            // Créer le HTML pour l'impression
            let htmlContent = `
                <!DOCTYPE html><html lang="fr"><head><meta charset="UTF-8">
                <title>QR-codes Joueurs - ${players.length} joueurs</title>
                <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"><\/script>
                <style>
                    body { 
                        font-family: Arial, sans-serif; 
                        padding: 20px;
                    }
                    .qr-grid { 
                        display: grid; 
                        grid-template-columns: repeat(4, 1fr); 
                        gap: 15px;
                        page-break-inside: avoid;
                    }
                    .qr-item { 
                        border: 2px dashed #333; 
                        padding: 15px; 
                        text-align: center;
                        page-break-inside: avoid;
                        background: white;
                    }
                    .qr-item h4 { 
                        margin: 10px 0 5px 0; 
                        font-size: 14px;
                        word-wrap: break-word;
                    }
                    .qr-item .elo { 
                        font-size: 12px; 
                        color: #666; 
                        margin: 5px 0;
                    }
                    .qr-item .instructions {
                        font-size: 10px;
                        color: #999;
                        margin-top: 5px;
                        font-style: italic;
                    }
                    h1 {
                        text-align: center;
                        margin-bottom: 30px;
                        color: #2c3e50;
                    }
                    @media print {
                        body { margin: 10mm; }
                        .qr-grid { gap: 10px; }
                        .qr-item { padding: 10px; }
                    }
                </style>
                </head><body>
                <h1>🎫 QR-codes d'Identification des Joueurs</h1>
                <p style="text-align: center; margin-bottom: 20px; color: #666;">
                    Découpez et distribuez ces QR-codes aux joueurs pour qu'ils puissent rapidement trouver leur table.
                </p>
                <div class="qr-grid">
            `;

            // Générer un QR-code pour chaque joueur
            players.forEach((player, index) => {
                const qrData = JSON.stringify({
                    type: 'player',
                    name: player.name,
                    elo: player.elo
                });

                htmlContent += `
                    <div class="qr-item">
                        <div id="player-qr-${index}"></div>
                        <h4>${escapeHtml(player.name)}</h4>
                        ${player.elo ? `<div class="elo">Élo: ${player.elo}</div>` : ''}
                        <div class="instructions">Scanner pour trouver ma table</div>
                    </div>
                `;
            });

            htmlContent += `
                </div>
                <script>
                    window.onload = () => {
                        const players = ${JSON.stringify(players)};
                        players.forEach((player, index) => {
                            const qrData = JSON.stringify({ 
                                type: 'player', 
                                name: player.name,
                                elo: player.elo 
                            });
                            try {
                                new QRCode(document.getElementById(\`player-qr-\${index}\`), {
                                    text: qrData,
                                    width: 100,
                                    height: 100,
                                    colorDark: "#000000",
                                    colorLight: "#ffffff"
                                });
                            } catch(e) { 
                                console.error('Erreur QR-code:', e); 
                            }
                        });
                        
                        // Lancer l'impression après génération
                        setTimeout(() => window.print(), 1000);
                    };
                <\/script>
            </body></html>`;

            // Ouvrir dans une nouvelle fenêtre
            const printWindow = window.open('', '_blank');
            printWindow.document.write(htmlContent);
            printWindow.document.close();
            showNotification(`${players.length} QR-codes joueurs générés`, 'success');
        }

        // Fonction helper pour échapper le HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }


        // --- 2. Logique de SCAN de QR Code ---

        // CORRECTION: Fonction unifiée pour démarrer le scanner
        async function startGenericQRScanner(scanMode) {
            // scanMode: 'RESULT' (défaut) ou 'PLAYER_ID'
            currentScanMode = scanMode || 'RESULT';

            if (isPlayerMode) {
                document.getElementById('playerHomeModal').style.display = 'none';
            }

            const modal = document.getElementById('qrScannerModal');
            modal.style.display = 'flex';

            const video = document.getElementById('qrVideo');

            try {
                qrStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: { ideal: "environment" },
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    }
                });

                video.srcObject = qrStream;
                video.setAttribute("playsinline", true); // Force for iOS
                await video.play();

                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');

                qrScanInterval = setInterval(() => {
                    if (video.readyState === video.HAVE_ENOUGH_DATA) {
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        context.drawImage(video, 0, 0, canvas.width, canvas.height);

                        const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
                        const code = jsQR(imageData.data, imageData.width, imageData.height);

                        if (code && code.data) {
                            clearInterval(qrScanInterval);
                            onScanSuccess(code.data); // La gestion se fait dans onScanSuccess
                        }
                    }
                }, 300);

            } catch (err) {
                console.error('Erreur caméra:', err);
                showNotification("Erreur caméra. Autorisez l'accès.", 'error');
                stopQRScanner();
            }
        }

        // Wrapper pour l'ancien bouton "Scanner QR Code (résultat)"
        function startQRScanner() {
            startGenericQRScanner('RESULT');
        }

        // Wrapper pour le nouveau bouton "Scanner mon QR-code" (pour trouver sa table)
        function startPlayerQRScanner() {
            startGenericQRScanner('PLAYER_ID');
        }

        // Wrapper pour le scanner de pointage dans la page d'inscription
        function startRegistrationQRScanner() {
            startGenericQRScanner('REGISTRATION');
        }


        function stopQRScanner() {
            if (qrStream) {
                qrStream.getTracks().forEach(track => track.stop());
                qrStream = null;
            }
            if (qrScanInterval) {
                clearInterval(qrScanInterval);
                qrScanInterval = null;
            }
            document.getElementById('qrScannerModal').style.display = 'none';

            // NOUVEAU: Ré-afficher la modale d'accueil si on annule
            if (isPlayerMode && !qrStagedResult) { // Ne pas ré-afficher si on va valider
                document.getElementById('playerHomeModal').style.display = 'flex';
            }
        }

        function onScanSuccess(data) {
            stopQRScanner();

            try {
                const parsed = JSON.parse(data);

                // --- GESTION DU SCAN ---

                // CAS 1: On a scanné un QR JOUEUR ('player')
                if (parsed.type === 'player' && parsed.name) {

                    // CAS 1a: Mode REGISTRATION - Pointage automatique
                    if (currentScanMode === 'REGISTRATION') {
                        handleRegistrationScan(parsed.name, parsed.elo);
                        return;
                    }

                    // CAS 1b: On voulait trouver sa table (mode PLAYER_ID)
                    if (currentScanMode === 'PLAYER_ID') {
                        findPlayerTable(parsed.name, parsed.elo);
                    }
                    // CAS 1b: On voulait scanner un RÉSULTAT (mode RESULT)
                    else {
                        // Si on est arbitre, on cherche la table pour la montrer
                        if (!isPlayerMode) {
                            findPlayerTable(parsed.name, parsed.elo);
                            showNotification('Scan annulé. Vous devez scanner votre QR-code joueur, pas un résultat.', 'error');
                            if (isPlayerMode) document.getElementById('playerHomeModal').style.display = 'flex';
                            return;
                        }

                        // Logique de validation du résultat (code existant)
                        qrStagedResult = parsed;
                        const { board } = findBoard(parsed.table);

                        const boardNum = parsed.table;
                        const resultStr = formatResult(parsed.result);
                        let whiteName = "N/A";
                        let blackName = "N/A";

                        if (board && (board.score.white !== '' || board.score.black !== '') && isPlayerMode) {
                            showNotification("Ce résultat a déjà été saisi.", "info");
                            cancelQRValidation();
                            return;
                        }

                        if (board) {
                            whiteName = getSimplePlayerName(board.players.white.name);
                            blackName = getSimplePlayerName(board.players.black.name);
                        } else if (board) {
                            whiteName = "(Table non appariée)";
                            blackName = "(Table non appariée)";
                        } else {
                            whiteName = "(Échiquier non trouvé)";
                            blackName = "(Échiquier non trouvé)";
                        }

                        document.getElementById('qrValidateBoard').textContent = boardNum;
                        document.getElementById('qrValidateWhite').textContent = whiteName;
                        document.getElementById('qrValidateBlack').textContent = blackName;
                        document.getElementById('qrValidateResult').textContent = resultStr;

                        document.getElementById('qrValidationModal').style.display = 'flex';

                    }
                } else {
                    showNotification('QR Code invalide ou non reconnu', 'error');
                    if (isPlayerMode) document.getElementById('playerHomeModal').style.display = 'flex';
                }
            } catch (e) {
                showNotification('QR Code illisible', 'error');
                if (isPlayerMode) document.getElementById('playerHomeModal').style.display = 'flex';
            }
        }

        function cancelQRValidation() {
            document.getElementById('qrValidationModal').style.display = 'none';
            qrStagedResult = null;
            // NOUVEAU: Retour à l'accueil joueur
            if (isPlayerMode) {
                document.getElementById('playerHomeModal').style.display = 'flex';
            }
        }


        // --- 3. LA FONCTION DE CONNEXION PRINCIPALE ---
        function validateQRResult() {
            if (!qrStagedResult) return;

            const tableNum = qrStagedResult.table;
            const result = qrStagedResult.result;

            const { board, physicalTable } = findBoard(tableNum);

            if (!board) {
                showNotification(`Échiquier ${tableNum} non trouvé dans cette ronde.`, 'error');
                cancelQRValidation();
                return;
            }

            // CORRECTION: Modifier AVANT de sauvegarder
            if (result === "1-0") {
                board.score.white = "1";
                board.score.black = "0";
            } else if (result === "0-1") {
                board.score.white = "0";
                board.score.black = "1";
            } else if (result === "DRAW") {
                board.score.white = "1/2";
                board.score.black = "1/2";
            }
            board.scoreTimestamp = Date.now(); // Ajouter timestamp

            updateTableDisplay(physicalTable.id);
            updateStats();

            saveHistoryState(); // Sauvegarder APRÈS

            showNotification(`Table ${tableNum} : ${formatResult(result)} enregistré !`, 'success');
            cancelQRValidation(); // Retourne à l'accueil joueur
        }

        // --- NOUVELLES FONCTIONS MODE JOUEUR ---

        window.arbiterPassword = null;
        let isPlayerMode = false;

        function showArbiterPasswordModal() {
            document.getElementById('arbiterPassInput').value = arbiterPassword || '';
            document.getElementById('arbiterPassModal').style.display = 'flex';
        }

        function setArbiterPassword() {
            const pass = document.getElementById('arbiterPassInput').value;
            if (pass.length > 0 && pass.length < 4) {
                alert("Le mot de passe doit faire au moins 4 caractères.");
                return;
            }
            arbiterPassword = pass.length > 0 ? pass : null;
            document.getElementById('arbiterPassModal').style.display = 'none';

            if (arbiterPassword) {
                showNotification("Mot de passe arbitre enregistré.", "success");

                // --- CORRECTION AJOUTÉE ---
                // Basculer automatiquement en mode Arbitre
                if (window.ChessRoomSave && typeof window.ChessRoomSave.setMode === 'function') {
                    window.ChessRoomSave.setMode('arbiter');
                }
                // --- FIN CORRECTION ---

            } else {
                showNotification("Mot de passe arbitre désactivé.", "info");

                // --- CORRECTION AJOUTÉE ---
                // (Sécurité) Si le mdp est supprimé, forcer le mode spectateur
                if (window.ChessRoomSave && typeof window.ChessRoomSave.setMode === 'function') {
                    window.ChessRoomSave.setMode('spectator');
                }
                // --- FIN CORRECTION ---
            }
            autoSaveToLocalStorage();
        }

        function showPlayerLoginModal() {
            if (!arbiterPassword) {
                alert("Aucun mot de passe arbitre n'a été défini. Veuillez d'abord en créer un.");
                return;
            }
            document.getElementById('playerPassInput').value = '';
            document.getElementById('playerLoginError').style.display = 'none';
            document.getElementById('playerLoginModal').style.display = 'flex';
        }

        function loginAsPlayer() {
            const pass = document.getElementById('playerPassInput').value;
            if (pass === arbiterPassword) {
                isPlayerMode = true;
                document.getElementById('playerLoginModal').style.display = 'none';
                document.getElementById('playerHomeModal').style.display = 'flex';
                // Verrouiller les outils
                setTool('pan'); // Mettre dans un mode "sûr"
                document.querySelector('.sidebar').style.display = 'none';
                document.querySelector('.toolbar').style.display = 'none';
                document.querySelector('.shortcut-bar').style.display = 'none';
                document.querySelector('.main-content').classList.add('sidebar-collapsed');
                fitAllTables(); // Centrer le plan pour le joueur
            } else {
                document.getElementById('playerLoginError').style.display = 'block';
            }
        }

        function performPlayerLogout() {
            isPlayerMode = false;
            document.getElementById('playerHomeModal').style.display = 'none';
            document.getElementById('playerLogoutConfirmModal').style.display = 'none';
            // Déverrouiller les outils
            document.querySelector('.sidebar').style.display = 'flex';
            document.querySelector('.toolbar').style.display = 'flex';
            document.querySelector('.shortcut-bar').style.display = 'block';
            document.querySelector('.main-content').classList.remove('sidebar-collapsed');
            setTool('select');
        }

        function promptToLogoutPlayer() {
            document.getElementById('playerLogoutPassInput').value = '';
            document.getElementById('playerLogoutError').style.display = 'none';
            // MODIFIÉ: S'assurer que la modale d'accueil est cachée
            document.getElementById('playerHomeModal').style.display = 'none';
            document.getElementById('playerLogoutConfirmModal').style.display = 'flex';
        }

        // NOUVEAU: Fermer la modale de déconnexion et revenir
        function closePlayerLogoutConfirm() {
            document.getElementById('playerLogoutConfirmModal').style.display = 'none';
            document.getElementById('playerHomeModal').style.display = 'flex';
        }

        function attemptPlayerLogout() {
            const pass = document.getElementById('playerLogoutPassInput').value;
            if (pass === arbiterPassword) {
                performPlayerLogout();
            } else {
                document.getElementById('playerLogoutError').style.display = 'block';
            }
        }

        // --- NOUVEAU: Gestion Saisie sur Plan ---
        function showPlayerPlanView() {
            document.getElementById('playerHomeModal').style.display = 'none';
            document.body.classList.add('player-plan-view-mode');
            setTool('pan'); // Activer le mode 'pan' pour le déplacement
            renderAllTables(); // NOUVEAU: Re-rendre pour cacher les tables terminées
            fitAllTables();
        }

        function returnToPlayerHome() {
            closePlayerTableInfo();
        }

        // --- NOUVEAU: Gestion Recherche Joueur (Texte) ---
        function showPlayerTextSearch(mode = 'ENCODE') {
            document.getElementById('playerHomeModal').style.display = 'none';
            document.getElementById('playerSearchInput').value = '';
            populatePlayerSearchSuggestions(); // Pré-remplir
            document.getElementById('playerTextSearchModal').dataset.mode = mode;
            document.getElementById('playerTextSearchModal').style.display = 'flex';
            document.getElementById('playerSearchInput').focus();
        }

        function closePlayerTextSearch() {
            document.getElementById('playerTextSearchModal').style.display = 'none';
            document.getElementById('playerHomeModal').style.display = 'flex';
        }

        function populatePlayerSearchSuggestions() {
            const input = document.getElementById('playerSearchInput');
            const suggestionsList = document.getElementById('player-search-suggestions');
            const searchTerm = input.value.toLowerCase();

            suggestionsList.innerHTML = '';
            const addedSuggestions = new Set();
            let matchingOptions = [];

            physicalTables.forEach(table => {
                table.boards.forEach(board => {
                    // NOUVEAU: Filtre
                    if (board.players && (board.score.white === '' && board.score.black === '')) {
                        const wName = getSimplePlayerName(board.players.white.name);
                        const bName = getSimplePlayerName(board.players.black.name);

                        if (wName !== 'N/A' && !addedSuggestions.has(wName)) {
                            addedSuggestions.add(wName);
                            if (wName.toLowerCase().includes(searchTerm)) {
                                matchingOptions.push(wName);
                            }
                        }
                        if (bName !== 'N/A' && !addedSuggestions.has(bName)) {
                            addedSuggestions.add(bName);
                            if (bName.toLowerCase().includes(searchTerm)) {
                                matchingOptions.push(bName);
                            }
                        }
                    }
                });
            });

            // NOUVEAU: Logique d'auto-complétion améliorée
            if (matchingOptions.length === 1 && searchTerm.length > 2 && matchingOptions[0].toLowerCase() !== searchTerm) {
                input.value = matchingOptions[0]; // Auto-remplir
            } else {
                matchingOptions.forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    suggestionsList.appendChild(option);
                });
            }
        }

        function findPlayerFromTextSearch() {
            const mode = document.getElementById('playerTextSearchModal').dataset.mode || 'ENCODE'; // <-- AJOUTÉ
            const name = document.getElementById('playerSearchInput').value;
            document.getElementById('playerSearchInput').value = '';
            if (!name || name.trim().length < 2) {
                alert("Veuillez entrer un nom valide.");
                return;
            }

            // --- MODIFIÉ ---
            if (mode === 'VIEW') {
                findPlayerTable(name.trim());
            } else {
                findPlayerByName(name.trim());
            }
            // --- FIN MODIFICATION ---

            document.getElementById('playerTextSearchModal').style.display = 'none';
        }

        // --- NOUVEAU: Gestion Recherche Joueur (Liste) ---
        function showPlayerListSearch(mode = 'ENCODE') {
            document.getElementById('playerHomeModal').style.display = 'none';
            document.getElementById('playerListSearchModal').dataset.mode = mode;

            const select = document.getElementById('playerListSelect');
            select.innerHTML = '<option value="">-- Sélectionnez votre nom --</option>';
            const playerList = [];

            physicalTables.forEach(table => {
                table.boards.forEach(board => {
                    // NOUVEAU: Filtre (mode ENCODE)
                    if (mode === 'ENCODE' && board.players && (board.score.white === '' && board.score.black === '')) {
                        playerList.push({ name: getSimplePlayerName(board.players.white.name), board: board.boardNumber });
                        playerList.push({ name: getSimplePlayerName(board.players.black.name), board: board.boardNumber });
                    }
                    // NOUVEAU: Pas de filtre (mode VIEW)
                    else if (mode === 'VIEW' && board.players) {
                        playerList.push({ name: getSimplePlayerName(board.players.white.name), board: board.boardNumber });
                        playerList.push({ name: getSimplePlayerName(board.players.black.name), board: board.boardNumber });
                    }
                });
            });

            // Trier la liste par nom
            playerList.sort((a, b) => a.name.localeCompare(b.name));

            const addedNames = new Set(); // Éviter doublons si un joueur a 2 parties (rare)
            playerList.forEach(p => {
                if (p.name !== "N/A" && !addedNames.has(p.name)) {
                    const option = document.createElement('option');
                    option.value = p.name; // On utilise le nom pour la recherche
                    option.textContent = `${p.name} (Éch. ${p.board})`;
                    select.appendChild(option);
                    addedNames.add(p.name);
                }
            });

            document.getElementById('playerListSearchModal').style.display = 'flex';
        }

        function closePlayerListSearch() {
            document.getElementById('playerListSearchModal').style.display = 'none';
            document.getElementById('playerHomeModal').style.display = 'flex';
        }

        function findPlayerFromListSearch() {
            const mode = document.getElementById('playerListSearchModal').dataset.mode || 'ENCODE'; // <-- AJOUTÉ
            const name = document.getElementById('playerListSelect').value;
            if (!name) {
                alert("Veuillez sélectionner votre nom.");
                return;
            }

            // --- MODIFIÉ ---
            if (mode === 'VIEW') {
                findPlayerTable(name);
            } else {
                findPlayerByName(name);
            }
            document.getElementById('playerListSearchModal').style.display = 'none';
        }

        // --- NOUVEAU: Logique de recherche commune ---
        function findPlayerByName(name, fromQR = false) {
            const searchTerm = name.toLowerCase();
            let foundGame = null;

            for (const physicalTable of physicalTables) {
                for (const board of physicalTable.boards) {
                    // NOUVEAU: Filtre
                    if (board.players && (board.score.white === '' && board.score.black === '')) {
                        if ((board.players.white && getSimplePlayerName(board.players.white.name).toLowerCase() === searchTerm) ||
                            (board.players.black && getSimplePlayerName(board.players.black.name).toLowerCase() === searchTerm)) {

                            foundGame = { board, physicalTable };
                            break;
                        }
                    }
                }
                if (foundGame) break;
            }

            if (foundGame) {
                showSimplifiedScoreModal(foundGame.board, foundGame.physicalTable);
            } else {
                // CORRECTION: Ne pas alerter si on vient d'un scan QR (car on va chercher da// --- NOUVEAU: Gestion Suivi Multi-Joueurs ---
                let watchedPlayers = [];
                let lastWatchedResults = {}; // Pour détecter les changements d'état

                // Initialisation au chargement
                try {
                    const stored = localStorage.getItem('chessRoomWatchedPlayers');
                    if (stored) {
                        watchedPlayers = JSON.parse(stored);
                        if (!Array.isArray(watchedPlayers)) watchedPlayers = [];
                    }
                } catch (e) {
                    watchedPlayers = [];
                }

                function enableTrackingMode(playerName) {
                    if (!playerName) return;

                    // Ajouter si pas déjà présent
                    if (!watchedPlayers.includes(playerName)) {
                        watchedPlayers.push(playerName);
                        localStorage.setItem('chessRoomWatchedPlayers', JSON.stringify(watchedPlayers));
                    }

                    document.getElementById('playerSelectContainer').style.display = 'none';
                    document.getElementById('playerTrackingContainer').style.display = 'block';

                    // Mettre à jour l'affichage
                    checkAndRedirectPlayer();
                }

                window.stopAutoWatch = function (nameToRemove = null) {
                    if (nameToRemove) {
                        watchedPlayers = watchedPlayers.filter(p => p !== nameToRemove);
                    } else {
                        if (confirm("Arrêter le suivi de TOUS les joueurs ?")) {
                            watchedPlayers = [];
                        } else {
                            return;
                        }
                    }
                    localStorage.setItem('chessRoomWatchedPlayers', JSON.stringify(watchedPlayers));

                    // Nettoyer les états précédents pour ce joueur
                    if (nameToRemove && lastWatchedResults[nameToRemove]) {
                        delete lastWatchedResults[nameToRemove];
                    } else if (!nameToRemove) {
                        lastWatchedResults = {};
                    }

                    if (watchedPlayers.length === 0) {
                        document.getElementById('playerSelectContainer').style.display = 'block';
                        document.getElementById('playerTrackingContainer').style.display = 'none';
                        document.getElementById('trackingLiveInfo').innerHTML = '';
                        // Supprimer le bouton "Ajouter" s'il existe
                        const addBtn = document.getElementById('btnAddAnotherPlayer');
                        if (addBtn) addBtn.remove();
                    } else {
                        checkAndRedirectPlayer();
                    }

                    if (typeof renderAllTables === 'function') renderAllTables();
                    updateSpectatorPlayerList();
                };

                // Fonction de vérification et mise à jour (Multi-joueurs)
                function checkAndRedirectPlayer() {
                    if (watchedPlayers.length === 0) return;

                    const container = document.getElementById('trackingLiveInfo');
                    if (!container) return;

                    container.innerHTML = ''; // Reset des cartes

                    // Gestion du bouton "Ajouter un joueur" (sous le bouton rouge)
                    let addBtn = document.getElementById('btnAddAnotherPlayer');
                    if (!addBtn) {
                        addBtn = document.createElement('button');
                        addBtn.id = 'btnAddAnotherPlayer';
                        addBtn.className = 'btn-info';
                        addBtn.innerHTML = '➕ Suivre un autre joueur';
                        addBtn.style.width = '100%';
                        addBtn.style.marginTop = '10px';
                        addBtn.onclick = () => {
                            document.getElementById('playerSelectContainer').style.display = 'block';
                            document.getElementById('playerTrackingContainer').style.display = 'none';
                        };
                        // Insérer après le bouton rouge (qui est le dernier enfant de playerTrackingContainer normalement)
                        const trackingContainer = document.getElementById('playerTrackingContainer');
                        trackingContainer.appendChild(addBtn);
                    }

                    // S'assurer que le bouton rouge est visible et a le bon texte
                    // (Le bouton rouge est statique dans le HTML, on ne le touche pas, mais on ajoute le bouton bleu après)

                    watchedPlayers.forEach(name => {
                        const card = document.createElement('div');
                        card.className = 'info-box';
                        card.style.marginBottom = '15px';
                        card.style.position = 'relative';

                        // Bouton supprimer ce joueur
                        const delBtn = document.createElement('button');
                        delBtn.innerHTML = '🗑️';
                        delBtn.style.position = 'absolute';
                        delBtn.style.top = '5px';
                        delBtn.style.right = '5px';
                        delBtn.style.background = 'none';
                        delBtn.style.border = 'none';
                        delBtn.style.cursor = 'pointer';
                        delBtn.style.fontSize = '1.2em';
                        delBtn.onclick = () => stopAutoWatch(name);
                        card.appendChild(delBtn);

                        const searchTerm = name.toLowerCase();
                        let foundGame = null;
                        let playerColor = null;

                        // Recherche de la partie
                        for (const physicalTable of physicalTables) {
                            for (const board of physicalTable.boards) {
                                if (board.players) {
                                    const whiteName = board.players.white ? board.players.white.name.toLowerCase().trim() : '';
                                    const blackName = board.players.black ? board.players.black.name.toLowerCase().trim() : '';

                                    if (whiteName === searchTerm || whiteName.includes(searchTerm)) {
                                        foundGame = { physicalTable, board, color: 'white' };
                                        playerColor = 'white';
                                        break;
                                    }
                                    if (blackName === searchTerm || blackName.includes(searchTerm)) {
                                        foundGame = { physicalTable, board, color: 'black' };
                                        playerColor = 'black';
                                        break;
                                    }
                                }
                            }
                            if (foundGame) break;
                        }

                        if (foundGame) {
                            const { board, physicalTable } = foundGame;
                            const whitePlayer = board.players.white;
                            const blackPlayer = board.players.black;

                            let opponentName = playerColor === 'white' ? blackPlayer.name : whitePlayer.name;
                            let myColorDisplay = playerColor === 'white' ? "⚪ Blancs" : "⚫ Noirs";

                            let statusHTML = '';
                            let isFinished = false;
                            let resultText = '';

                            // Vérification du résultat
                            if (board.score.white !== '' || board.score.black !== '') {
                                isFinished = true;
                                resultText = `${board.score.white}-${board.score.black}`;
                                if (resultText === '1/2-1/2') resultText = '½-½';

                                let resultClass = 'info';
                                let resultMessage = 'Partie Terminée';

                                // Analyse du résultat pour le joueur suivi
                                if (playerColor === 'white') {
                                    if (board.score.white === '1') { resultClass = 'success'; resultMessage = '🏆 Victoire !'; }
                                    else if (board.score.white === '0') { resultClass = 'error'; resultMessage = '❌ Défaite'; }
                                    else { resultClass = 'warning'; resultMessage = '⚖️ Nulle'; }
                                } else {
                                    if (board.score.black === '1') { resultClass = 'success'; resultMessage = '🏆 Victoire !'; }
                                    else if (board.score.black === '0') { resultClass = 'error'; resultMessage = '❌ Défaite'; }
                                    else { resultClass = 'warning'; resultMessage = '⚖️ Nulle'; }
                                }

                                statusHTML = `
                    <div class="notification ${resultClass}" style="position: static; opacity: 1; transform: none; margin-top: 10px; text-align: center;">
                        <div style="font-size: 1.5em; margin-bottom: 5px;">${resultText}</div>
                        <div>${resultMessage}</div>
                    </div>
                `;

                                // --- POPUP SUR LE PLAN (NOUVEAU) ---
                                // Si le résultat vient d'apparaître (n'était pas là avant)
                                if (!lastWatchedResults[name]) {
                                    // On marque comme vu pour ne pas spammer
                                    lastWatchedResults[name] = resultText;

                                    // Afficher une notification sticky
                                    showNotification(`Résultat pour ${formatPlayerName(name)} : ${resultText} (${resultMessage})`, resultClass, 10000);

                                    // Optionnel : Afficher une modale spéciale
                                    // alert(`Résultat pour ${name} : ${resultText}`);
                                }

                            } else {
                                statusHTML = `
                    <div style="margin-top: 10px; text-align: center; color: #2196F3; font-weight: bold;">
                        ⏳ Partie en cours...
                    </div>
                `;
                                // Reset de l'état si la partie repasse en cours (correction d'erreur)
                                if (lastWatchedResults[name]) {
                                    delete lastWatchedResults[name];
                                }
                            }

                            card.innerHTML += `
                <h3 style="margin-top: 0; color: #2c3e50;">${formatPlayerName(name)}</h3>
                <div style="font-size: 1.1em; margin-bottom: 5px;">
                    Table <strong style="color: #e74c3c; font-size: 1.3em;">${board.boardNumber}</strong>
                </div>
                <div style="margin-bottom: 5px;">
                    ${myColorDisplay} <span style="color: #7f8c8d;">vs</span> <strong>${formatPlayerName(opponentName)}</strong>
                </div>
                ${statusHTML}
            `;
                        } else {
                            card.innerHTML += `
                <h3 style="margin-top: 0; color: #2c3e50;">${formatPlayerName(name)}</h3>
                <div style="color: #999; font-style: italic;">
                    Aucune partie trouvée dans cette ronde.
                </div>
            `;
                        }
                        container.appendChild(card);
                    });
                } if (!fromQR) {
                    alert(`Aucune partie non terminée trouvée pour "${name}" dans cette ronde.`);
                    document.getElementById('playerHomeModal').style.display = 'flex'; // Retour accueil
                }

                // CORRECTION: Si on vient d'un QR et qu'on n'a pas trouvé de partie non terminée,
                // c'est que le résultat est déjà saisi.
                if (fromQR) {
                    showNotification("Cette partie est déjà terminée.", "info");
                    document.getElementById('playerHomeModal').style.display = 'flex'; // Retour accueil
                }
            }
        }


        // --- NOUVELLE FONCTION: Trouver la table d'un joueur depuis son QR-code ---
        function findPlayerTable(playerName, playerElo) {
            const searchTerm = playerName.toLowerCase().trim();
            let foundGame = null;
            let playerColor = null;

            // Chercher le joueur dans la ronde actuelle
            for (const physicalTable of physicalTables) {
                for (const board of physicalTable.boards) {
                    if (board.players) {
                        const whiteName = board.players.white ? board.players.white.name.toLowerCase().trim() : '';
                        const blackName = board.players.black ? board.players.black.name.toLowerCase().trim() : '';

                        if (whiteName === searchTerm) {
                            foundGame = { board, physicalTable };
                            playerColor = 'white';
                            break;
                        } else if (blackName === searchTerm) {
                            foundGame = { board, physicalTable };
                            playerColor = 'black';
                            break;
                        }
                    }
                }
                if (foundGame) break;
            }

            if (foundGame) {
                // === MODIFICATION START ===

                // 1. Cacher toutes les modales (accueil, recherche)
                document.getElementById('playerHomeModal').style.display = 'none';
                document.getElementById('playerTextSearchModal').style.display = 'none';
                document.getElementById('playerListSearchModal').style.display = 'none';

                // 2. Passer en mode plan
                document.body.classList.add('player-plan-view-mode');
                setTool('pan');
                renderAllTables();

                // 3. Mettre en évidence et scroller
                highlightPlayerTable(foundGame.physicalTable, foundGame.board);

                // 4. Afficher le popup d'info
                showPlayerTableInfo(foundGame.board, foundGame.physicalTable, playerColor, playerName, playerElo);

                // === MODIFICATION END ===
            } else {
                showNotification(`Partie non trouvée pour "${playerName}" dans cette ronde.`, 'error');
                // Ré-afficher la modale d'accueil si non trouvé
                if (isPlayerMode) {
                    document.getElementById('playerHomeModal').style.display = 'flex';
                }
            }
        }

        function closePlayerTableInfo() {
            document.getElementById('playerTableInfoModal').style.display = 'none';

            // Enlever la surbrillance
            document.querySelectorAll('.table-element').forEach(el => {
                el.classList.remove('highlight-player');
            });

            // Revenir à l'accueil joueur (le hub central)
            if (isPlayerMode) {
                // NOUVEAU: Nettoyer le joueur suivi en mode joueur pour ne pas garder la surbrillance
                localStorage.removeItem('chessRoomWatchedPlayer');

                // Quitter le mode plan
                document.body.classList.remove('player-plan-view-mode');
                // Afficher le hub
                document.getElementById('playerHomeModal').style.display = 'flex';

                // Rafraîchir l'affichage pour enlever le style jaune
                renderAllTables();
            }
        }

        // MODIFIÉ: Version unique et corrigée de showPlayerTableInfo
        // MODIFIÉ: Le popup ne se ferme plus automatiquement
        function showPlayerTableInfo(board, physicalTable, playerColor, playerName, playerElo) {
            if (!board.players) return;

            // --- Récupération des infos ---
            const boardNum = board.boardNumber;
            const whitePlayer = board.players.white;
            const blackPlayer = board.players.black;

            let opponentName, opponentElo, colorText;
            if (playerColor === 'white') {
                opponentName = getSimplePlayerName(blackPlayer.name);
                opponentElo = blackPlayer.elo || '';
                colorText = '⚪ Blancs';
            } else {
                opponentName = getSimplePlayerName(whitePlayer.name);
                opponentElo = whitePlayer.elo || '';
                colorText = '⚫ Noirs';
            }

            const playerDisplayName = `${playerName}${playerElo ? ' (' + playerElo + ')' : ''}`;
            const opponentDisplayName = `${opponentName}${opponentElo ? ' (' + opponentElo + ')' : ''}`;

            // --- Mise à jour du DOM ---
            document.getElementById('playerTableInfoName').textContent = playerDisplayName;
            document.getElementById('playerTableInfoTable').textContent = boardNum;
            document.getElementById('playerTableInfoColor').textContent = colorText;
            document.getElementById('playerTableInfoOpponent').textContent = opponentDisplayName;

            // --- Affichage ---
            const modal = document.getElementById('playerTableInfoModal');
            modal.style.display = 'block';
            // On réactive les clics sur la modale pour pouvoir utiliser le bouton
            modal.style.pointerEvents = "auto";

            // --- Gestion Fermeture (Uniquement manuelle) ---
            const closeBtn = document.getElementById('closePlayerTableInfoBtn');

            // On supprime les anciens listeners pour éviter les doublons
            const newBtn = closeBtn.cloneNode(true);
            closeBtn.parentNode.replaceChild(newBtn, closeBtn);

            newBtn.onclick = () => {
                closePlayerTableInfo();
            };
        }

        // Fonction pour mettre en évidence la table du joueur sur le plan
        function highlightPlayerTable(physicalTable, board) {
            // Enlever toute mise en évidence précédente
            document.querySelectorAll('.table-element').forEach(el => {
                el.classList.remove('highlight-player');
            });

            // Trouver l'élément DOM de la table
            const tableElement = document.querySelector(`[data-table-id="${physicalTable.id}"]`);
            if (tableElement) {
                tableElement.classList.add('highlight-player');

                // Scroller vers la table si nécessaire
                tableElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }


        // Afficher la modale de saisie simplifiée
        function showSimplifiedScoreModal(board, physicalTable) {
            if (!board.players) return;

            const pWhite = getSimplePlayerName(board.players.white.name);
            const pBlack = getSimplePlayerName(board.players.black.name);
            const boardNum = board.boardNumber;

            document.getElementById('simplifiedBoardNum').textContent = boardNum;
            document.getElementById('simplifiedWhitePlayer').textContent = pWhite;
            document.getElementById('simplifiedBlackPlayer').textContent = pBlack;

            const btnWhite = document.getElementById('btnWinWhite');
            btnWhite.innerHTML = `<strong>1-0</strong><br>(${pWhite} gagne)`;
            btnWhite.onclick = () => saveSimplifiedScore(boardNum, '1-0');

            const btnDraw = document.getElementById('btnDraw');
            btnDraw.innerHTML = `<strong>½-½</strong><br>(Match Nul)`;
            btnDraw.onclick = () => saveSimplifiedScore(boardNum, '1/2-1/2');

            const btnBlack = document.getElementById('btnWinBlack');
            btnBlack.innerHTML = `<strong>0-1</strong><br>(${pBlack} gagne)`;
            btnBlack.onclick = () => saveSimplifiedScore(boardNum, '0-1');

            document.getElementById('simplifiedScoreModal').style.display = 'flex';
        }

        // NOUVEAU: Fermer la modale simplifiée et retourner
        function closeSimplifiedScoreModal() {
            document.getElementById('simplifiedScoreModal').style.display = 'none';
            // Si on était en mode plan, on y reste. Sinon, on retourne à l'accueil
            if (!document.body.classList.contains('player-plan-view-mode') && isPlayerMode) {
                document.getElementById('playerHomeModal').style.display = 'flex';
            }
        }

        // Enregistrer le score depuis la modale simplifiée
        function saveSimplifiedScore(boardNum, result) {
            const { board, physicalTable } = findBoard(boardNum);
            if (!board) return;

            // CORRECTION: Modifier AVANT de sauvegarder
            if (result === "1-0") {
                board.score.white = "1";
                board.score.black = "0";
            } else if (result === "0-1") {
                board.score.white = "0";
                board.score.black = "1";
            } else if (result === "1/2-1/2") {
                board.score.white = "1/2";
                board.score.black = "1/2";
            }

            // NOUVEAU: Timestamp
            board.scoreTimestamp = Date.now();

            updateTableDisplay(physicalTable.id);
            updateStats();

            saveHistoryState(); // Sauvegarder APRÈS

            // MODIFIÉ: Logique de fermeture/retour
            document.getElementById('simplifiedScoreModal').style.display = 'none';
            showNotification(`Résultat ${result} enregistré pour l'échiquier ${boardNum} !`, 'success');

            // NOUVEAU: Retour automatique à l'accueil
            if (isPlayerMode) {
                returnToPlayerHome();
            }
        }



        // --- Initialisation ---
        document.addEventListener('DOMContentLoaded', async () => {

            // NOUVEAU: Ouvrir le premier accordéon par défaut (Statistiques)
            const firstAccordionHeader = document.querySelector('.sidebar-section h3');
            if (firstAccordionHeader) {
                toggleAccordion(firstAccordionHeader);
            }


            // CORRECTION: Recharger la stratégie de sauvegarde depuis localStorage
            const savedStrategy = localStorage.getItem(STRATEGY_KEY) || 'server_only';
            const strategySelect = document.getElementById('saveStrategySelector');
            if (strategySelect) {
                strategySelect.value = savedStrategy;
            }

            // Note: Le chargement des données est maintenant géré par chessroom-save-system.js
            // qui s'occupe de charger depuis le serveur ou le localStorage selon la configuration

            // Charger l'état par défaut si aucune donnée n'est chargée
            if (Object.keys(roundsStore).length === 0 || !roundsStore['ronde1']) {
                loadStateFromStore('ronde1');
            }

            document.getElementById('scoreModal').addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    hideScoreModal();
                }
                if (e.key === 'Enter') {
                    saveScoreFromModal();
                }
            });

            // NOUVEAU: Écouteur pour la modale de recherche texte joueur
            document.getElementById('playerTextSearchModal').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    findPlayerFromTextSearch();
                }
            });

            // NOUVEAU: Écouteur pour la modale de recherche liste joueur
            document.getElementById('playerListSearchModal').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    findPlayerFromListSearch();
                }
            });

            // NOUVEAU: Écouteur pour la modale de login joueur
            document.getElementById('playerLoginModal').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    loginAsPlayer();
                }
            });

            // NOUVEAU: Écouteur pour la modale de logout joueur
            document.getElementById('playerLogoutConfirmModal').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    attemptPlayerLogout();
                }
            });

            setTimeout(() => {
                // MODIFIÉ: Vue par défaut
                fitAllTables();
            }, 500);

            // NOUVEAU: Écouteur de synchronisation entre onglets
            window.addEventListener('storage', (e) => {
                // CORRECTION: On écoute la clé de stratégie
                if (e.key === STRATEGY_KEY && e.newValue) {
                    const strategySelect = document.getElementById('saveStrategySelector');
                    if (strategySelect) {
                        strategySelect.value = e.newValue;
                        // On simule le changement pour déclencher les rechargements
                        strategySelect.dispatchEvent(new Event('change'));
                    }
                }

                if (e.key === SAVE_KEY && e.newValue) {

                    if (isPlayerMode) return;

                    if (document.querySelector('.modal-overlay[style*="display: flex"]') || document.getElementById('scoreModal').style.display === 'flex') {
                        console.log('Synchronisation en attente, modale ouverte.');
                        return;
                    }

                    // CORRECTION: Ne synchroniser que si on est en mode 'local_only'
                    // (le mode serveur est géré par le timer de synchro)
                    const currentStrategy = document.getElementById('saveStrategySelector').value;
                    if (currentStrategy !== 'local_only') {
                        return;
                    }

                    console.log('Changement de sauvegarde (local) détecté, rafraîchissement...');
                    try {
                        const data = JSON.parse(e.newValue);
                        if (data && data.roundsStore) {
                            roundsStore = data.roundsStore;
                            arbiterPassword = data.arbiterPassword || null;

                            if (!roundsStore[currentRoundKey]) {
                                currentRoundKey = data.currentRoundKey || 'ronde1';
                            }

                            loadStateFromStore(currentRoundKey);
                            updateRoundSelector();

                            showNotification('Plan mis à jour (synchro. locale)', 'info');
                        }
                    } catch (err) {
                        console.error('Erreur de synchronisation:', err);
                    }
                }
            });
        });

        // ========================================
        // SAUVEGARDE ET SYNCHRONISATION AUTOMATIQUE
        // ========================================
        // Note: Les intervalles de sauvegarde automatique sont maintenant gérés
        // par chessroom-save-system.js qui configure les timers selon les options
        // choisies par l'utilisateur (Mode Arbitre/Spectateur + cases à cocher)

        // --- NOUVELLES FONCTIONS DE GESTION DE TOURNOI ---

        function deleteCurrentRound() {
            // 1. Vérification de sécurité
            const keys = Object.keys(roundsStore);
            if (keys.length <= 1) {
                alert("Impossible de supprimer la seule ronde existante. Pour recommencer à zéro, utilisez le bouton 'Nouveau Tournoi'.");
                return;
            }

            // 2. Demander confirmation
            if (!confirm(`Êtes-vous sûr de vouloir supprimer DÉFINITIVEMENT la ${currentRoundKey.replace('r', 'R')} ?\n\n⚠️ IMPORTANT : Les rondes suivantes seront renumérotées (ex: la Ronde 3 deviendra la Ronde 2).`)) {
                return;
            }

            // 3. Récupérer toutes les clés et les trier numériquement (pour éviter l'ordre ronde1, ronde10, ronde2)
            const sortedKeys = keys.sort((a, b) => {
                const numA = parseInt(a.replace('ronde', ''));
                const numB = parseInt(b.replace('ronde', ''));
                return numA - numB;
            });

            // 4. Créer une liste des données des rondes que l'on GARDE (on exclut la ronde actuelle)
            const remainingRoundsData = sortedKeys
                .filter(key => key !== currentRoundKey)
                .map(key => roundsStore[key]);

            // 5. Reconstruire le roundsStore proprement (ronde1, ronde2, ronde3...)
            // On vide l'ancien store et on le remplit avec les nouvelles clés séquentielles
            roundsStore = {};

            remainingRoundsData.forEach((data, index) => {
                const newKey = `ronde${index + 1}`; // index 0 devient ronde1, index 1 devient ronde2, etc.
                roundsStore[newKey] = data;
            });

            // 6. Basculer vers la dernière ronde disponible (souvent celle qui vient d'être renommée)
            const newKeys = Object.keys(roundsStore);
            const lastKey = newKeys[newKeys.length - 1];

            // Charger la nouvelle vue
            loadStateFromStore(lastKey);
            updateRoundSelector();
            autoSaveToLocalStorage();

            saveHistoryState(); // Sauvegarder APRÈS
            showNotification("Ronde supprimée et numérotation réorganisée.", "success");
        }

        function createNewTournament() {
            // On réutilise la logique existante de clearAll mais avec un message spécifique
            // clearAll() contient déjà un confirm(), mais pour être sûr du message "Nouveau Tournoi":

            if (confirm("⚠️ ATTENTION : Vous allez créer un NOUAU TOURNOI.\n\nToutes les données actuelles (toutes les rondes, joueurs, scores, configurations) seront effacées.\n\nVoulez-vous vraiment continuer ?")) {
                // On appelle la logique de nettoyage sans redemander confirmation (on bypass le confirm du clearAll en exécutant son contenu directement ou en le modifiant légèrement, mais ici on va appeler la logique de reset manuellement pour être propre).

                localStorage.removeItem(SAVE_KEY);
                localStorage.removeItem(SAVE_KEY_TIMESTAMP);

                // Réinitialisation des variables globales
                physicalTables = [];
                rooms = [];
                nextPhysicalTableId = 1;
                nextRoomId = 1;
                nextBoardNumber = 1;
                historyStack = [];
                redoStack = [];

                // Réinitialisation du store
                roundsStore = {};
                currentRoundKey = 'ronde1'; // On repart à la ronde 1

                // Charger l'état vide
                loadStateFromStore('ronde1');
                updateRoundSelector();

                document.getElementById('canvas').innerHTML = '';
                updateStats();

                saveHistoryState(); // Sauvegarder l'état vide

                showNotification("Nouveau tournoi créé.", "success");
            }
        }
    </script>

    <script>
        // =====================================================
        // MODULE INSCRIPTIONS & POINTAGE (V1) - INITIALIZATION
        // =====================================================

        const REG_APP_ID = 'chess-reg-v1-local';
        let REG_TOURNAMENT_ID = 'OPEN-' + new Date().toISOString().slice(0, 10).replace(/-/g, '');
        let REG_CACHE = [];
        let REG_SORT = { key: 'lastName', dir: 'asc' };
        let REG_FILTERS = { q: '', status: '', payment: '' };

        // --- Helpers Manquants ---
        function normalize(str) { return str ? str.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").trim() : ""; }
        function escapeHtml(text) {
            if (!text) return "";
            return text.toString()
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }
        function generateUUID() {
            if (typeof crypto !== 'undefined' && crypto.randomUUID) return crypto.randomUUID();
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // --- Store Local ---
        class RegistrationStore {
            constructor(tid) {
                this.tid = tid;
                this.key = `ls:${REG_APP_ID}:${this.tid}:registrations`;
                if (!localStorage.getItem(this.key)) localStorage.setItem(this.key, JSON.stringify([]));
            }
            _read() { return JSON.parse(localStorage.getItem(this.key) || '[]'); }
            _write(arr) { localStorage.setItem(this.key, JSON.stringify(arr)); }
            _sync() {
                // Trigger background save to server
                if (typeof saveToServer === 'function') {
                    // Use setTimeout to ensure it doesn't block the UI thread at all
                    setTimeout(() => saveToServer(), 0);
                }
            }

            getAll() { return this._read(); }
            add(reg) {
                const arr = this._read();
                arr.push(reg);
                this._write(arr);
                this._sync();
                return arr;
            }
            addBatch(regs) {
                const arr = this._read();
                regs.forEach(r => arr.push(r));
                this._write(arr);
                // No sync here, caller must handle it or we sync once
                // this._sync(); 
                return arr;
            }
            update(id, patch) {
                const arr = this._read();
                const i = arr.findIndex(r => r.id === id);
                if (i >= 0) {
                    arr[i] = { ...arr[i], ...patch };
                    this._write(arr);
                    this._sync();
                }
                return arr;
            }
            purge() {
                this._write([]);
                this._sync();
                // Clear import status message if it exists
                const statusDiv = document.getElementById('ffeImportStatus');
                if (statusDiv) statusDiv.innerHTML = '';
                return [];
            }
            setAll(list) {
                this._write(list);
                // No sync here to avoid loop when loading from server
                return list;
            }
        }

        let RegDB = new RegistrationStore(REG_TOURNAMENT_ID);


        // ===== CONFIGURATION =====
        const SAVE_CONFIG = {
            modes: {
                ARBITER: 'arbiter', // Peut sauvegarder
                SPECTATOR: 'spectator' // Lecture seule
            },
            intervals: {
                LOCAL_SAVE: 30000, // 30 secondes
                SERVER_SYNC: 5000 // 5 secondes
            },
            maxHistoryDisplay: 20 // Nombre d'historiques affichés
        };

        // Variable locale pour ce module
        let lastSaveStatus = { type: '', message: '', timestamp: null };

        // ===== FONCTIONS DE STATUT =====

        function showSaveStatus(type, message) {
            const statusDiv = document.getElementById('saveStatus');
            if (!statusDiv) return;

            const icons = {
                success: '✅',
                error: '❌',
                warning: '⚠️',
                info: 'ℹ️',
                sync: '🔄'
            };

            const colors = {
                success: '#d4edda',
                error: '#f8d7da',
                warning: '#fff3cd',
                info: '#d1ecf1',
                sync: '#e7f3ff'
            };

            const timestamp = new Date().toLocaleTimeString('fr-FR');

            statusDiv.style.display = 'block';
            statusDiv.style.background = colors[type] || colors.info;
            statusDiv.style.border = `1px solid ${colors[type]}`;
            statusDiv.innerHTML = `${icons[type]} ${message} <small>(${timestamp})</small>`;

            lastSaveStatus = { type, message, timestamp };

            // Masquer après 5 secondes pour les succès
            if (type === 'success') {
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 5000);
            }
        }

        // ===== FONCTIONS DE SAUVEGARDE =====

        async function saveToLocalStorage() {
            try {
                saveCurrentStateToStore();

                const registrations = RegDB.getAll();
                console.log('💾 LOCAL: Saving registrations:', registrations.length, 'players');

                const dataToSave = {
                    roundsStore: JSON.parse(JSON.stringify(roundsStore)),
                    currentRoundKey: currentRoundKey,
                    arbiterPassword: arbiterPassword,
                    registrations: registrations, // Sauvegarde des inscrits
                    tournamentConfig: tournamentConfig, // Sauvegarde de la configuration du tournoi
                    lastModified: Date.now()
                };

                // Nettoyer les handlers
                Object.values(dataToSave.roundsStore).forEach(roundState => {
                    if (roundState.physicalTables) {
                        roundState.physicalTables.forEach(t => {
                            delete t.mouseDownHandler;
                        });
                    }
                });

                const json = JSON.stringify(dataToSave);
                localStorage.setItem(SAVE_KEY, json);
                localStorage.setItem(SAVE_KEY_TIMESTAMP, Date.now().toString());

                showSaveStatus('success', '💾 Sauvegarde locale réussie');
                return true;
            } catch (error) {
                console.error('Erreur sauvegarde locale:', error);
                showSaveStatus('error', 'Erreur lors de la sauvegarde locale');
                return false;
            }
        }

        async function saveToServer(force = false) {
            if (!USE_SERVER_SYNC) {
                showSaveStatus('warning', 'Synchronisation serveur désactivée');
                return false;
            }

            if (currentSaveMode !== SAVE_CONFIG.modes.ARBITER) {
                showSaveStatus('warning', '⚠️ Mode spectateur : sauvegarde serveur bloquée');
                return false;
            }

            try {
                saveCurrentStateToStore();

                const registrations = RegDB.getAll();
                console.log('💾 Saving registrations:', registrations.length, 'players');
                console.log('💾 Registration data:', registrations);

                const dataToSave = {
                    roundsStore: JSON.parse(JSON.stringify(roundsStore)),
                    currentRoundKey: currentRoundKey,
                    arbiterPassword: arbiterPassword,
                    registrations: registrations, // NOUVEAU: Sauvegarde des inscrits
                    tournamentConfig: tournamentConfig, // NOUVEAU: Sauvegarde de la configuration du tournoi
                    lastModified: Date.now(),
                    savedBy: currentSaveMode
                };

                // Optimistic Locking: Only send timestamp if NOT forced
                if (!force) {
                    dataToSave.clientTimestamp = lastServerTimestamp;
                }

                // Nettoyer les handlers
                Object.values(dataToSave.roundsStore).forEach(roundState => {
                    if (roundState.physicalTables) {
                        roundState.physicalTables.forEach(t => {
                            delete t.mouseDownHandler;
                        });
                    }
                });

                const response = await fetch(SERVER_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(dataToSave)
                });

                if (response.status === 409) {
                    const errorData = await response.json();
                    alert("⚠️ CONFLIT DE VERSION !\n\nQuelqu'un d'autre a modifié les données pendant que vous travailliez.\n\nVos modifications n'ont PAS été sauvegardées pour éviter d'écraser leur travail.\n\nVeuillez recharger la page pour voir les nouvelles données.");
                    showSaveStatus('error', 'Conflit de version - Sauvegarde annulée');
                    return false;
                }

                if (response.ok) {
                    const result = await response.json();
                    console.log("✅ Save Response:", result); // Debug Log
                    if (result.success) {
                        if (result.timestamp) lastServerTimestamp = result.timestamp;
                        showSaveStatus('success', `☁️ Sauvegarde serveur réussie`);
                        return true;
                    }
                } else {
                    console.error("❌ Server Error:", response.status, response.statusText); // Debug Log
                    showSaveStatus('error', 'Erreur serveur : ' + response.status);
                }
                return false;
            } catch (error) {
                console.error('❌ Erreur serveur (Catch):', error);
                showSaveStatus('error', 'Impossible de contacter le serveur');
                return false;
            }
        }

        async function forceSaveToServer() {
            if (!confirm("Forcer la sauvegarde ? Cela enverra toutes les données actuelles au serveur.")) return;
            console.log("⚠️ Force Save Initiated");
            const success = await saveToServer();
            if (success) alert("Sauvegarde forcée réussie !");
            else alert("Echec de la sauvegarde forcée. Vérifiez la console.");
        }

        async function loadFromServer(isAutoSync = false) {
            if (!USE_SERVER_SYNC) return false;

            try {
                if (!isAutoSync) {
                    showSaveStatus('sync', '🔄 Chargement depuis le serveur...');
                }

                // Add timestamp to prevent caching
                const response = await fetch(SERVER_URL + '?t=' + new Date().getTime());

                // Get Timestamp Header for Optimistic Locking
                const tsHeader = response.headers.get('X-Data-Timestamp');
                if (tsHeader) {
                    lastServerTimestamp = parseInt(tsHeader, 10);
                    console.log("Server Timestamp:", lastServerTimestamp);
                }

                if (!response.ok) {
                    if (!isAutoSync) showSaveStatus('error', 'Erreur lors du chargement serveur');
                    return false;
                }

                const data = await response.json();

                // NOUVEAU: Restauration des inscrits (Indépendant de roundsStore)
                if (data.registrations && Array.isArray(data.registrations)) {
                    RegDB.setAll(data.registrations);
                    loadRegistrations();
                }

                if (data && data.roundsStore && typeof data.roundsStore === 'object' &&
                    Object.keys(data.roundsStore).length > 0) {

                    // Vérifier si les données ont changé
                    const currentJson = JSON.stringify(roundsStore);
                    const serverJson = JSON.stringify(data.roundsStore);

                    if (currentJson === serverJson) {
                        if (!isAutoSync) showSaveStatus('info', 'ℹ️ Les données sont déjà à jour');
                        // On retourne true car le chargement (même partiel ou inutile) a réussi techniquement
                        return true;
                    }

                    // CORRECTION: En mode spectateur, ne JAMAIS demander confirmation
                    // En mode arbitre, demander uniquement si action manuelle ET données locales existent
                    if (!isAutoSync &&
                        currentSaveMode === SAVE_CONFIG.modes.ARBITER &&
                        Object.keys(roundsStore).length > 0) {
                        if (!confirm('⚠️ Charger les données du serveur écrasera vos modifications locales. Continuer ?')) {
                            showSaveStatus('warning', 'Chargement annulé');
                            return false;
                        }
                    }

                    roundsStore = data.roundsStore;
                    currentRoundKey = data.currentRoundKey || 'ronde1';
                    arbiterPassword = data.arbiterPassword || null;

                    // NOUVEAU: Restauration de la configuration du tournoi
                    if (data.tournamentConfig) {
                        tournamentConfig = data.tournamentConfig;
                        // Sauvegarder aussi dans localStorage
                        localStorage.setItem('chessroom-tournamentConfig', JSON.stringify(tournamentConfig));
                    }

                    // Migration des données
                    Object.values(roundsStore).forEach(roundState => {
                        if (!roundState.physicalTables) roundState.physicalTables = [];
                        if (!roundState.rooms) roundState.rooms = [];
                        if (!roundState.nextRoomId) roundState.nextRoomId = 1;
                        roundState.physicalTables.forEach(pt => {
                            if (!pt.arbiterComment) pt.arbiterComment = { text: "", flag: "none" };
                            pt.boards.forEach(b => {
                                if (b.score === undefined) b.score = { white: "", black: "" };
                                if (b.players && b.players.white && typeof b.players.white === 'string') {
                                    b.players.white = { name: b.players.white, elo: null };
                                    b.players.black = { name: b.players.black, elo: null };
                                }
                                if (!b.players) {
                                    b.players = { white: { name: "", elo: null }, black: { name: "", elo: null } };
                                }
                            });
                        });
                    });

                    loadStateFromStore(currentRoundKey);
                    updateRoundSelector();

                    if (!isAutoSync) {
                        showSaveStatus('success', '✅ Données chargées depuis le serveur');
                        checkAndNotifyPlayer();
                    }
                    if (typeof checkAndRedirectPlayer === 'function') {
                        checkAndRedirectPlayer();
                    }
                    return true;
                } else {
                    if (!isAutoSync) showSaveStatus('warning', 'Aucune donnée sur le serveur');
                    return false;
                }
            } catch (error) {
                console.error('Erreur chargement serveur:', error);
                if (!isAutoSync) showSaveStatus('error', 'Erreur lors du chargement');
                return false;
            }
        }

        // NOUVEAU: Fonction pour charger depuis localStorage
        async function loadFromLocalStorage() {
            try {
                const saved = localStorage.getItem(SAVE_KEY);
                if (!saved) {
                    showSaveStatus('info', 'Aucune sauvegarde locale trouvée');
                    return false;
                }

                const data = JSON.parse(saved);

                if (data && data.roundsStore && typeof data.roundsStore === 'object') {
                    roundsStore = data.roundsStore;
                    currentRoundKey = data.currentRoundKey || 'ronde1';
                    arbiterPassword = data.arbiterPassword || null;

                    // Restauration des inscrits
                    if (data.registrations && Array.isArray(data.registrations)) {
                        RegDB.setAll(data.registrations);
                        loadRegistrations();
                    }

                    // Restauration de la configuration du tournoi
                    if (data.tournamentConfig) {
                        tournamentConfig = data.tournamentConfig;
                    }

                    // Migration des données
                    Object.values(roundsStore).forEach(roundState => {
                        if (!roundState.physicalTables) roundState.physicalTables = [];
                        if (!roundState.rooms) roundState.rooms = [];
                        if (!roundState.nextRoomId) roundState.nextRoomId = 1;
                        roundState.physicalTables.forEach(pt => {
                            if (!pt.arbiterComment) pt.arbiterComment = { text: "", flag: "none" };
                            pt.boards.forEach(b => {
                                if (b.score === undefined) b.score = { white: "", black: "" };
                                if (b.players && b.players.white && typeof b.players.white === 'string') {
                                    b.players.white = { name: b.players.white, elo: null };
                                    b.players.black = { name: b.players.black, elo: null };
                                }
                                if (!b.players) {
                                    b.players = { white: { name: "", elo: null }, black: { name: "", elo: null } };
                                }
                            });
                        });
                    });

                    loadStateFromStore(currentRoundKey);
                    updateRoundSelector();

                    showSaveStatus('success', '✅ Données chargées depuis le localStorage');
                    return true;
                }
                return false;
            } catch (error) {
                console.error('Erreur chargement localStorage:', error);
                showSaveStatus('error', 'Erreur lors du chargement local');
                return false;
            }
        }

        // NOUVEAU: Fonction pour purger le localStorage
        function purgeLocalStorage() {
            if (!confirm('⚠️ ATTENTION : Supprimer TOUTES les sauvegardes locales ?\n\nCette action est irréversible.\n\nAssurez-vous d\'avoir sauvegardé sur le serveur si nécessaire.')) {
                return;
            }

            try {
                localStorage.removeItem(SAVE_KEY);
                localStorage.removeItem(SAVE_KEY_TIMESTAMP);
                showSaveStatus('success', '🗑️ Sauvegardes locales supprimées');
            } catch (error) {
                console.error('Erreur purge localStorage:', error);
                showSaveStatus('error', 'Erreur lors de la suppression');
            }
        }

        // ===== SYNCHRONISATION AUTOMATIQUE =====

        async function syncFromServerIfNeeded() {
            // CORRECTION: Supprimer le délai anti-conflit
            // La synchronisation se fait maintenant immédiatement après chaque action

            // En mode spectateur, toujours synchroniser depuis le serveur
            if (currentSaveMode === SAVE_CONFIG.modes.SPECTATOR) {
                await loadFromServer(true); // true = auto sync silencieux
            }
        }

        // ===== HISTORIQUE SERVEUR =====

        async function loadFromHistory(filename) {
            if (!filename) return false;

            try {
                showSaveStatus('sync', '🔄 Chargement de l\'historique...');

                const response = await fetch(`${SERVER_URL}?history=${encodeURIComponent(filename)}`);
                if (!response.ok) {
                    showSaveStatus('error', 'Erreur lors du chargement de l\'historique');
                    return false;
                }

                const data = await response.json();

                if (data && data.roundsStore) {
                    if (confirm(`⚠️ Restaurer cette sauvegarde écrasera toutes les données actuelles. Continuer ?`)) {
                        roundsStore = data.roundsStore;
                        currentRoundKey = data.currentRoundKey || 'ronde1';
                        arbiterPassword = data.arbiterPassword || null;

                        // Migration
                        Object.values(roundsStore).forEach(roundState => {
                            if (!roundState.physicalTables) roundState.physicalTables = [];
                            if (!roundState.rooms) roundState.rooms = [];
                            if (!roundState.nextRoomId) roundState.nextRoomId = 1;
                            roundState.physicalTables.forEach(pt => {
                                if (!pt.arbiterComment) pt.arbiterComment = { text: "", flag: "none" };
                                pt.boards.forEach(b => {
                                    if (b.score === undefined) b.score = { white: "", black: "" };
                                    if (b.players && b.players.white && typeof b.players.white === 'string') {
                                        b.players.white = { name: b.players.white, elo: null };
                                        b.players.black = { name: b.players.black, elo: null };
                                    }
                                    if (!b.players) {
                                        b.players = { white: { name: "", elo: null }, black: { name: "", elo: null } };
                                    }
                                });
                            });
                        });

                        loadStateFromStore(currentRoundKey);
                        updateRoundSelector();

                        // Sauvegarder immédiatement
                        saveToLocalStorage();
                        if (currentSaveMode === SAVE_CONFIG.modes.ARBITER) {
                            await saveToServer();
                        }

                        showSaveStatus('success', '✅ Historique restauré');
                        return true;
                    }
                }
                return false;
            } catch (error) {
                console.error('Erreur restauration historique:', error);
                showSaveStatus('error', 'Erreur lors de la restauration');
                return false;
            }
        }

        // NOUVEAU: Fonction pour supprimer un fichier d'historique
        async function deleteHistoryFile(filename, buttonElement) {
            if (!confirm(`Supprimer définitivement le fichier "${filename}" ?\n\nCette action est irréversible.`)) {
                return;
            }

            try {
                const response = await fetch(`${SERVER_URL}?delete=${encodeURIComponent(filename)}`);
                if (!response.ok) {
                    showSaveStatus('error', 'Erreur lors de la suppression');
                    return;
                }

                const result = await response.json();
                if (result.success) {
                    // Retirer visuellement l'élément
                    const historyItem = buttonElement.closest('.history-item');
                    if (historyItem) {
                        historyItem.style.opacity = '0';
                        setTimeout(() => historyItem.remove(), 300);
                    }
                    showSaveStatus('success', `Fichier ${filename} supprimé`);
                } else {
                    showSaveStatus('error', 'Impossible de supprimer le fichier');
                }
            } catch (error) {
                console.error('Erreur suppression:', error);
                showSaveStatus('error', 'Erreur lors de la suppression');
            }
        }

        // NOUVEAU: Fonction pour supprimer TOUT l'historique
        async function deleteAllHistory() {
            if (!confirm('⚠️ ATTENTION : Supprimer TOUT l\'historique du serveur ?\n\nCette action est IRRÉVERSIBLE et supprimera toutes les sauvegardes automatiques.\n\nLes données actuelles ne seront pas affectées.')) {
                return;
            }

            // Double confirmation pour sécurité
            if (!confirm('Confirmez-vous vraiment la suppression de TOUT l\'historique ?')) {
                return;
            }

            try {
                const response = await fetch(`${SERVER_URL}?delete_all=true`);
                if (!response.ok) {
                    showSaveStatus('error', 'Erreur lors de la suppression');
                    return;
                }

                const result = await response.json();
                if (result.success) {
                    // Fermer la modale et recharger
                    const modal = document.getElementById('historyModal');
                    if (modal) modal.remove();

                    showSaveStatus('success', result.message);
                } else {
                    showSaveStatus('error', 'Impossible de supprimer l\'historique');
                }
            } catch (error) {
                console.error('Erreur suppression totale:', error);
                showSaveStatus('error', 'Erreur lors de la suppression');
            }
        }

        async function showHistoryModal() {
            if (!USE_SERVER_SYNC) {
                alert('La synchronisation serveur doit être activée pour voir l\'historique.');
                return;
            }

            try {
                showSaveStatus('sync', '🔄 Chargement de l\'historique...');

                const response = await fetch(`${SERVER_URL}?list_history=true`);
                if (!response.ok) {
                    showSaveStatus('error', 'Erreur lors du chargement de l\'historique');
                    return;
                }

                const result = await response.json();
                if (!result.success || !result.history) {
                    showSaveStatus('warning', 'Aucun historique trouvé');
                    return;
                }

                showHistoryList(result.history);
                showSaveStatus('success', 'Historique chargé');
            } catch (error) {
                console.error('Erreur chargement historique:', error);
                showSaveStatus('error', 'Impossible de charger l\'historique');
            }
        }

        function showHistoryList(historyItems) {
            // Créer la modale
            const modal = document.createElement('div');
            modal.id = 'historyModal';
            modal.className = 'modal-overlay';
            modal.style.cssText = 'display: flex; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); z-index: 10000; align-items: center; justify-content: center;';

            modal.innerHTML = `
    <div
        style="background: white; border-radius: 12px; padding: 30px; max-width: 800px; width: 90%; max-height: 80vh; overflow-y: auto; box-shadow: 0 10px 40px rgba(0,0,0,0.3);">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h2 style="margin: 0; color: #2c3e50;">📂 Historique des sauvegardes</h2>
            <button id="closeHistoryModal"
                style="background: #eb3349; color: white; border: none; border-radius: 50%; width: 32px; height: 32px; font-size: 1.2em; cursor: pointer; display: flex; align-items: center; justify-content: center;">×</button>
        </div>

        <div
            style="margin-bottom: 15px; padding: 10px; background: #fff3cd; border-left: 4px solid #ffc107; border-radius: 4px;">
            <strong>ℹ️ Info :</strong> Les sauvegardes sont créées automatiquement à chaque modification.
        </div>

        <button id="deleteAllHistoryBtn"
            style="padding: 10px 20px; background: #dc3545; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; margin-bottom: 20px; width: 100%;">
            🗑️ Supprimer TOUT l'historique
        </button>

        <div id="historyList"></div>
    </div>
    `;

            document.body.appendChild(modal);

            // Remplir la liste
            const listDiv = document.getElementById('historyList');

            if (historyItems.length === 0) {
                listDiv.innerHTML = '<p style="text-align: center; color: #6c757d; padding: 40px;">Aucune sauvegarde trouvée</p>';
                return;
            }

            // Limiter l'affichage
            const displayItems = historyItems.slice(0, SAVE_CONFIG.maxHistoryDisplay);

            const listHTML = displayItems.map(item => `
    <div class="history-item"
        style="border: 1px solid #dee2e6; border-radius: 8px; padding: 15px; margin-bottom: 10px; transition: all 0.3s ease;">
        <div style="display: flex; justify-content: space-between; align-items: center; gap: 10px;">
            <div style="flex: 1;">
                <div style="font-weight: bold; color: #2c3e50; margin-bottom: 5px;">${item.filename}</div>
                <div style="color: #6c757d; font-size: 0.9em;">
                    📅 ${item.date} | 💾 ${(item.size / 1024).toFixed(2)} Ko
                </div>
            </div>
            <div style="display: flex; gap: 8px;">
                <button class="restore-btn" data-file="${item.filename}"
                    style="padding: 8px 12px; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer; white-space: nowrap; width: auto; margin-bottom: 0;">
                    🔄 Restaurer
                </button>
                <a href="${SERVER_URL}?history=${encodeURIComponent(item.filename)}" download="${item.filename}"
                    style="padding: 8px 12px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; text-decoration: none; display: inline-block; white-space: nowrap; width: auto; margin-bottom: 0;">
                    ⬇️ Télécharger
                </a>
                <button class="delete-btn" data-file="${item.filename}"
                    style="padding: 8px 12px; background: #eb3349; color: white; border: none; border-radius: 4px; cursor: pointer; width: auto; margin-bottom: 0;">
                    🗑️ Supprimer
                </button>
            </div>
        </div>
    </div>
    `).join('');

            listDiv.innerHTML = listHTML;

            // Event listeners
            document.querySelectorAll('.restore-btn').forEach(btn => {
                btn.addEventListener('click', async () => {
                    const filename = btn.dataset.file;
                    const success = await loadFromHistory(filename);
                    if (success) {
                        modal.remove();
                    }
                });
            });

            document.querySelectorAll('.delete-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    deleteHistoryFile(btn.dataset.file, btn);
                });
            });

            document.getElementById('closeHistoryModal').addEventListener('click', () => {
                modal.remove();
            });

            document.getElementById('deleteAllHistoryBtn').addEventListener('click', () => {
                deleteAllHistory();
            });

            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }

        // ===== GESTION DES MODES =====

        function setMode(mode) {
            currentSaveMode = mode;

            // NOUVEAU: Récupérer les éléments du switch
            const modeSwitch = document.getElementById('modeSwitch');
            const modeSwitchLabel = document.getElementById('modeSwitchLabel');
            const saveStrategySelector = document.getElementById('saveStrategySelector');
            const btnShowHistory = document.getElementById('btnShowHistory');

            if (mode === SAVE_CONFIG.modes.ARBITER) {
                // Mode Arbitre : peut sauvegarder
                if (modeSwitch) modeSwitch.checked = true;
                if (modeSwitchLabel) modeSwitchLabel.textContent = 'Arbitre';
                if (btnShowHistory) btnShowHistory.disabled = false;
                if (saveStrategySelector) saveStrategySelector.disabled = false;

                document.body.classList.remove('spectator-mode');

                // --- CORRECTION AJOUTÉE ---
                if (typeof setTool === 'function') {
                    setTool('select'); // Remettre l'outil "Sélection" par défaut
                }
                // --- FIN CORRECTION ---

                showSaveStatus('info', '👨‍⚖️ Mode Arbitre activé - Vous pouvez modifier et sauvegarder');

            } else {
                // Mode Spectateur : lecture seule
                if (modeSwitch) modeSwitch.checked = false;
                if (modeSwitchLabel) modeSwitchLabel.textContent = 'Spectateur';
                if (btnShowHistory) btnShowHistory.disabled = false; // Peut voir l'historique
                if (saveStrategySelector) saveStrategySelector.disabled = true;

                document.body.classList.add('spectator-mode');

                // --- CORRECTION AJOUTÉE ---
                if (typeof setTool === 'function') {
                    setTool('pan'); // Forcer le mode "Bouger"
                }
                // --- FIN CORRECTION ---

                showSaveStatus('info', '👁️ Mode Spectateur activé - Lecture seule');
            }

            // Réinitialiser les intervalles
            configureSaveStrategy();
        }

        // ===== CONFIGURATION DES INTERVALLES =====

        // ===== CONFIGURATION DES INTERVALLES =====

        function configureSaveStrategy() {
            // Clear existing intervals
            if (window.localSaveInterval) {
                clearInterval(window.localSaveInterval);
                window.localSaveInterval = null;
            }
            if (window.serverSyncInterval) {
                clearInterval(window.serverSyncInterval);
                window.serverSyncInterval = null;
            }
            if (window.serverSaveInterval) {
                clearInterval(window.serverSaveInterval);
                window.serverSaveInterval = null;
            }
            const strategySelect = document.getElementById('saveStrategySelector');
            if (!strategySelect) return;

            const strategy = strategySelect.value;

            if (strategy === 'local_only') {
                // MODE LOCAL
                if (currentSaveMode === SAVE_CONFIG.modes.ARBITER) {
                    // AJOUT DE window.
                    window.localSaveInterval = setInterval(() => {
                        saveToLocalStorage();
                    }, SAVE_CONFIG.intervals.LOCAL_SAVE);
                }
                console.log('Mode local: Sauvegarde locale activée, serveur désactivé');

            } else if (strategy === 'server_only') {
                // MODE SERVEUR
                // Sauvegarde automatique vers le serveur (en mode Arbitre uniquement)
                if (currentSaveMode === SAVE_CONFIG.modes.ARBITER) {
                    window.serverSaveInterval = setInterval(() => {
                        saveToServer();
                    }, SAVE_CONFIG.intervals.LOCAL_SAVE); // 30 secondes
                }

                // Synchronisation depuis le serveur
                window.serverSyncInterval = setInterval(() => {
                    syncFromServerIfNeeded();
                }, SAVE_CONFIG.intervals.SERVER_SYNC); // 5 secondes
                console.log('Mode serveur: Sauvegarde et synchronisation serveur activées');
            }
        }

        // ===== ÉVÉNEMENTS DE L'INTERFACE =====

        function initSaveControls() {
            console.log('🔧 Initialisation des contrôles de sauvegarde...');

            setTimeout(() => {
                // MODIFIÉ: Cible le nouvel interrupteur
                const modeSwitch = document.getElementById('modeSwitch');
                const saveStrategySelector = document.getElementById('saveStrategySelector');
                const btnShowHistory = document.getElementById('btnShowHistory');

                console.log('🔍 Éléments trouvés:', {
                    modeSwitch: !!modeSwitch, // Modifié
                    saveStrategySelector: !!saveStrategySelector,
                    btnShowHistory: !!btnShowHistory
                });

                if (!modeSwitch) { // Modifié
                    console.error('❌ Interrupteur de mode non trouvé !'); // Modifié
                    return;
                }

                // MODIFIÉ: Listener pour l'interrupteur (change)
                modeSwitch?.addEventListener('change', (e) => {
                    const isChecked = e.target.checked;

                    if (isChecked) {
                        // --- Tente de passer en mode Arbitre ---
                        if (!arbiterPassword) {
                            // Pas de mot de passe défini, créer un maintenant
                            alert("⚠️ Aucun mot de passe arbitre n'est défini.\n\nVeuillez en créer un pour sécuriser l'accès au mode Arbitre.");
                            document.getElementById('arbiterPassModal').style.display = 'flex';
                            e.target.checked = false; // Rester en spectateur
                            return;
                        }

                        // Afficher la modale de validation
                        document.getElementById('switchToArbiterModal').style.display = 'flex';
                        document.getElementById('switchArbiterPassInput').value = '';
                        document.getElementById('switchArbiterPassInput').focus();

                        // Remettre temporairement en spectateur (sera changé après validation)
                        e.target.checked = false;

                    } else {
                        // --- Passe en mode Spectateur (toujours autorisé) ---
                        setMode(SAVE_CONFIG.modes.SPECTATOR);
                    }
                });

                // Listener pour la stratégie
                saveStrategySelector?.addEventListener('change', (e) => {
                    const newStrategy = e.target.value;

                    // CORRECTION: Recharger les données selon la nouvelle stratégie
                    if (newStrategy === 'server_only') {
                        console.log('Changement vers mode serveur - Chargement serveur...');
                        loadFromServer(false); // false = action manuelle, afficher confirmation si conflit
                    } else if (newStrategy === 'local_only') {
                        console.log('Changement vers mode local - Chargement localStorage...');
                        const hasLocalData = localStorage.getItem(SAVE_KEY);
                        if (hasLocalData) {
                            loadFromLocalStorage();
                        } else {
                            showSaveStatus('info', 'Mode local activé - Aucune sauvegarde locale');
                        }
                    }

                    // NOUVEAU: Mémoriser le choix
                    try {
                        localStorage.setItem(STRATEGY_KEY, newStrategy);
                    } catch (e) {
                        console.warn("Impossible de mémoriser la stratégie de sauvegarde.", e);
                    }

                    configureSaveStrategy();
                    showSaveStatus('info', '📡 Stratégie de sauvegarde mise à jour.');
                });

                btnShowHistory?.addEventListener('click', () => {
                    console.log('📂 Clic sur Historique');
                    showHistoryModal();
                });

                console.log('✅ Event listeners attachés');

                // Initialiser les intervalles
                configureSaveStrategy();
            }, 500);
        }

        // Fonction pour valider le passage en mode Arbitre
        window.validateSwitchToArbiter = function () {
            const passwordInput = document.getElementById('switchArbiterPassInput');
            const enteredPassword = passwordInput.value;

            if (enteredPassword === arbiterPassword) {
                // Mot de passe correct
                document.getElementById('switchToArbiterModal').style.display = 'none';
                setMode(SAVE_CONFIG.modes.ARBITER); // setMode va cocher la case
                showSaveStatus('success', '✅ Mode Arbitre activé');
            } else {
                // Mot de passe incorrect
                alert('❌ Mot de passe incorrect');
                passwordInput.value = '';
                passwordInput.focus();
            }
        };

        // Fonction pour annuler le passage en mode Arbitre
        window.cancelSwitchToArbiter = function () {
            document.getElementById('switchToArbiterModal').style.display = 'none';
        };

        // ===== HOOK DE SAUVEGARDE APRÈS RÉSULTAT =====

        function onResultSaved() {
            // CORRECTION: Sauvegarder IMMÉDIATEMENT selon la stratégie stricte

            const strategySelect = document.getElementById('saveStrategySelector');
            if (!strategySelect) return;

            const strategy = strategySelect.value;

            // Vérifier qu'on est bien en mode arbitre
            if (currentSaveMode !== SAVE_CONFIG.modes.ARBITER) {
                console.log('Mode spectateur - Pas de sauvegarde');
                return;
            }

            // CORRECTION: Mode strictement séparé
            if (strategy === 'local_only') {
                // MODE LOCAL : Sauvegarder UNIQUEMENT en local
                console.log('Sauvegarde locale immédiate');
                saveToLocalStorage();
            } else if (strategy === 'server_only') {
                // MODE SERVEUR : Sauvegarder UNIQUEMENT sur serveur
                console.log('Sauvegarde serveur immédiate');
                saveToServer();
            }
        }

        // ==========================================
        // NOUVELLES FONCTIONS INTÉGRÉES
        // ==========================================

        // --- MODE PROJECTEUR ---
        function toggleProjectorMode() {
            document.body.classList.toggle('projector-mode');
            if (document.body.classList.contains('projector-mode')) {
                fitAllTables();
                // Passer en plein écran si possible
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen().catch(e => console.log(e));
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen().catch(e => console.log(e));
                }
                setTimeout(fitAllTables, 100);
            }
        }

        // --- MISE À JOUR ATOMIQUE DES SCORES ---
        async function updateScoreOnServer(roundKey, boardNumber, result) {
            // Ne rien faire si la synchro serveur est désactivée globalement
            if (typeof USE_SERVER_SYNC !== 'undefined' && !USE_SERVER_SYNC) return;

            // Ne rien faire en mode local_only
            const strategySelect = document.getElementById('saveStrategySelector');
            if (strategySelect && strategySelect.value === 'local_only') return;

            try {
                const response = await fetch(SERVER_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'update_score',
                        roundKey: roundKey,
                        boardNumber: boardNumber,
                        result: result
                    })
                });

                if (!response.ok) {
                    console.error("Erreur mise à jour score serveur:", response.status);
                    showSaveStatus('warning', '⚠️ Erreur synchro score serveur');
                } else {
                    const res = await response.json();
                    if (res.success) {
                        console.log("Score mis à jour sur serveur (atomique)");
                    }
                }
            } catch (e) {
                console.error("Exception mise à jour score:", e);
            }
        }

        // ===== INITIALISATION =====

        document.addEventListener('DOMContentLoaded', () => {
            initSaveControls();

            // CORRECTION: Charger VRAIMENT selon la stratégie
            const strategySelect = document.getElementById('saveStrategySelector');
            const strategy = strategySelect ? strategySelect.value : 'server_only';

            // IMPORTANT: Vérifier d'abord si on a des données locales
            const hasLocalData = localStorage.getItem(SAVE_KEY);

            if (strategy === 'local_only') {
                // MODE LOCAL : Charger UNIQUEMENT depuis localStorage, jamais depuis serveur
                if (hasLocalData) {
                    console.log('Mode local: Chargement depuis localStorage');
                    loadFromLocalStorage();
                } else {
                    console.log('Mode local: Aucune donnée locale - Nouveau tournoi');
                    showSaveStatus('info', 'Mode local - Nouveau tournoi');
                }
            } else {
                // MODE SERVEUR : Charger depuis serveur
                console.log('Mode serveur: Chargement depuis serveur');
                loadFromServer(true);
            }

            // Charger tournamentConfig depuis localStorage si disponible
            const savedConfig = localStorage.getItem('chessroom-tournamentConfig');
            if (savedConfig) {
                try {
                    tournamentConfig = JSON.parse(savedConfig);
                    console.log('Configuration du tournoi chargée depuis localStorage');
                } catch (e) {
                    console.error('Erreur lors du chargement de tournamentConfig:', e);
                }
            }

            // NOUVEAU: Démarrer en mode SPECTATEUR par défaut
            setMode(SAVE_CONFIG.modes.SPECTATOR);

            // NOUVEAU: Listener pour Enter dans la modale de switch
            const switchModal = document.getElementById('switchToArbiterModal');
            if (switchModal) {
                switchModal.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        validateSwitchToArbiter();
                    } else if (e.key === 'Escape') {
                        cancelSwitchToArbiter();
                    }
                });
            }

            showSaveStatus('success', '🚀 Système de sauvegarde initialisé - Mode Spectateur');
        });

        // ===== EXPORT DES FONCTIONS =====

        window.ChessRoomSave = {
            saveLocal: saveToLocalStorage,
            saveServer: saveToServer,
            loadServer: loadFromServer,
            showHistory: showHistoryModal,
            setMode: setMode,
            onResultSaved: onResultSaved
        };
    </script>
    <script>
        // ... (Existing JS) ...

        // --- GLOBAL VARIABLES FOR OPTIMISTIC LOCKING ---
        let lastServerTimestamp = 0;

        // --- HEARTBEAT ---
        function updateConnectionStatus(status) {
            const el = document.getElementById('connectionStatus');
            if (el) {
                el.className = status;
                el.title = status === 'online' ? 'Connecté' : (status === 'offline' ? 'Déconnecté' : 'Vérification...');
            }
        }

        function checkConnection() {
            updateConnectionStatus('checking');
            // Use a lightweight HEAD request to test.php or save.php
            fetch('test.php', { method: 'HEAD', cache: 'no-store' })
                .then(response => {
                    if (response.ok) updateConnectionStatus('online');
                    else updateConnectionStatus('offline');
                })
                .catch(() => updateConnectionStatus('offline'));
        }
        // Start Heartbeat
        setInterval(checkConnection, 30000); // Check every 30s
        setTimeout(checkConnection, 1000); // Initial check

        // --- DARK MODE ---
        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
            const isDark = document.body.classList.contains('dark-mode');
            localStorage.setItem('chessRoomDarkMode', isDark);
        }
        // Init Dark Mode
        if (localStorage.getItem('chessRoomDarkMode') === 'true') {
            document.body.classList.add('dark-mode');
        }

        // --- FILTERS ---
        function filterTables(filter) {
            // 1. Gestion de l'apparence des boutons
            document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
            const activeBtn = document.getElementById('filterBtn' + filter.charAt(0).toUpperCase() + filter.slice(1));
            if (activeBtn) activeBtn.classList.add('active');

            // 2. Application du filtre sur les tables physiques
            physicalTables.forEach(table => {
                const element = document.getElementById(`phys-table-${table.id}`);
                if (!element) return;

                // On réinitialise l'affichage
                element.classList.remove('hidden-by-filter');

                if (filter === 'all') return; // Si "Toutes", on s'arrête là (tout est affiché)

                // 3. Analyse de l'état de la table
                let isTableEmpty = true;       // La table est-elle vide de joueurs ?
                let hasActiveGame = false;     // Y a-t-il au moins une partie en cours ?
                let isFullyFinished = true;    // Toutes les parties occupées sont-elles finies ?

                let boardsWithPlayers = 0;

                table.boards.forEach(board => {
                    // Vérifie s'il y a des joueurs (Nom non vide)
                    const hasPlayers = board.players && (
                        (board.players.white && board.players.white.name.trim() !== "") ||
                        (board.players.black && board.players.black.name.trim() !== "")
                    );

                    // Vérifie s'il y a un score
                    const hasScore = board.score && (board.score.white !== '' || board.score.black !== '');

                    if (hasPlayers) {
                        isTableEmpty = false;
                        boardsWithPlayers++;

                        if (!hasScore) {
                            // Partie avec joueurs mais SANS score = En cours
                            hasActiveGame = true;
                            isFullyFinished = false;
                        }
                    }
                });

                // Si la table n'a que des échiquiers vides, elle n'est pas "finie", elle est juste vide.
                if (boardsWithPlayers === 0) {
                    isFullyFinished = false;
                }

                // 4. Logique de masquage selon le filtre choisi
                let shouldHide = false;

                if (filter === 'empty') {
                    // On veut voir les vides -> on cache si NON vide
                    if (!isTableEmpty) shouldHide = true;
                }
                else if (filter === 'playing') {
                    // On veut voir "En cours" -> on cache si Vide OU si tout est fini
                    if (isTableEmpty || !hasActiveGame) shouldHide = true;
                }
                else if (filter === 'finished') {
                    // On veut voir "Terminées" -> on cache si Vide OU s'il reste une partie active
                    if (isTableEmpty || !isFullyFinished) shouldHide = true;
                }

                // 5. Application
                if (shouldHide) {
                    element.classList.add('hidden-by-filter');
                }
            });
        }

        // --- ATOMIC SCORE UPDATE ---
        async function updateScoreOnServer(roundKey, boardNumber, result) {
            // Check if server sync is enabled/relevant
            const strategySelect = document.getElementById('saveStrategySelector');
            if (strategySelect && strategySelect.value === 'local_only') return;

            try {
                const response = await fetch('update_score.php', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        roundKey: roundKey,
                        boardNumber: boardNumber,
                        result: result
                    })
                });
                const data = await response.json();
                if (data.success) {
                    showSaveStatus('success', 'Score mis à jour (Atomique)');
                    return true;
                } else {
                    console.error('Update Score Error:', data.error);
                    showSaveStatus('error', 'Erreur MAJ Score');
                    return false;
                }
            } catch (e) {
                console.error('Update Score Exception:', e);
                showSaveStatus('error', 'Erreur Connexion (Score)');
                return false;
            }
        }
    </script>

    <script>
        // =====================================================
        // SYSTÈME DE SUIVI JOUEUR V7 (CORRECTIF NOMS ADVERSAIRES)
        // =====================================================

        window.watchedPlayerName = localStorage.getItem('chessRoomWatchedPlayer') || null;
        window.lastFoundSignature = null;
        window.wakeLock = null;

        document.addEventListener('DOMContentLoaded', () => {
            if (window.watchedPlayerName) {
                setTimeout(() => enableTrackingMode(window.watchedPlayerName), 500);
            }
        });

        window.updateSpectatorPlayerList = function () {
            const roundDisplay = document.getElementById('spectatorRoundDisplay');
            if (roundDisplay && typeof currentRoundKey !== 'undefined') {
                roundDisplay.textContent = currentRoundKey.replace('ronde', 'Ronde ').replace(/^r/, 'R');
            }

            if (document.getElementById('playerTrackingContainer').style.display !== 'none') return;

            const select = document.getElementById('spectatorPlayerSelect');
            if (!select) return;

            let players = [];
            if (typeof roundsStore !== 'undefined' && roundsStore[currentRoundKey]) {
                const data = roundsStore[currentRoundKey];
                if (data.physicalTables) {
                    data.physicalTables.forEach(table => {
                        table.boards.forEach(board => {
                            if (board.players) {
                                if (board.players.white && board.players.white.name) players.push(board.players.white.name.trim());
                                if (board.players.black && board.players.black.name) players.push(board.players.black.name.trim());
                            }
                        });
                    });
                }
            }
            players.sort((a, b) => a.localeCompare(b));
            players = [...new Set(players)];
            select.innerHTML = '<option value="">-- Choisir votre nom --</option>';
            players.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.text = name;
                select.appendChild(option);
            });
        };

        window.startAutoWatchFromList = function () {
            const select = document.getElementById('spectatorPlayerSelect');
            const name = select.value;
            if (!name) { alert("Merci de choisir un nom."); updateSpectatorPlayerList(); return; }
            enableTrackingMode(name);
        };

        function enableTrackingMode(name) {
            window.watchedPlayerName = name;
            localStorage.setItem('chessRoomWatchedPlayer', name);
            window.lastFoundSignature = null;

            document.getElementById('playerSelectContainer').style.display = 'none';
            document.getElementById('playerTrackingContainer').style.display = 'block';
            document.getElementById('trackingPlayerName').textContent = name;

            if ('wakeLock' in navigator) navigator.wakeLock.request('screen').catch(e => console.log(e));

            if (typeof renderAllTables === 'function') renderAllTables();
            checkAndRedirectPlayer();
        }

        window.stopAutoWatch = function () {
            window.watchedPlayerName = null;
            localStorage.removeItem('chessRoomWatchedPlayer');
            window.lastFoundSignature = null;

            document.getElementById('playerSelectContainer').style.display = 'block';
            document.getElementById('playerTrackingContainer').style.display = 'none';

            if (typeof renderAllTables === 'function') renderAllTables();
            updateSpectatorPlayerList();
        };

        // CŒUR DU SYSTÈME
        window.checkAndRedirectPlayer = function () {
            const roundDisplay = document.getElementById('spectatorRoundDisplay');
            if (roundDisplay && typeof currentRoundKey !== 'undefined') {
                roundDisplay.textContent = currentRoundKey.replace('ronde', 'Ronde ').replace(/^r/, 'R');
            }

            if (!window.watchedPlayerName) return;
            const infoDiv = document.getElementById('trackingLiveInfo');
            if (!infoDiv) return;

            if (typeof roundsStore === 'undefined' || !currentRoundKey || !roundsStore[currentRoundKey]) {
                infoDiv.innerHTML = '<span style="color:#999;">Chargement...</span>';
                return;
            }

            const normalize = (str) => str ? str.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").trim() : "";
            const targetName = normalize(window.watchedPlayerName);

            const tables = roundsStore[currentRoundKey].physicalTables;
            let found = false;
            let foundData = {};

            for (const table of tables) {
                for (const board of table.boards) {
                    if (board.players) {
                        const pWhite = normalize(board.players.white.name);
                        const pBlack = normalize(board.players.black.name);

                        if (pWhite.includes(targetName) || pBlack.includes(targetName)) {
                            found = true;
                            const isWhite = pWhite.includes(targetName);
                            foundData = {
                                tableId: table.id,
                                boardNum: board.boardNumber,
                                color: isWhite ? '⚪ Blancs' : '⚫ Noirs',
                                // On récupère les vrais objets joueurs complets pour l'affichage
                                playerObj: isWhite ? board.players.white : board.players.black,
                                opponentObj: isWhite ? board.players.black : board.players.white,
                                // Pour le panneau latéral
                                opponentName: isWhite ? board.players.black.name : board.players.white.name,
                                opponentElo: isWhite ? board.players.black.elo : board.players.white.elo,
                                rawWhite: board.players.white, // Objet complet
                                rawBlack: board.players.black  // Objet complet
                            };
                            break;
                        }
                    }
                }
                if (found) break;
            }

            if (found) {
                const oppEloDisplay = foundData.opponentElo ? `(${foundData.opponentElo})` : '';
                infoDiv.innerHTML = `
            <div style="color: #667eea; font-weight: bold; font-size: 1.4em; margin-bottom: 5px;">Table ${foundData.boardNum}</div>
            <div style="font-size: 1.1em; margin-bottom: 5px;">${foundData.color}</div>
            <div style="font-size: 0.9em; color: #555;">Contre : <strong>${foundData.opponentName}</strong> ${oppEloDisplay}</div>
        `;
                infoDiv.style.borderColor = "#28a745";

                const currentSignature = currentRoundKey + "_" + foundData.boardNum + "_" + foundData.opponentName;

                // DÉTECTION DE CHANGEMENT POUR LE POPUP
                if (window.lastFoundSignature !== currentSignature) {
                    console.log("Nouveau match détecté -> Zoom & Popup");
                    window.lastFoundSignature = currentSignature;

                    // 1. Scroll
                    setTimeout(() => {
                        const el = document.getElementById(`phys-table-${foundData.tableId}`);
                        if (el) el.scrollIntoView({ behavior: "smooth", block: "center" });
                    }, 300);

                    // 2. Popup CORRECTEMENT REMPLI
                    if (typeof showPlayerTableInfo === 'function') {
                        // Fermer l'ancien
                        const oldModal = document.getElementById('playerTableInfoModal');
                        if (oldModal) oldModal.style.display = 'none';

                        setTimeout(() => {
                            // On passe les vrais objets joueurs ici !
                            showPlayerTableInfo(
                                {
                                    boardNumber: foundData.boardNum,
                                    players: {
                                        white: foundData.rawWhite,
                                        black: foundData.rawBlack
                                    }
                                },
                                null,
                                (foundData.color.includes('Blanc') ? 'white' : 'black'),
                                window.watchedPlayerName,
                                foundData.playerObj.elo // Elo du joueur suivi
                            );
                        }, 400);
                    }
                }

            } else {
                infoDiv.innerHTML = `
            <span style="font-size: 1.1em; font-weight: bold; color: #e67e22;">⏳ En attente...</span>
            <div style="font-size: 0.8em; color: #777; margin-top: 5px;">
                Pas de partie trouvée<br>dans la ronde en cours.
            </div>
        `;
                infoDiv.style.borderColor = "#e67e22";
            }
        };
    </script>

    <script>
        // =====================================================
        // MODULE INSCRIPTIONS & POINTAGE (V1)
        // =====================================================

        // NOTE: Initialization moved to top of script to ensure availability for saveToServer

        // --- UI Functions ---
        // --- UI Functions ---
        window.openRegistrationOverlay = function () {
            document.getElementById('registrationOverlay').classList.add('active');
            loadRegistrations();
        };

        window.closeRegistrationOverlay = function () {
            document.getElementById('registrationOverlay').classList.remove('active');
        };

        function closeRegistrationOverlay() {
            document.getElementById('registrationOverlay').classList.remove('active');
        }

        function loadRegistrations() {
            REG_CACHE = RegDB.getAll();
            renderRegDashboard();
        }

        function renderRegDashboard() {
            const list = applyRegFilters(REG_CACHE);
            sortRegListInternal(list);

            // Aggregates
            const total = REG_CACHE.length;
            const active = REG_CACHE.filter(r => r.status !== 'Annulé');
            const checked = active.filter(r => r.status === 'Pointé').length;
            const paid = active.filter(r => r.payment === 'Réglé').length;

            document.getElementById('aggTotal').textContent = active.length;
            document.getElementById('aggChecked').textContent = checked;
            document.getElementById('aggRemaining').textContent = active.length - checked;
            document.getElementById('aggPaid').textContent = paid;

            // Table
            const tbody = document.getElementById('regTbody');
            if (!tbody) return;
            tbody.innerHTML = '';

            list.forEach(r => {
                const isCancelled = r.status === 'Annulé';
                const tr = document.createElement('tr');
                if (isCancelled) tr.classList.add('cancelled');

                tr.innerHTML = `
                    <td style="font-weight:500">${escapeHtml(r.lastName)}</td>
                    <td>${escapeHtml(r.firstName)}</td>
                    <td>${r.eloSlow || ''}</td>
                    <td>${escapeHtml(r.club || '')}</td>
                    <td style="font-family:monospace; color:#666;">${escapeHtml(r.fideId || '')}</td>
                    <td><span class="reg-status-badge ${getBadgeClass(r.status)}">${r.status}</span></td>
                    <td><span class="reg-status-badge ${getBadgeClass(r.payment)}">${r.payment}</span></td>
                    <td>
                        <div style="display:flex; gap:5px;">
                            <button class="reg-btn reg-btn-secondary" style="padding:4px 8px; font-size:0.8em;" 
                                onclick="showRegistrationQRCode('${r.id}')" title="Afficher le QR-code">
                                🏁 QR
                            </button>
                            <button class="reg-btn reg-btn-success" style="padding:4px 8px; font-size:0.8em;" 
                                onclick="toggleRegStatus('${r.id}')" ${isCancelled ? 'disabled' : ''}>
                                ${r.status === 'Pointé' ? 'Dépointer' : 'Pointer'}
                            </button>
                            <button class="reg-btn reg-btn-indigo" style="padding:4px 8px; font-size:0.8em; background:#e0e7ff; color:#4338ca;" 
                                onclick="toggleRegPayment('${r.id}')" ${isCancelled ? 'disabled' : ''}>
                                ${r.payment === 'Réglé' ? '€ Non' : '€ Oui'}
                            </button>
                            <button class="reg-btn reg-btn-danger" style="padding:4px 8px; font-size:0.8em;" 
                                onclick="toggleRegCancel('${r.id}')">
                                ${isCancelled ? 'Activer' : '×'}
                            </button>
                        </div>
                    </td>
                `;
                tbody.appendChild(tr);
            });
        }

        function applyRegFilters(list) {
            const q = normalize(REG_FILTERS.q);
            return list.filter(r => {
                if (r.status === 'Annulé' && REG_FILTERS.status !== 'Annulé') return false;
                const matchQ = !q || normalize(`${r.lastName} ${r.firstName} ${r.fideId || ''}`).includes(q);
                const matchS = !REG_FILTERS.status || r.status === REG_FILTERS.status;
                const matchP = !REG_FILTERS.payment || r.payment === REG_FILTERS.payment;
                return matchQ && matchS && matchP;
            });
        }

        function sortRegListInternal(list) {
            const { key, dir } = REG_SORT;
            const factor = dir === 'asc' ? 1 : -1;
            list.sort((a, b) => {
                let va = a[key], vb = b[key];
                if (key === 'eloSlow') { va = Number(va || 0); vb = Number(vb || 0); }
                else { va = (va || '').toString().toLowerCase(); vb = (vb || '').toString().toLowerCase(); }
                return va < vb ? -1 * factor : va > vb ? 1 * factor : 0;
            });

            // Update headers
            document.querySelectorAll('.reg-table th').forEach(th => {
                th.classList.remove('sorted');
                if (th.dataset.sort === key) th.classList.add('sorted');
            });
        }

        function sortRegList(key) {
            if (REG_SORT.key === key) REG_SORT.dir = REG_SORT.dir === 'asc' ? 'desc' : 'asc';
            else { REG_SORT.key = key; REG_SORT.dir = 'asc'; }
            renderRegDashboard();
        }

        function getBadgeClass(status) {
            if (status === 'Pointé') return 'bg-emerald-100';
            if (status === 'Annulé') return 'bg-rose-100';
            if (status === 'Réglé') return 'bg-indigo-100';
            if (status === 'Exonéré') return 'bg-slate-100';
            return 'bg-amber-100';
        }

        // --- Actions ---
        // --- PAPI Import Logic ---
        function importPapiParticipants(input) {
            const file = input.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                const content = e.target.result;
                const parser = new DOMParser();
                const doc = parser.parseFromString(content, 'text/html');

                // Select rows based on PAPI classes
                const rows = doc.querySelectorAll('tr.papi_liste_c, tr.papi_liste_f');
                let count = 0;

                rows.forEach(row => {
                    const cells = row.cells;
                    if (cells.length < 8) return;

                    // Extract Name (Col 3 - Index 2)
                    const nameCell = cells[2].textContent.trim();
                    // Parse "LASTNAME Firstname"
                    // Usually PAPI puts LASTNAME in uppercase and Firstname in Title Case
                    // We can just use it as is or try to split.
                    // Let's assume the format "LASTNAME Firstname"
                    const nameParts = nameCell.split(' ');
                    let lastName = '';
                    let firstName = '';

                    // Simple heuristic: All caps parts are Last Name, others are First Name
                    // Or just split by first space if we want to be simple, but PAPI names can be complex.
                    // Let's try to detect the transition from CAPS to TitleCase if possible, 
                    // or just take the first part as Last Name if we want to be safe? 
                    // Actually, the user example shows "ALVIN Leo".

                    // Let's use a regex to find the split between the uppercase part and the rest
                    // But some last names have spaces "VAN DER ...".
                    // Let's assume the last part is the first name if it's not fully uppercase?
                    // No, "VANLERBERGHE Noe".

                    // Let's try to find the last token that is fully uppercase? No, "DE LA ..."

                    // Let's stick to: Last token is First Name, rest is Last Name. 
                    // EXCEPT if there are only 2 tokens.

                    const parts = nameCell.split(/\s+/);
                    if (parts.length >= 2) {
                        firstName = parts.pop();
                        lastName = parts.join(' ');
                    } else {
                        lastName = nameCell;
                    }

                    // Extract Elo (Col 4 - Index 3) -> "1993 N"
                    const eloCell = cells[3].textContent.trim();
                    const eloMatch = eloCell.match(/^(\d+)/);
                    const elo = eloMatch ? parseInt(eloMatch[1]) : 1000;

                    // Extract Club (Col 8 - Index 7)
                    const club = cells[7].textContent.trim();

                    // Create Registration
                    // Check for duplicates
                    const exists = REG_CACHE.some(r =>
                        normalize(r.lastName) === normalize(lastName) &&
                        normalize(r.firstName) === normalize(firstName)
                    );

                    if (!exists) {
                        const newReg = {
                            id: generateUUID(),
                            firstName: firstName,
                            lastName: lastName,
                            eloSlow: elo,
                            club: club,
                            email: '',
                            phone: '',
                            status: 'Non pointé',
                            payment: 'Non réglé',
                            fideId: '',
                            category: '',
                            notes: 'Import PAPI'
                        };
                        REG_CACHE.push(newReg);
                        count++;
                    }
                });

                if (count > 0) {
                    RegDB._write(REG_CACHE);
                    RegDB._sync();
                    renderRegDashboard();
                    showNotification(`${count} participants importés avec succès !`, 'success');
                } else {
                    showNotification('Aucun nouveau participant trouvé ou format invalide.', 'warning');
                }

                // Reset input
                input.value = '';
            };
            reader.readAsText(file, 'ISO-8859-1'); // PAPI uses ISO-8859-1 usually
        }

        // --- Tournament Name Persistence ---
        function saveTournamentName(name) {
            localStorage.setItem('ls:REG_APP_ID:tournamentName', name);
            updateAppHeader(name);
        }

        function loadTournamentName() {
            const name = localStorage.getItem('ls:REG_APP_ID:tournamentName');
            if (name) {
                const input = document.getElementById('regTournamentName');
                if (input) input.value = name;
                updateAppHeader(name);
            }
        }

        function updateAppHeader(name) {
            if (!name) return;
            document.title = name;
            // Try to update main header if it exists
            const mainHeader = document.querySelector('header h1');
            // This might target the sidebar header or main content header depending on layout
            // Let's be specific if we can, or just update document title.
            // The user said "que son nom reste à l'affichage sur tous les écran".
            // Maybe we can add a global header element if it doesn't exist or update an existing one.

            // Let's look for a prominent place. The sidebar has a title?
            // Or we can inject a top bar?
            // For now, let's update the document title and the input itself.
        }

        // Call load on startup
        document.addEventListener('DOMContentLoaded', loadTournamentName);

        function toggleRegStatus(id) {
            const r = REG_CACHE.find(x => x.id === id);
            if (!r) return;
            const next = r.status === 'Pointé' ? 'Non pointé' : 'Pointé';
            REG_CACHE = RegDB.update(id, { status: next });
            renderRegDashboard();
        }

        function toggleRegPayment(id) {
            const r = REG_CACHE.find(x => x.id === id);
            if (!r) return;
            const next = r.payment === 'Réglé' ? 'Non réglé' : 'Réglé';
            REG_CACHE = RegDB.update(id, { payment: next });
            renderRegDashboard();
        }

        function toggleRegCancel(id) {
            const r = RegDB.get(id);
            if (!r) return;
            r.status = (r.status === 'Annulé') ? 'Inscrit' : 'Annulé';
            RegDB.update(r);
            loadRegistrations();
        }

        function checkAll() {
            const all = RegDB.getAll();
            const active = all.filter(r => r.status !== 'Annulé');
            if (active.length === 0) return;

            // If ALL active are 'Pointé', then uncheck all. Otherwise check all.
            const allChecked = active.every(r => r.status === 'Pointé');
            const newStatus = allChecked ? 'Inscrit' : 'Pointé';
            const confirmMsg = allChecked ?
                "Voulez-vous vraiment DÉ-POINTER tous les joueurs ?" :
                "Voulez-vous vraiment POINTER tous les joueurs ?";

            if (!confirm(confirmMsg)) return;

            active.forEach(r => r.status = newStatus);
            RegDB.setAll(all);
            loadRegistrations();
        }

        function markAllPaid() {
            const all = RegDB.getAll();
            const active = all.filter(r => r.status !== 'Annulé');
            if (active.length === 0) return;

            // If ALL active are 'Réglé', then unpay all. Otherwise pay all.
            const allPaid = active.every(r => r.payment === 'Réglé');
            const newPayment = allPaid ? 'En attente' : 'Réglé';
            const confirmMsg = allPaid ?
                "Voulez-vous vraiment passer tous les joueurs en NON RÉGLÉ ?" :
                "Voulez-vous vraiment passer tous les joueurs en RÉGLÉ ?";

            if (!confirm(confirmMsg)) return;

            active.forEach(r => r.payment = newPayment);
            RegDB.setAll(all);
            loadRegistrations();
        }

        // --- QR Code Registration Handler ---
        function handleRegistrationScan(playerName, playerElo) {
            // Normalize the scanned player name for comparison
            const normalizedScanName = normalize(playerName);

            // Search for the player in the registration database
            const player = REG_CACHE.find(r => {
                const fullName = `${r.firstName} ${r.lastName}`.trim();
                const reverseName = `${r.lastName} ${r.firstName}`.trim();
                return normalize(fullName) === normalizedScanName ||
                    normalize(reverseName) === normalizedScanName;
            });

            if (!player) {
                showNotification(`❌ Joueur "${playerName}" non trouvé dans les inscriptions`, 'error');
                // Reopen scanner after 2 seconds for continuous scanning
                setTimeout(() => startRegistrationQRScanner(), 2000);
                return;
            }

            // Check if player is cancelled
            if (player.status === 'Annulé') {
                showNotification(`⚠️ ${playerName} : inscription annulée`, 'warning');
                setTimeout(() => startRegistrationQRScanner(), 2000);
                return;
            }

            // Check if already checked in
            if (player.status === 'Pointé') {
                showNotification(`ℹ️ ${playerName} : déjà pointé`, 'info');
                setTimeout(() => startRegistrationQRScanner(), 2000);
                return;
            }

            // Update player status to "Pointé"
            REG_CACHE = RegDB.update(player.id, { status: 'Pointé' });
            renderRegDashboard();

            showNotification(`✅ ${playerName} pointé avec succès !`, 'success');

            // Reopen scanner after 1.5 seconds for continuous scanning
            setTimeout(() => startRegistrationQRScanner(), 1500);
        }

        // --- Single QR Code Display ---
        function showRegistrationQRCode(id) {
            const r = REG_CACHE.find(x => x.id === id);
            if (!r) return;

            const container = document.getElementById('regQRCodeContainer');
            container.innerHTML = ''; // Clear previous

            // Format name exactly as expected by scanner (First Last)
            const name = `${r.firstName} ${r.lastName}`;

            // Create QR data matching the scanner's expected format
            const qrData = JSON.stringify({
                type: 'player',
                name: name,
                elo: r.eloSlow || 1000
            });

            // Generate QR Code
            new QRCode(container, {
                text: qrData,
                width: 200,
                height: 200,
                colorDark: "#000000",
                colorLight: "#ffffff",
                correctLevel: QRCode.CorrectLevel.H
            });

            document.getElementById('regQRCodeName').textContent = name;
            document.getElementById('regQRCodeInfo').textContent = `Elo: ${r.eloSlow || 'N/A'} | Club: ${r.club || 'N/A'}`;

            document.getElementById('regQRCodeModal').style.display = 'flex';
        }

        function printRegQRCode() {
            const container = document.getElementById('regQRCodeContainer');
            const name = document.getElementById('regQRCodeName').textContent;
            const info = document.getElementById('regQRCodeInfo').textContent;

            const win = window.open('', '', 'height=600,width=500');
            win.document.write('<html><head><title>QR Code - ' + name + '</title>');
            win.document.write('<style>');
            win.document.write('body { font-family: "Segoe UI", sans-serif; text-align: center; padding: 40px; }');
            win.document.write('h2 { margin: 20px 0 10px; color: #333; }');
            win.document.write('p { color: #666; font-size: 1.1em; }');
            win.document.write('.qr-box { border: 2px solid #333; padding: 20px; display: inline-block; border-radius: 10px; }');
            win.document.write('</style>');
            win.document.write('</head><body>');

            win.document.write('<div class="qr-box">');
            win.document.write(container.innerHTML);
            win.document.write('</div>');
            win.document.write('<h2>' + name + '</h2>');
            win.document.write('<p>' + info + '</p>');

            win.document.write('<script>window.onload = function() { window.print(); window.close(); }<\/script>');
            win.document.write('</body></html>');
            win.document.close();
        }



        function toggleRegPayment(id) {
            const r = REG_CACHE.find(x => x.id === id);
            if (!r) return;
            const next = r.payment === 'Réglé' ? 'Non réglé' : 'Réglé';
            REG_CACHE = RegDB.update(id, { payment: next });
            renderRegDashboard();
        }

        function toggleRegCancel(id) {
            const r = REG_CACHE.find(x => x.id === id);
            if (!r) return;
            const next = r.status === 'Annulé' ? 'Non pointé' : 'Annulé';
            if (confirm(`Voulez-vous vraiment ${next === 'Annulé' ? 'annuler' : 'réactiver'} cette inscription ?`)) {
                REG_CACHE = RegDB.update(id, { status: next });
                renderRegDashboard();
            }
        }

        // --- FIDE Search ---
        // --- FIDE Search (Fixed) ---
        let lastFideHtml = ""; // Stocke le dernier HTML pour debug

        async function searchFIDE() {
            const query = document.getElementById('fideSearchInput').value.trim();
            if (query.length < 3) { alert("Veuillez entrer au moins 3 caractères."); return; }

            const btn = document.querySelector('button[onclick="searchFIDE()"]');
            const originalText = btn.innerHTML;
            btn.innerHTML = '⏳';
            btn.disabled = true;

            const container = document.getElementById('fideSearchResults');
            container.innerHTML = '<p style="text-align:center; padding:20px;">Recherche via API FIDE Players...</p>';
            document.getElementById('fideSearchModal').style.display = 'flex';

            try {
                // 1. Utilisation du BON endpoint (Datasette)
                // Note: _shape=array force le retour d'une liste d'objets JSON propre
                const apiUrl = `https://fide-players.fly.dev/players/players.json?_search=${encodeURIComponent(query)}&_sort=fideid&_shape=array`;
                console.log("Appel API:", apiUrl);

                const response = await fetch(apiUrl);
                if (!response.ok) { throw new Error(`Erreur API (${response.status})`); }

                const players = await response.json();
                console.log(`${players.length} joueurs trouvés`);

                const results = [];
                // 2. Mapping des champs (Datasette renvoie les noms de colonnes en minuscules généralement)
                if (Array.isArray(players)) {
                    players.forEach(p => {
                        results.push({
                            name: p.name,
                            fed: p.federation || p.country || '',
                            title: p.title || '',
                            rating: p.standard_rating || p.rating || '0',
                            fideId: p.fideid || p.id
                        });
                    });
                }

                if (results.length === 0) {
                    container.innerHTML = '<div style="padding:20px; text-align:center;">Aucun joueur trouvé avec ce nom.</div>';

                } else {
                    showFideResults(results);
                }

            } catch (error) {
                console.error(error);
                container.innerHTML = `
    <div style="text-align:center; padding:20px; color: red;">
        <p>❌ Erreur: ${error.message}</p>
        <p style="font-size:0.9em; color:#555;">
            L'API externe semble indisponible.
        </p>
        <a href="https://ratings.fide.com/index.phtml?search=${encodeURIComponent(query)}" target="_blank"
            class="btn-primary" style="margin-top:10px; display:inline-block;">
            Ouvrir FIDE.com ↗️
        </a>
    </div>
    `;
            } finally {
                btn.innerHTML = originalText;
                btn.disabled = false;
            }
        }

        async function testProxies() {
            const proxies = [
                { name: 'CodeTabs', url: (u) => `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(u)}` },
                { name: 'AllOrigins', url: (u) => `https://api.allorigins.win/raw?url=${encodeURIComponent(u)}` },
                { name: 'CorsProxy', url: (u) => `https://corsproxy.io/?${encodeURIComponent(u)}` }
            ];

            const targetUrl = `https://ratings.fide.com/index.phtml?search=Carlsen`;
            let report = "Rapport de test des proxies :\n\n";

            for (const p of proxies) {
                report += `🔹 ${p.name} : `;
                try {
                    const start = Date.now();
                    const res = await fetch(p.url(targetUrl));
                    const time = Date.now() - start;
                    if (res.ok) {
                        const txt = await res.text();
                        report += `✅ OK (${time}ms, ${txt.length} bytes)\n`;
                    } else {
                        report += `❌ HTTP ${res.status}\n`;
                    }
                } catch (e) {
                    report += `❌ Erreur: ${e.message}\n`;
                }
            }

            alert(report);
        }

        function showFideRawHtml() {
            if (!lastFideHtml) {
                alert("Aucune recherche FIDE n'a été effectuée. Faites d'abord une recherche.");
                return;
            }
            const container = document.getElementById('fideSearchResults');
            container.innerHTML = `
    <div style="padding: 10px;">
        <p><strong>HTML Brut (${lastFideHtml.length} caractères) :</strong></p>
        <textarea readonly
            style="width: 100%; height: 400px; font-size: 0.7em; font-family: monospace; border: 1px solid #ccc; padding: 5px;">${lastFideHtml.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</textarea>
    </div>
    `;
            document.getElementById('fideSearchModal').style.display = 'flex';
        }

        // ==================== FFE IMPORT ====================
        async function importFromFFE() {
            console.log('Début import FFE');
            const urlInput = document.getElementById('ffeUrlInput');
            const statusDiv = document.getElementById('ffeImportStatus');
            const url = urlInput.value.trim();

            if (!url) {
                statusDiv.innerHTML = '❌ Veuillez entrer une URL FFE';
                statusDiv.style.color = '#ef4444';
                return;
            }

            // Validate URL is from FFE
            if (!url.includes('echecs.asso.fr')) {
                statusDiv.innerHTML = '❌ L\'URL doit être du site echecs.asso.fr';
                statusDiv.style.color = '#ef4444';
                return;
            }

            statusDiv.innerHTML = '⏳ Chargement de la page FFE...';
            statusDiv.style.color = '#3b82f6';

            try {
                // Fetch HTML through PHP proxy
                const response = await fetch(`fetch_ffe.php?url=${encodeURIComponent(url)}`);
                if (!response.ok) {
                    throw new Error('Erreur lors du chargement de la page FFE');
                }

                const html = await response.text();

                // Parse HTML
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');

                // Find all player rows (alternating classes papi_liste_f and papi_liste_c)
                const rows = doc.querySelectorAll('tr.papi_liste_f, tr.papi_liste_c');
                console.log('Lignes trouvées:', rows.length);

                if (rows.length === 0) {
                    throw new Error('Aucun joueur trouvé dans cette page');
                }

                statusDiv.innerHTML = `📊 ${rows.length} joueurs trouvés, import en cours...`;

                let imported = 0;
                let skipped = 0;
                let batchPlayers = [];

                rows.forEach(row => {
                    const cells = row.querySelectorAll('td');
                    if (cells.length < 8) return; // Skip malformed rows

                    // Extract player data from table cells
                    const name = cells[2].textContent.trim(); // Column 3: Name
                    const eloText = cells[3].textContent.trim(); // Column 4: Elo (e.g., "1447 F")
                    const club = cells[7].textContent.trim(); // Column 8: Club

                    // Parse name (format: "LASTNAME Firstname" or "LASTNAME-NAME Firstname")
                    const nameParts = name.split(' ');
                    let lastName = '';
                    let firstName = '';

                    if (nameParts.length >= 2) {
                        // Last part is usually first name
                        firstName = nameParts[nameParts.length - 1];
                        // Everything else is last name
                        lastName = nameParts.slice(0, -1).join(' ');
                    } else {
                        lastName = name;
                    }

                    // Parse Elo (format: "1447 F" or "1299 E")
                    const eloMatch = eloText.match(/(\d+)/);
                    const elo = eloMatch ? parseInt(eloMatch[1]) : 1000;

                    // Check for duplicates
                    const exists = RegDB.getAll().some(p =>
                        p.lastName.toLowerCase() === lastName.toLowerCase() &&
                        p.firstName.toLowerCase() === firstName.toLowerCase()
                    );

                    if (exists) {
                        skipped++;
                        return;
                    }

                    // Add player to batch list
                    // Add player to batch list
                    const player = {
                        id: generateUUID(),
                        firstName: firstName,
                        lastName: lastName,
                        eloSlow: elo,
                        eloRapid: elo,
                        club: club,
                        federation: 'FRA',
                        status: 'Inscrit', // Default status
                        payment: 'En attente', // Default payment status
                        isCheckedIn: false, // Keep for compatibility if needed
                        isPaid: false // Keep for compatibility if needed
                    };

                    batchPlayers.push(player);
                    imported++;
                });

                // Batch add and FORCE save
                if (batchPlayers.length > 0) {
                    RegDB.addBatch(batchPlayers);
                    await saveToServer(true); // Force save to overwrite server data with new import
                }

                // Update display
                loadRegistrations();

                statusDiv.innerHTML = `✅ Import terminé : ${imported} joueurs ajoutés${skipped > 0 ? `, ${skipped} doublons ignorés` : ''}`;
                statusDiv.style.color = '#10b981';

                // Clear URL input
                urlInput.value = '';

            } catch (error) {
                console.error('FFE Import Error:', error);
                statusDiv.innerHTML = `❌ Erreur : ${error.message}`;
                statusDiv.style.color = '#ef4444';
            }
        }

        // Global storage for search results to ensure access
        window.lastFideResults = [];

        function showFideResults(results) {
            window.lastFideResults = results; // Store for access via index
            const container = document.getElementById('fideSearchResults');
            container.innerHTML = '';

            if (results.length === 0) {
                container.innerHTML = '<p style="text-align:center; padding:20px; color:#666;">Aucun résultat trouvé.</p>';
            } else if (results.length === 1) {
                // Un seul résultat : remplir directement le formulaire
                fillRegForm(results[0]);
                document.getElementById('fideSearchModal').style.display = 'none';
            } else {
                // Plusieurs résultats : afficher une table de sélection
                const header = document.createElement('div');
                header.style.cssText = 'padding: 15px; background: #f5f5f5; border-bottom: 2px solid #ddd; font-weight: bold;';
                header.innerHTML = `${results.length} joueur(s) trouvé(s) - Cliquez pour sélectionner :`;
                container.appendChild(header);

                const table = document.createElement('table');
                table.style.cssText = 'width: 100%; border-collapse: collapse;';

                let html = `
    <thead>
        <tr style="background: #2c3e50; color: white;">
            <th style="padding: 10px; text-align: left;">Nom</th>
            <th style="padding: 10px; text-align: center;">Pays</th>
            <th style="padding: 10px; text-align: center;">Titre</th>
            <th style="padding: 10px; text-align: center;">Elo</th>
        </tr>
    </thead>
    <tbody>
        `;

                results.forEach((p, index) => {
                    const bg = index % 2 === 0 ? '#fff' : '#f9f9f9';
                    html += `
        <tr style="background: ${bg}; border-bottom: 1px solid #eee; cursor: pointer;"
            onmouseover="this.style.background='#e3f2fd'" onmouseout="this.style.background='${bg}'"
            onclick="selectFidePlayer(${index})">
            <td style="padding: 12px; font-weight: 500;">${p.name}</td>
            <td style="padding: 12px; text-align: center;">${p.fed || '-'}</td>
            <td style="padding: 12px; text-align: center; color: #d32f2f; font-weight: bold;">${p.title || '-'}</td>
            <td style="padding: 12px; text-align: center; font-weight: 600;">${p.rating || '-'}</td>
        </tr>
        `;
                });

                html += '</tbody>';
                table.innerHTML = html;
                container.appendChild(table);
            }

            // Ensure modal content has background
            const modalContent = document.querySelector('#fideSearchModal .modal-content');
            if (modalContent) modalContent.style.background = 'white';

            document.getElementById('fideSearchModal').style.display = 'flex';
        }

        function selectFidePlayer(index) {
            const p = window.lastFideResults[index];
            if (p) {
                fillRegForm(p);
            } else {
                console.error("Player not found at index", index);
            }
        }



        function fillRegForm(p) {
            console.log("fillRegForm called with:", p);
            if (!p) return;
            // FIDE format: LASTNAME Firstname
            // On essaie de séparer intelligemment
            // Souvent tout en majuscules ou Nom, Prenom
            let last = p.name, first = '';
            if (p.name.includes(',')) {
                const parts = p.name.split(',');
                last = parts[0].trim();
                first = parts[1].trim();
            } else {
                // Heuristique simple: dernier mot = prénom ? Non, FIDE c'est souvent "NOM Prenom"
                // On va mettre tout dans Nom si pas de virgule, ou laisser l'utilisateur corriger
                const parts = p.name.split(' ');
                if (parts.length > 1) {
                    last = parts.slice(0, -1).join(' ');
                    first = parts[parts.length - 1];
                }
            }

            document.getElementById('regLast').value = toTitleCase(last); // Helper à définir ou utiliser existant
            document.getElementById('regFirst').value = toTitleCase(first);
            document.getElementById('regElo').value = p.rating;
            document.getElementById('regClub').value = p.fed;
            document.getElementById('regFideId').value = p.fideId;

            document.getElementById('fideSearchModal').style.display = 'none';
        }

        function toTitleCase(str) {
            return str.replace(/\w\S*/g, function (txt) { return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase(); });
        }

        // --- Event Listeners ---
        document.getElementById('formAddReg').addEventListener('submit', (e) => {
            e.preventDefault();

            try {
                const lastName = document.getElementById('regLast').value.trim();
                const firstName = document.getElementById('regFirst').value.trim();
                const elo = document.getElementById('regElo').value;

                if (!lastName || !firstName) {
                    alert("Nom et Prénom sont obligatoires !");
                    return;
                }

                const reg = {
                    id: generateUUID(),
                    lastName: lastName,
                    firstName: firstName,
                    eloSlow: elo,
                    club: document.getElementById('regClub').value.trim(),
                    fideId: document.getElementById('regFideId').value.trim(),
                    status: 'Non pointé',
                    payment: 'Non réglé',
                    createdAt: Date.now()
                };

                RegDB.add(reg);

                // Clear filters to ensure the new player is visible
                REG_FILTERS.q = '';
                document.getElementById('regSearch').value = '';

                console.log("Reloading registrations...");
                loadRegistrations();

                e.target.reset();
                document.getElementById('regAddMsg').textContent = "Ajouté !";
                setTimeout(() => document.getElementById('regAddMsg').textContent = "", 2000);
            } catch (error) {
                console.error("Error adding registration:", error);
                alert("Erreur lors de l'ajout: " + error.message);
            }
        });

        document.getElementById('regSearch').addEventListener('input', (e) => {
            REG_FILTERS.q = e.target.value;
            renderRegDashboard();
        });
        document.getElementById('regFilterStatus').addEventListener('change', (e) => {
            REG_FILTERS.status = e.target.value;
            renderRegDashboard();
        });
        document.getElementById('regFilterPayment').addEventListener('change', (e) => {
            REG_FILTERS.payment = e.target.value;
            renderRegDashboard();
        });


        document.getElementById('btnPurgeReg').addEventListener('click', () => {
            if (confirm("Tout effacer ?")) {
                RegDB.purge();
                loadRegistrations();
            }
        });

        // Init
        // (Rien à faire au chargement initial sauf si on veut précharger)

        // =====================================================
        // MODULE APPARIEMENTS (SWISS & ROUND ROBIN)
        // =====================================================

        // --- Gestion des Paramètres Avancés ---
        let tournamentConfig = {
            tieBreaks: { buchholz: true, sonneborn: true, direct: true, progressive: false },
            points: { bye: 1.0, absent: 0 },
            acceleration: false
        };

        function openTournamentSettings() {
            // Charger les valeurs actuelles
            document.getElementById('tbBuchholz').checked = tournamentConfig.tieBreaks.buchholz;
            document.getElementById('tbSonneborn').checked = tournamentConfig.tieBreaks.sonneborn;
            document.getElementById('tbDirect').checked = tournamentConfig.tieBreaks.direct;
            document.getElementById('tbProgressive').checked = tournamentConfig.tieBreaks.progressive;

            document.getElementById('ptsBye').value = tournamentConfig.points.bye;
            document.getElementById('ptsAbsent').value = tournamentConfig.points.absent;

            document.getElementById('optAcceleration').checked = tournamentConfig.acceleration;

            document.getElementById('tournamentSettingsModal').style.display = 'flex';
        }

        function saveTournamentSettings() {
            tournamentConfig = {
                tieBreaks: {
                    buchholz: document.getElementById('tbBuchholz').checked,
                    sonneborn: document.getElementById('tbSonneborn').checked,
                    direct: document.getElementById('tbDirect').checked,
                    progressive: document.getElementById('tbProgressive').checked
                },
                points: {
                    bye: parseFloat(document.getElementById('ptsBye').value),
                    absent: parseFloat(document.getElementById('ptsAbsent').value)
                },
                acceleration: document.getElementById('optAcceleration').checked
            };

            // Sauvegarder dans localStorage
            localStorage.setItem('chessroom-tournamentConfig', JSON.stringify(tournamentConfig));

            // Déclencher la sauvegarde serveur selon la stratégie active
            const strategySelect = document.getElementById('saveStrategySelector');
            const strategy = strategySelect ? strategySelect.value : 'server_only';

            if (currentSaveMode === SAVE_CONFIG.modes.ARBITER) {
                if (strategy === 'local_only') {
                    saveToLocalStorage();
                } else if (strategy === 'server_only') {
                    saveToServer();
                }
            }

            document.getElementById('tournamentSettingsModal').style.display = 'none';
            alert("Paramètres enregistrés !");
        }

        /**
         * FIDE DUTCH PAIRING SYSTEM - Implementation complète
         * Conforme au règlement FIDE C.04.3 - Applied from 1st February, 2026
         */
        class FIDEDutchPairingSystem {
            constructor() {
                this.players = [];
                this.currentRound = 1;
                this.pairings = [];
                this.results = [];
                this.maxRounds = 9;
            }

            assignTPNs() {
                this.players.sort((a, b) => {
                    if (b.rating !== a.rating) return b.rating - a.rating;
                    return a.name.localeCompare(b.name);
                });
                this.players.forEach((player, index) => {
                    player.tpn = index + 1;
                });
            }

            orderPlayers(players) {
                return players.sort((a, b) => {
                    if (b.score !== a.score) return b.score - a.score;
                    return a.tpn - b.tpn;
                });
            }

            calculateFloats(player) {
                if (!player.history) return { downfloats: 0, upfloats: 0 };
                let downfloats = 0;
                let upfloats = 0;
                for (let i = 0; i < player.history.length; i++) {
                    const match = player.history[i];
                    if (!match.opponent) {
                        if (match.result === 1 || match.result === 0.5) downfloats++;
                    } else {
                        const opponent = this.getPlayerByTPN(match.opponent);
                        if (opponent && player.score > opponent.score) downfloats++;
                        else if (opponent && player.score < opponent.score) upfloats++;
                    }
                }
                return { downfloats, upfloats };
            }

            getColourDifference(player) {
                if (!player.history || player.history.length === 0) return 0;
                let whites = 0;
                let blacks = 0;
                for (const match of player.history) {
                    if (match.colour === 'white') whites++;
                    else if (match.colour === 'black') blacks++;
                }
                return whites - blacks;
            }

            getColourPreference(player) {
                if (!player.history || player.history.length === 0) return { type: 'none', colour: null };
                const cd = this.getColourDifference(player);
                const lastTwo = this.getLastTwoColours(player);
                if (cd < -1 || (cd <= -1 && lastTwo[0] === 'black' && lastTwo[1] === 'black')) return { type: 'absolute', colour: 'white' };
                if (cd > 1 || (cd >= 1 && lastTwo[0] === 'white' && lastTwo[1] === 'white')) return { type: 'absolute', colour: 'black' };
                if (cd === -1) return { type: 'strong', colour: 'white' };
                if (cd === 1) return { type: 'strong', colour: 'black' };
                if (cd === 0 && player.history.length > 0) {
                    const lastColour = player.history[player.history.length - 1].colour;
                    return { type: 'mild', colour: lastColour === 'white' ? 'black' : 'white' };
                }
                return { type: 'none', colour: null };
            }

            getLastTwoColours(player) {
                const playedGames = player.history.filter(h => h.colour);
                if (playedGames.length < 2) return [null, null];
                return [playedGames[playedGames.length - 1].colour, playedGames[playedGames.length - 2].colour];
            }

            hasPlayedBefore(player1, player2) {
                if (!player1.history || !player2.history) return false;
                return player1.history.some(h => h.opponent === player2.tpn);
            }

            hasReceivedBye(player) {
                if (!player.history) return false;
                return player.history.some(h => h.bye === true);
            }

            violatesColourAbsolute(player1, player2) {
                const pref1 = this.getColourPreference(player1);
                const pref2 = this.getColourPreference(player2);
                const isTopscorer1 = player1.score > (this.currentRound / 2);
                const isTopscorer2 = player2.score > (this.currentRound / 2);
                if (!isTopscorer1 && !isTopscorer2) {
                    if (pref1.type === 'absolute' && pref2.type === 'absolute' && pref1.colour === pref2.colour) return true;
                }
                return false;
            }

            canCompletePariring(players) {
                if (players.length === 0) return true;
                if (players.length === 1) return true;
                for (let i = 0; i < players.length; i++) {
                    let hasCompatible = false;
                    for (let j = 0; j < players.length; j++) {
                        if (i !== j && this.areCompatible(players[i], players[j])) {
                            hasCompatible = true;
                            break;
                        }
                    }
                    if (!hasCompatible && players.length > 1) return false;
                }
                return true;
            }

            areCompatible(p1, p2) {
                if (this.hasPlayedBefore(p1, p2)) return false;
                if (this.violatesColourAbsolute(p1, p2)) return false;
                return true;
            }

            pairBracket(bracket, mdps = []) {
                const M0 = mdps.length;
                const residents = bracket.filter(p => !mdps.includes(p));
                const totalPlayers = residents.length + M0;
                const MaxPairs = Math.floor(totalPlayers / 2);
                let M1 = Math.min(M0, residents.length, MaxPairs);
                const pairableMDPs = this.selectPairableMDPs(mdps.slice(0, M1), residents);
                M1 = pairableMDPs.length;
                const limbo = mdps.slice(M1);
                let S1, S2;
                if (bracket.length === residents.length && mdps.length === 0) {
                    S1 = residents.slice(0, MaxPairs);
                    S2 = residents.slice(MaxPairs);
                } else {
                    S1 = pairableMDPs;
                    S2 = residents;
                }
                const candidate = this.buildCandidate(S1, S2, limbo);
                if (this.isPerfectCandidate(candidate)) return candidate;
                return this.findBestCandidate(bracket, mdps);
            }

            buildCandidate(S1, S2, limbo) {
                const pairs = [];
                const downfloaters = [...limbo];
                const minLength = Math.min(S1.length, S2.length);
                for (let i = 0; i < minLength; i++) pairs.push([S1[i], S2[i]]);
                if (S1.length > minLength) downfloaters.push(...S1.slice(minLength));
                if (S2.length > minLength) downfloaters.push(...S2.slice(minLength));
                return { pairs, downfloaters };
            }

            isPerfectCandidate(candidate) {
                for (const pair of candidate.pairs) {
                    if (this.hasPlayedBefore(pair[0], pair[1])) return false;
                    if (this.violatesColourAbsolute(pair[0], pair[1])) return false;
                }
                return true;
            }

            findBestCandidate(bracket, mdps) {
                const residents = bracket.filter(p => !mdps.includes(p));
                const MaxPairs = Math.floor(bracket.length / 2);
                const transpositions = this.generateTranspositions(residents, MaxPairs);
                for (const transpo of transpositions) {
                    const candidate = this.buildCandidate(mdps.slice(0, MaxPairs), transpo, mdps.slice(MaxPairs));
                    if (this.isPerfectCandidate(candidate)) return candidate;
                }
                return this.tryExchanges(bracket, mdps);
            }

            generateTranspositions(players, n) {
                if (n === 0 || players.length === 0) return [[]];
                if (n > players.length) n = players.length;
                const result = [];
                const generate = (current, remaining) => {
                    if (current.length === n) {
                        result.push([...current, ...remaining]);
                        return;
                    }
                    for (let i = 0; i < remaining.length; i++) {
                        generate([...current, remaining[i]], [...remaining.slice(0, i), ...remaining.slice(i + 1)]);
                    }
                };
                generate([], players);
                return result;
            }

            tryExchanges(bracket, mdps) {
                const S1 = bracket.slice(0, Math.floor(bracket.length / 2));
                const S2 = bracket.slice(Math.floor(bracket.length / 2));
                for (let exchangeSize = 1; exchangeSize <= Math.min(S1.length, S2.length); exchangeSize++) {
                    const exchanges = this.generateExchanges(S1, S2, exchangeSize);
                    for (const exchange of exchanges) {
                        const newS1 = [...S1];
                        const newS2 = [...S2];
                        for (let i = 0; i < exchange.from1.length; i++) {
                            const idx1 = newS1.indexOf(exchange.from1[i]);
                            const idx2 = newS2.indexOf(exchange.from2[i]);
                            [newS1[idx1], newS2[idx2]] = [newS2[idx2], newS1[idx1]];
                        }
                        const candidate = this.buildCandidate(newS1, newS2, []);
                        if (this.isPerfectCandidate(candidate)) return candidate;
                    }
                }
                return this.buildCandidate(bracket.slice(0, Math.floor(bracket.length / 2)), bracket.slice(Math.floor(bracket.length / 2)), []);
            }

            generateExchanges(S1, S2, size) {
                const exchanges = [];
                if (size <= Math.min(S1.length, S2.length)) {
                    exchanges.push({ from1: S1.slice(0, size), from2: S2.slice(0, size) });
                }
                return exchanges;
            }

            allocateColours(pairs) {
                const pairingsWithColours = [];
                for (const pair of pairs) {
                    const [p1, p2] = this.orderPlayers([pair[0], pair[1]]);
                    const colour = this.determineColour(p1, p2);
                    if (colour === 'white') pairingsWithColours.push({ white: p1, black: p2, board: pairingsWithColours.length + 1 });
                    else pairingsWithColours.push({ white: p2, black: p1, board: pairingsWithColours.length + 1 });
                }
                return pairingsWithColours;
            }

            determineColour(higherRanked, lowerRanked) {
                if (!higherRanked.history || higherRanked.history.length === 0) return higherRanked.tpn % 2 === 1 ? 'white' : 'black';
                const pref1 = this.getColourPreference(higherRanked);
                const pref2 = this.getColourPreference(lowerRanked);
                if (pref1.colour && pref2.colour && pref1.colour !== pref2.colour) return pref1.colour;
                if (pref1.type === 'absolute' || pref1.type === 'strong') {
                    if (pref2.type !== 'absolute' && pref2.type !== 'strong') return pref1.colour;
                    const cd1 = Math.abs(this.getColourDifference(higherRanked));
                    const cd2 = Math.abs(this.getColourDifference(lowerRanked));
                    return cd1 >= cd2 ? pref1.colour : pref2.colour;
                }
                const lastOpposite = this.getLastOppositeColours(higherRanked, lowerRanked);
                if (lastOpposite) return lastOpposite;
                if (pref1.colour) return pref1.colour;
                return higherRanked.tpn % 2 === 1 ? 'white' : 'black';
            }

            getLastOppositeColours(p1, p2) {
                if (!p1.history || !p2.history) return null;
                for (let i = Math.min(p1.history.length, p2.history.length) - 1; i >= 0; i--) {
                    if (p1.history[i] && p2.history[i]) {
                        if (p1.history[i].colour === 'white' && p2.history[i].colour === 'black') return 'black';
                        if (p1.history[i].colour === 'black' && p2.history[i].colour === 'white') return 'white';
                    }
                }
                return null;
            }

            generatePairingsForRound() {
                const scoregroups = this.createScoregroups();
                let byePlayer = null;
                if (this.players.length % 2 === 1) byePlayer = this.assignBye();
                const allPairs = [];
                const processedPlayers = new Set();
                if (byePlayer) processedPlayers.add(byePlayer.tpn);
                for (const scoregroup of scoregroups) {
                    const unpairedPlayers = scoregroup.filter(p => !processedPlayers.has(p.tpn));
                    if (unpairedPlayers.length === 0) continue;
                    if (unpairedPlayers.length === 1) continue;
                    const bracketPairing = this.pairBracket(unpairedPlayers, []);
                    for (const pair of bracketPairing.pairs) {
                        allPairs.push(pair);
                        processedPlayers.add(pair[0].tpn);
                        processedPlayers.add(pair[1].tpn);
                    }
                }
                const finalPairings = this.allocateColours(allPairs);
                if (byePlayer) {
                    finalPairings.push({ white: null, black: null, bye: byePlayer, board: finalPairings.length + 1 });
                }
                this.pairings = finalPairings;
                return finalPairings;
            }

            createScoregroups() {
                const groups = {};
                for (const player of this.players) {
                    const score = player.score || 0;
                    if (!groups[score]) groups[score] = [];
                    groups[score].push(player);
                }
                return Object.keys(groups).sort((a, b) => parseFloat(b) - parseFloat(a)).map(score => this.orderPlayers(groups[score]));
            }

            assignBye() {
                const eligiblePlayers = this.players.filter(p => !this.hasReceivedBye(p));
                if (eligiblePlayers.length === 0) return null;
                eligiblePlayers.sort((a, b) => {
                    if (a.score !== b.score) return a.score - b.score;
                    return b.tpn - a.tpn;
                });
                const byePlayer = eligiblePlayers[0];
                if (!byePlayer.history) byePlayer.history = [];
                byePlayer.history.push({ round: this.currentRound, opponent: null, result: 1, colour: null, bye: true });
                byePlayer.score = (byePlayer.score || 0) + 1;
                return byePlayer;
            }

            selectPairableMDPs(mdps, residents) {
                const pairable = [];
                for (const mdp of mdps) {
                    let canPair = false;
                    for (const resident of residents) {
                        if (this.areCompatible(mdp, resident)) {
                            canPair = true;
                            break;
                        }
                    }
                    if (canPair) pairable.push(mdp);
                }
                return pairable;
            }

            getPlayerByTPN(tpn) {
                return this.players.find(p => p.tpn === tpn);
            }

            addPlayer(name, rating, id) {
                this.players.push({ name, rating: rating || 1500, score: 0, history: [], tpn: null, originalId: id });
                this.assignTPNs();
            }

            recordResult(round, whiteTPN, blackTPN, result) {
                const white = this.getPlayerByTPN(whiteTPN);
                const black = this.getPlayerByTPN(blackTPN);
                if (!white || !black) return false;
                white.score += result;
                black.score += (1 - result);
                white.history.push({ round, opponent: blackTPN, result, colour: 'white', bye: false });
                black.history.push({ round, opponent: whiteTPN, result: 1 - result, colour: 'black', bye: false });
                return true;
            }

            nextRound() {
                this.currentRound++;
                this.pairings = [];
            }

            getStandings() {
                return this.orderPlayers([...this.players]);
            }
        }

        class PairingService {
            constructor() {
                this.history = []; // Historique des parties {white: id, black: id, result: ...}
            }

            setHistory(history) {
                this.history = history || [];
            }

            async generate(players, roundNum, type = 'swiss') {
                // Filtrer les joueurs actifs (non annulés)
                const activePlayers = players.filter(p => p.status !== 'Annulé');

                if (activePlayers.length < 2) throw new Error("Pas assez de joueurs actifs.");
                if (type === 'swiss') return await this._swissPairing(activePlayers, roundNum);
                if (type === 'cup') return this._cupPairing(activePlayers, roundNum);
                if (type === 'roundrobin') return this._roundRobinPairing(activePlayers, roundNum);
                return this._randomPairing(activePlayers);
            }

            // --- SYSTÈME COUPE (KO) ---
            _cupPairing(players, roundNum) {
                // R1: Aléatoire
                if (roundNum === 1) return this._randomPairing(players);
                // R2+: Vainqueurs vs Vainqueurs
                // On doit savoir qui a gagné la ronde précédente.
                // C'est complexe sans historique complet des résultats.
                // Pour l'instant, faisons simple: Random parmi les joueurs restants (non annulés)
                return this._randomPairing(players);
            }
            // --- SYSTÈME SUISSE (FIDE DUTCH SYSTEM via Python Backend) ---
            async _swissPairing(players, roundNum) {
                console.log('_swissPairing called with', players.length, 'players, round', roundNum);
                console.log('this.history:', this.history);

                // Create ID mapping: original ID -> sequential ID
                const idMap = {};
                players.forEach((p, index) => {
                    idMap[p.id] = index + 1;
                    console.log(`Player ${index + 1}: ${p.firstName} ${p.lastName}, ID: ${p.id}`);
                });

                // Prepare data for Python backend
                const playerData = players.map((p, index) => {
                    const stats = this._getPlayerStats(p.id);

                    console.log(`Processing player ${p.firstName} ${p.lastName} (${p.id}), stats:`, stats);

                    // Build history for this player
                    const playerHistory = [];
                    this.history.forEach(match => {
                        console.log(`  Checking match: white=${match.white}, black=${match.black}, p.id=${p.id}`);
                        if (match.white === p.id || match.black === p.id) {
                            const isWhite = match.white === p.id;
                            let score = 0;

                            if (match.isBye) {
                                score = 1;
                            } else if (match.result === '1-0') {
                                score = isWhite ? 1 : 0;
                            } else if (match.result === '0-1') {
                                score = isWhite ? 0 : 1;
                            } else if (match.result === '1/2-1/2' || match.result === '0.5-0.5') {
                                score = 0.5;
                            }

                            // Map opponent ID to sequential ID
                            const opponentOriginalId = isWhite ? match.black : match.white;
                            const opponentSeqId = idMap[opponentOriginalId];

                            console.log(`    Match found! opponent=${opponentOriginalId}, seqId=${opponentSeqId}, score=${score}`);

                            // Only add if opponent is in current player list
                            if (opponentSeqId) {
                                playerHistory.push({
                                    round: match.round || 1,
                                    opponent_id: opponentSeqId,
                                    score: score,
                                    color: isWhite ? 'white' : 'black'
                                });
                            }
                        }
                    });

                    console.log(`  Final history for ${p.firstName}:`, playerHistory);

                    return {
                        id: index + 1, // Use sequential IDs for Python
                        score: stats.score,
                        rating: p.eloSlow || p.eloRapid || 1500,  // IMPORTANT: Send rating for round 1 pairings
                        history: playerHistory
                    };
                });

                const requestData = {
                    players: playerData,
                    current_round: roundNum,
                    total_rounds: 9 // Default, can be made configurable
                };

                console.log('Sending to Python backend:', JSON.stringify(requestData, null, 2));

                if (window.location.protocol === 'file:') {
                    alert("⚠️ ERREUR : Vous lancez l'application via un fichier local (file://).\n\n" +
                        "L'appariement nécessite le serveur Python local.\n" +
                        "1. Ouvrez un terminal dans le dossier 'local_python_deploy'.\n" +
                        "2. Lancez : python3 server.py\n" +
                        "3. Ouvrez : http://localhost:8000");
                    throw new Error("Cannot run pairing on file:// protocol. Please use the Python server.");
                }

                try {
                    // Call Python backend via local server
                    const response = await fetch('/pairing.php', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(requestData)
                    });

                    if (!response.ok) {
                        throw new Error(`Server error: ${response.status}`);
                    }

                    const result = await response.json();

                    console.log('Python backend response:', result);

                    if (result.status !== 'success') {
                        throw new Error(result.message || 'Python pairing failed');
                    }

                    // Convert Python results back to app format
                    const appPairings = result.pairings.map(pairing => {
                        if (pairing.white === null) {
                            // Bye for black player
                            return {
                                white: players[pairing.black - 1],
                                black: null,
                                isBye: true
                            };
                        } else if (pairing.black === null) {
                            // Bye for white player
                            return {
                                white: players[pairing.white - 1],
                                black: null,
                                isBye: true
                            };
                        } else {
                            // Normal pairing
                            return {
                                white: players[pairing.white - 1],
                                black: players[pairing.black - 1]
                            };
                        }
                    });

                    // Sort pairings by highest rating in each pair (descending)
                    // This matches the display order of the Chess-main program
                    appPairings.sort((a, b) => {
                        const maxRatingA = Math.max(
                            a.white ? (a.white.eloSlow || a.white.eloRapid || 0) : 0,
                            a.black ? (a.black.eloSlow || a.black.eloRapid || 0) : 0
                        );
                        const maxRatingB = Math.max(
                            b.white ? (b.white.eloSlow || b.white.eloRapid || 0) : 0,
                            b.black ? (b.black.eloSlow || b.black.eloRapid || 0) : 0
                        );
                        return maxRatingB - maxRatingA; // Descending order
                    });

                    return appPairings;

                } catch (error) {
                    console.error('Python pairing error:', error);
                    // Fallback to simple random pairing if Python fails
                    alert(`Erreur d'appariement Python: ${error.message}\n\nUtilisation de l'appariement aléatoire de secours.`);
                    return this._randomPairing(players);
                }
            }

            // --- TOUTES RONDES (BERGER) ---
            _roundRobinPairing(players, roundNum) {
                let n = players.length;
                const isOdd = n % 2 !== 0;
                if (isOdd) n++; // Joueur fantôme pour bye

                const pIds = players.map(p => p);
                if (isOdd) pIds.push(null); // Bye

                // Table de Berger
                const pairings = [];
                const half = n / 2;

                // Rotation simple pour la ronde X
                // Fixer le dernier joueur, tourner les autres
                // Algorithme standard Berger

                // Positions pour la ronde r (1-indexed)
                // P[n] est fixe. Les autres tournent.

                const roundIndex = roundNum - 1;
                const movingPlayers = pIds.slice(0, n - 1);
                const fixedPlayer = pIds[n - 1];

                // Rotation: décalage de (roundIndex)
                // Rotation: décalage de (roundIndex)
                // Méthode simple:
                // Liste: [0, 1, 2, ... n-2] + [n-1 fixe]
                // Rotation vers la droite (sens horaire)
                const cycle = [...movingPlayers];

                // Décaler de (roundNum - 1) vers la droite
                for (let k = 0; k < roundNum - 1; k++) {
                    cycle.unshift(cycle.pop());
                }

                const fullList = [...cycle, fixedPlayer];
                // Pairings:
                // Le dernier de cycle joue contre fixedPlayer (ou l'inverse selon ronde)
                // Les autres s'apparient : 1er vs dernier-1, 2ème vs dernier-2...
                // Cas spécial: dernier du cycle vs fixe
                let p1 = cycle[cycle.length - 1];
                let p2 = fixedPlayer;

                // Alternance couleurs pour le fixe
                // Simplification: Fixe alterne. R1: Noir (selon Berger standard souvent 1-N)
                // Si 1-N, 1 a les blancs.

                if (p1 && p2) {
                    if (roundNum % 2 !== 0) pairings.push({ white: p1, black: p2 });
                    else pairings.push({ white: p2, black: p1 });
                } else if (p1 && !p2) {
                    pairings.push({ white: p1, black: null, isBye: true });
                } else if (!p1 && p2) {
                    pairings.push({ white: p2, black: null, isBye: true });
                }

                // Les autres paires
                for (let i = 0; i < (n - 2) / 2; i++) {
                    const a = cycle[i];
                    const b = cycle[cycle.length - 2 - i];

                    if (a && b) {
                        // Couleurs: 1er de la paire a les Blancs si (i+round) pair?
                        // Berger: couleur dépend de l'indice.
                        // Simplification: alternance basique
                        if ((roundNum + i) % 2 === 0) pairings.push({ white: a, black: b });
                        else pairings.push({ white: b, black: a });
                    } else if (a && !b) {
                        pairings.push({ white: a, black: null, isBye: true });
                    } else if (!a && b) {
                        pairings.push({ white: b, black: null, isBye: true });
                    }
                }
                return pairings;
            }

            _randomPairing(players) {
                const shuffled = [...players].sort(() => Math.random() - 0.5);
                const pairings = [];
                while (shuffled.length > 1) {
                    pairings.push({ white: shuffled.pop(), black: shuffled.pop() });
                }
                if (shuffled.length > 0) {
                    pairings.push({ white: shuffled[0], black: null, isBye: true });
                }
                return pairings;
            }

            // --- HELPERS ---
            _getPlayerStats(pid) {
                let score = 0;
                let colors = []; // 'w', 'b'
                let opponents = [];
                let hasBye = false;

                this.history.forEach(h => {
                    if (h.white === pid) {
                        colors.push('w');
                        opponents.push(h.black);
                        if (h.result === '1-0') score += 1;
                        else if (h.result === '1/2-1/2') score += 0.5;
                    } else if (h.black === pid) {
                        colors.push('b');
                        opponents.push(h.white);
                        if (h.result === '0-1') score += 1;
                        else if (h.result === '1/2-1/2') score += 0.5;
                    } else if (h.white === pid && h.isBye) {
                        hasBye = true;
                        score += 1;
                    }
                });
                return { score, colors, opponents, hasBye };
            }

            _canPair(p1, p2) {
                // Règle 1: Pas déjà joué
                if (p1.opponents.includes(p2.id)) return false;

                // Règle 2: Équilibre couleurs (Max 3 fois la même suite)
                const c1 = this._getLastColors(p1.colors);
                const c2 = this._getLastColors(p2.colors);

                // Si les deux doivent absolument avoir la même couleur -> incompatible
                if (c1.mustBe === 'w' && c2.mustBe === 'w') return false;
                if (c1.mustBe === 'b' && c2.mustBe === 'b') return false;

                return true;
            }

            _determineColors(p1, p2) {
                const c1 = this._getLastColors(p1.colors);
                const c2 = this._getLastColors(p2.colors);

                // Priorité absolue
                if (c1.mustBe === 'w') return { white: p1, black: p2 };
                if (c1.mustBe === 'b') return { white: p2, black: p1 };
                if (c2.mustBe === 'w') return { white: p2, black: p1 };
                if (c2.mustBe === 'b') return { white: p1, black: p2 };

                // Équilibrage (Différence W-B)
                if (c1.bal > c2.bal) return { white: p2, black: p1 }; // p1 a plus de blancs
                if (c2.bal > c1.bal) return { white: p1, black: p2 };

                // Alternance simple (Dernière couleur)
                if (c1.last === 'w' && c2.last !== 'w') return { white: p2, black: p1 };
                if (c1.last === 'b' && c2.last !== 'b') return { white: p1, black: p2 };

                // Si tout égal -> Elo le plus fort a les Blancs ? Non, alternance
                // FIDE: Si historiques identiques, couleur alternée du plus haut classé
                return { white: p1, black: p2 };
            }

            _getLastColors(colors) {
                const n = colors.length;
                if (n === 0) return { last: null, bal: 0, mustBe: null };

                const last = colors[n - 1];
                const bal = colors.filter(c => c === 'w').length - colors.filter(c => c === 'b').length;

                let mustBe = null;
                // Max 2 fois la même couleur de suite (donc 3ème doit changer)
                if (n >= 2 && colors[n - 1] === colors[n - 2]) {
                    mustBe = (colors[n - 1] === 'w') ? 'b' : 'w';
                }

                return { last, bal, mustBe };
            }
        }

        // --- UI Integration ---


        function buildHistoryFromStore() {
            const hist = [];
            if (typeof roundsStore === 'undefined') return hist;

            console.log('Building history from store. roundsStore keys:', Object.keys(roundsStore));

            // Track round numbers for bye games
            let roundNum = 0;
            Object.keys(roundsStore).sort().forEach(roundKey => {
                if (!roundKey.startsWith('ronde')) return;
                roundNum++;
                const round = roundsStore[roundKey];

                console.log(`Processing ${roundKey}, physicalTables:`, round.physicalTables?.length || 0);

                round.physicalTables.forEach(t => {
                    t.boards.forEach(b => {
                        // Handle normal games (both players)
                        if (b.players && b.players.white && b.players.black) {
                            // IMPORTANT: Use ID only, not name
                            const wId = b.players.white.id;
                            const bId = b.players.black.id;

                            let result = null;
                            if (b.score) {
                                if (b.score.white === '1') result = '1-0';
                                else if (b.score.black === '1') result = '0-1';
                                else if (b.score.white === '1/2') result = '1/2-1/2';
                            }

                            const wName = `${b.players.white.firstName || ''} ${b.players.white.lastName || ''}`.trim();
                            const bName = `${b.players.black.firstName || ''} ${b.players.black.lastName || ''}`.trim();
                            console.log(`  Game: ${wName} (${wId}) vs ${bName} (${bId}), result: ${result}`);
                            hist.push({ white: wId, black: bId, result, round: roundNum });
                        }
                        // Handle bye games (only white player)
                        else if (b.players && b.players.white && !b.players.black) {
                            const wId = b.players.white.id;
                            hist.push({
                                white: wId,
                                black: null,
                                result: '1-0',
                                isBye: true,
                                round: roundNum
                            });
                        }
                    });
                });
            });

            console.log('Built history:', hist);
            return hist;
        }

        function applyPairingsToPlan(pairings) {
            // Vider le plan actuel ?
            if (!confirm("Cela va remplacer les tables actuelles. Continuer ?")) return;

            // Reset tables
            physicalTables = [];

            // Créer tables
            // On met 2 paires par table physique par défaut, ou 1
            const boardsPerTable = parseInt(document.getElementById('boardsPerTable').value) || 2;
            let currentTable = null;

            pairings.forEach((p, i) => {
                const boardNum = i + 1;

                // Nouvelle table physique si nécessaire
                if (i % boardsPerTable === 0) {
                    currentTable = {
                        id: Date.now() + i,
                        x: 50 + (Math.floor(i / boardsPerTable) % 5) * 200, // Position simple grille
                        y: 50 + Math.floor(i / (boardsPerTable * 5)) * 150,
                        rotation: 0,
                        boards: []
                    };
                    physicalTables.push(currentTable);
                }

                // Créer échiquier
                const board = {
                    boardNumber: boardNum,
                    players: {
                        white: {
                            id: p.white.id,  // IMPORTANT: Store ID for history tracking
                            firstName: p.white.firstName,
                            lastName: p.white.lastName,
                            name: (p.white.lastName + ' ' + p.white.firstName).trim(),
                            elo: p.white.eloSlow,
                            comment: ""
                        },
                        black: p.black ? {
                            id: p.black.id,  // IMPORTANT: Store ID for history tracking
                            firstName: p.black.firstName,
                            lastName: p.black.lastName,
                            name: (p.black.lastName + ' ' + p.black.firstName).trim(),
                            elo: p.black.eloSlow,
                            comment: ""
                        } : null
                    },
                    score: { white: '', black: '' },
                    flipped: false
                };

                // Auto-assign score for bye games
                if (p.isBye || !p.black) {
                    board.score = { white: '1', black: '' };
                    board.isBye = true;
                }

                currentTable.boards.push(board);
            });

            renderAllTables();
            updateStats();
            saveHistoryState();
        }
        // --- UI Integration (Global Scope) ---
        async function generatePairingsUI() {
            const type = document.getElementById('pairingSystemSelect').value;
            const msg = document.getElementById('pairingMsg');

            // 1. Déterminer le numéro de la prochaine ronde
            const existingRounds = Object.keys(roundsStore).filter(k => k.startsWith('ronde')).sort();

            // Check if we should start at round 1 or continue
            let nextRoundNum = 1;
            if (existingRounds.length > 0) {
                // Check if the last round has pairings
                const lastRoundKey = existingRounds[existingRounds.length - 1];
                const lastRound = roundsStore[lastRoundKey];
                const hasPairings = lastRound && lastRound.physicalTables && lastRound.physicalTables.length > 0;

                if (hasPairings) {
                    // Last round has pairings, create next round
                    nextRoundNum = existingRounds.length + 1;
                } else {
                    // Last round is empty, use it
                    nextRoundNum = existingRounds.length;
                }
            }

            msg.textContent = "Vérification des résultats...";

            try {
                // 2. Validation des résultats de la ronde PRÉCÉDENTE (si on crée R2+)
                if (nextRoundNum > 1) {
                    const previousRoundKey = `ronde${nextRoundNum - 1}`;
                    const missingResults = validatePreviousRoundResults(previousRoundKey);
                    if (missingResults.length > 0) {
                        throw new Error(`Résultats manquants pour la ronde ${nextRoundNum - 1}\n(${missingResults.length} parties non terminées).`);
                    }
                }

                // 3. Créer la nouvelle ronde SI elle n'existe pas encore
                const targetRoundKey = `ronde${nextRoundNum}`;
                if (!roundsStore[targetRoundKey]) {
                    msg.textContent = `Création de la ronde ${nextRoundNum}...`;
                    saveCurrentStateToStore();
                    roundsStore[targetRoundKey] = {
                        physicalTables: [],
                        rooms: [],
                        nextPhysicalTableId: 1,
                        nextRoomId: 1,
                        nextBoardNumber: 1,
                        historyStack: [],
                        redoStack: []
                    };
                    updateRoundSelector();
                } else {
                    // Round exists, check if it has pairings
                    const existingRound = roundsStore[targetRoundKey];
                    const hasPairings = existingRound && existingRound.physicalTables && existingRound.physicalTables.length > 0;

                    if (hasPairings) {
                        if (!confirm(`La ronde ${nextRoundNum} existe déjà. Voulez-vous régénérer les appariements ?\n(Cela effacera les tables actuelles de cette ronde)`)) {
                            msg.textContent = "Annulé.";
                            return;
                        }
                    }
                }

                msg.textContent = `Génération des appariements R${nextRoundNum}...`;

                // 4. Récupérer joueurs
                const players = RegDB.getAll();
                if (players.length === 0) throw new Error("Aucun joueur inscrit !");

                // 5. Récupérer historique
                const history = buildHistoryFromStore();

                // 6. Générer
                const service = new PairingService();
                service.setHistory(history);
                const pairings = await service.generate(players, nextRoundNum, type);

                // 7. Switch to the target round before applying pairings
                currentRoundKey = targetRoundKey;
                loadStateFromStore(targetRoundKey);

                // 8. Appliquer au plan (Créer tables)
                applyPairingsToPlan(pairings);

                msg.textContent = `✅ Ronde ${nextRoundNum} générée (${pairings.length} tables) !`;
                msg.style.color = "green";

            } catch (e) {
                console.error(e);
                msg.textContent = "❌ " + e.message;
                msg.style.color = "red";
                alert(e.message);
            }
        }

        function validatePreviousRoundResults(roundKey) {
            const round = roundsStore[roundKey];
            if (!round) return []; // Pas de ronde précédente ?

            const missing = [];
            round.physicalTables.forEach(t => {
                t.boards.forEach(b => {
                    // Ignorer les tables vides ou bye
                    if (b.players && b.players.white && b.players.black) {
                        // Vérifier si le score est défini
                        if (!b.score || (b.score.white === '' && b.score.black === '')) {
                            missing.push(`Table ${b.boardNumber}`);
                        }
                    }
                });
            });
            return missing;
        }

        // --- RESULTS VIEW (GRID OR BRACKET) ---
        function showResultsView() {
            const type = document.getElementById('pairingSystemSelect').value;
            if (type === 'cup') {
                showCupBracket();
            } else {
                showAmericanGrid();
            }
        }

        // --- AMERICAN GRID (GRILLE AMÉRICAINE) ---
        function showAmericanGrid() {
            // Close registration overlay if it's open
            closeRegistrationOverlay();

            const modal = document.getElementById('americanGridModal');
            const table = document.getElementById('americanGridTable');
            const players = RegDB.getAll();
            const history = buildHistoryFromStore();

            // FIX: Initialize service with history
            const service = new PairingService();
            service.setHistory(history);

            // 1. Calculer les stats complètes pour chaque joueur
            const pStats = players.map(p => {
                const stats = service._getPlayerStats(p.id);

                // Calculer Buchholz (Somme des scores des adversaires)
                // Cut 1: On retire le score le plus faible des adversaires
                let oppScores = [];
                stats.opponents.forEach(oppId => {
                    const opp = players.find(x => x.id === oppId);
                    if (opp) {
                        const oppStats = service._getPlayerStats(opp.id);
                        oppScores.push(oppStats.score);
                    }
                });
                oppScores.sort((a, b) => a - b);
                if (oppScores.length > 1) oppScores.shift(); // Remove lowest
                const buchholz = oppScores.reduce((a, b) => a + b, 0);

                // Calculer Performance (Simplifiée: Moyenne Elo Adv + Diff Score)
                // Formule FIDE simplifiée: Ra + dp
                let totalOppElo = 0;
                let ratedGames = 0;
                stats.opponents.forEach(oppId => {
                    const opp = players.find(x => x.id === oppId);
                    if (opp && opp.eloSlow) {
                        totalOppElo += parseInt(opp.eloSlow);
                        ratedGames++;
                    }
                });
                let perf = 0;
                if (ratedGames > 0) {
                    const ra = totalOppElo / ratedGames;
                    const percentage = stats.score / ratedGames;
                    // Table de conversion simplifiée (dp)
                    let dp = 0;
                    if (percentage >= 1.0) dp = 800;
                    else if (percentage >= 0.9) dp = 400; // Approx
                    else if (percentage >= 0.8) dp = 240;
                    else if (percentage >= 0.7) dp = 150;
                    else if (percentage >= 0.6) dp = 70;
                    else if (percentage >= 0.5) dp = 0;
                    else if (percentage >= 0.4) dp = -70;
                    else if (percentage >= 0.3) dp = -150;
                    else if (percentage >= 0.2) dp = -240;
                    else if (percentage >= 0.1) dp = -400;
                    else dp = -800;

                    perf = Math.round(ra + dp);
                }

                // Calculer Cumulatif (Somme des scores progressifs)
                // Nécessite de rejouer l'historique ronde par ronde
                let cumulative = 0;
                // TODO: Implémenter cumulatif exact

                return { ...p, ...stats, buchholz, perf, cumulative };
            });

            // 2. Trier (Points > Buchholz > Perf > Elo)
            pStats.sort((a, b) => {
                if (b.score !== a.score) return b.score - a.score;
                if (b.buchholz !== a.buchholz) return b.buchholz - a.buchholz;
                if (b.perf !== a.perf) return b.perf - a.perf;
                return (b.eloSlow || 0) - (a.eloSlow || 0);
            });

            // 3. Construire la table
            const numRounds = Object.keys(roundsStore).filter(k => k.startsWith('ronde')).length;
            let html = `<thead>
                            <tr>
                                <th>Pl</th>
                                <th>Nom</th>
                                <th>Elo</th>
                                <th>Cat.</th>
                                <th>Fed</th>
                                <th>Ligue</th>`;
            for (let i = 1; i <= numRounds; i++) html += `<th>R${i}</th>`;
            html += `<th>Pts</th>
                                <th>Buch</th>
                                <th>Perf</th>
                            </tr>
                        </thead>
                        <tbody>`;

            pStats.forEach((p, index) => {
                html += `<tr onmouseover="showGridTooltip(event, '${p.id}')" onmouseout="hideGridTooltip()">
                                `;
                html += `<td>${index + 1}</td>`;
                html += `<td style="text-align:left; font-weight:bold;">${p.lastName} ${p.firstName}
                                </td>`;
                html += `<td>${p.eloSlow || ''}</td>`;
                html += `<td>${p.category || ''}</td>`; // Catégorie (ex: SenM)
                html += `<td>${p.federation || ''}</td>`; // Fed
                html += `<td>${p.league || ''}</td>`; // Ligue

                // Rounds cells
                for (let r = 1; r <= numRounds; r++) {
                    const roundKey = `ronde${r}`; const
                        roundData = roundsStore[roundKey]; let cellContent = ''; let cellClass = ''; if
                        (roundData) {
                        roundData.physicalTables.forEach(t => {
                            t.boards.forEach(b => {
                                if (b.players) {
                                    let myColor = null;
                                    let opp = null;
                                    let result = null;

                                    if (b.players.white && (b.players.white.id === p.id || b.players.white.name ===
                                        p.lastName + ' ' + p.firstName)) {
                                        myColor = 'w';
                                        opp = b.players.black;
                                        if (b.score.white === '1') result = 'W';
                                        else if (b.score.white === '0') result = 'L';
                                        else if (b.score.white === '1/2') result = 'D';
                                    } else if (b.players.black && (b.players.black.id === p.id || b.players.black.name
                                        === p.lastName + ' ' + p.firstName)) {
                                        myColor = 'b';
                                        opp = b.players.white;
                                        if (b.score.black === '1') result = 'W';
                                        else if (b.score.black === '0') result = 'L';
                                        else if (b.score.black === '1/2') result = 'D';
                                    }

                                    if (myColor) {
                                        if (opp) {
                                            const oppRank = pStats.findIndex(x => x.id === opp.id || (x.lastName + ' ' +
                                                x.firstName) === opp.name) + 1;
                                            // Format: + 23N (Gagne contre 23 avec Noirs)
                                            const sign = result === 'W' ? '+' : (result === 'L' ? '-' : '=');
                                            const colorCode = myColor === 'w' ? 'B' : 'N';
                                            cellContent = `${sign} ${oppRank}${colorCode}`;

                                            if (result === 'W') cellClass = 'grid-cell-win';
                                            else if (result === 'L') cellClass = 'grid-cell-loss';
                                            else if (result === 'D') cellClass = 'grid-cell-draw';
                                        } else {
                                            cellContent = 'BYE';
                                            cellClass = 'grid-cell-win';
                                        }
                                    }
                                }
                            });
                        });
                    }
                    html += `<td class="${cellClass}">${cellContent}</td>`;
                }

                html += `<td><strong>${p.score}</strong></td>`;
                html += `<td>${p.buchholz}</td>`;
                html += `<td>${p.perf}</td>`;
                html += `<td>${p.cumulative || ''}</td>`; // TODO: Implement Cumulative
                html += '</tr>';
            });
            html += '</tbody>';

            table.innerHTML = html;
            modal.style.display = 'flex';
        }

        // Export American Grid to CSV
        function exportAmericanGridCSV() {
            const players = RegDB.getAll();
            const history = buildHistoryFromStore();
            const service = new PairingService();
            service.setHistory(history);

            // Calculate stats for each player
            const pStats = players.map(p => {
                const stats = service._getPlayerStats(p.id);

                // Calculate Buchholz (sum of opponents' scores, cut-1)
                let oppScores = [];
                stats.opponents.forEach(oppId => {
                    const opp = players.find(x => x.id === oppId);
                    if (opp) {
                        const oppStats = service._getPlayerStats(opp.id);
                        oppScores.push(oppStats.score);
                    }
                });
                oppScores.sort((a, b) => a - b);
                if (oppScores.length > 1) oppScores.shift(); // Remove lowest
                const buchholz = oppScores.reduce((a, b) => a + b, 0);

                // Calculate Sonneborn-Berger (sum of defeated opponents' scores + half of drawn opponents' scores)
                let sonnebornBerger = 0;
                history.forEach(match => {
                    if (match.white === p.id) {
                        const opp = players.find(x => x.id === match.black);
                        if (opp) {
                            const oppStats = service._getPlayerStats(opp.id);
                            if (match.result === '1-0') sonnebornBerger += oppStats.score;
                            else if (match.result === '1/2-1/2') sonnebornBerger += oppStats.score / 2;
                        }
                    } else if (match.black === p.id) {
                        const opp = players.find(x => x.id === match.white);
                        if (opp) {
                            const oppStats = service._getPlayerStats(opp.id);
                            if (match.result === '0-1') sonnebornBerger += oppStats.score;
                            else if (match.result === '1/2-1/2') sonnebornBerger += oppStats.score / 2;
                        }
                    }
                });

                return { ...p, ...stats, buchholz, sonnebornBerger };
            });

            // Sort by Points > Buchholz > Sonneborn-Berger > Elo
            pStats.sort((a, b) => {
                if (b.score !== a.score) return b.score - a.score;
                if (b.buchholz !== a.buchholz) return b.buchholz - a.buchholz;
                if (b.sonnebornBerger !== a.sonnebornBerger) return b.sonnebornBerger - a.sonnebornBerger;
                return (b.eloSlow || 0) - (a.eloSlow || 0);
            });

            // Generate CSV
            let csv = 'Rang,Nom,Prénom,Points,Buchholz,Sonneborn-Berger,Elo\n';
            pStats.forEach((p, index) => {
                const rank = index + 1;
                const lastName = (p.lastName || '').replace(/,/g, ' ');
                const firstName = (p.firstName || '').replace(/,/g, ' ');
                const points = p.score || 0;
                const buchholz = p.buchholz.toFixed(1);
                const sb = p.sonnebornBerger.toFixed(1);
                const elo = p.eloSlow || '';
                csv += `${rank},${lastName},${firstName},${points},${buchholz},${sb},${elo}\n`;
            });

            // Download CSV
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', 'grille_americaine.csv');
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function showGridTooltip(e, playerId) {
            const tooltip = document.getElementById('gridHoverTooltip');
            const players = RegDB.getAll();
            const p = players.find(x => x.id === playerId);
            if (!p) return;

            // Calculate stats again or pass them? simpler to recalc for tooltip
            const service = new PairingService();
            service.setHistory(buildHistoryFromStore());
            const stats = service._getPlayerStats(p.id);

            let html = `
                        <div class="tooltip-header">
                            <span>${p.lastName} ${p.firstName}</span>
                            <span>${p.eloSlow || ''} F</span>
                        </div>
                        <table class="tooltip-table">
                            <thead>
                                <tr>
                                    <th>Rd</th>
                                    <th>C</th>
                                    <th>Res</th>
                                    <th>Adversaire</th>
                                    <th>Elo</th>
                                </tr>
                            </thead>
                            <tbody>
                                `;

            const numRounds = Object.keys(roundsStore).filter(k => k.startsWith('ronde')).length;
            for (let r = 1; r <= numRounds; r++) {
                const roundKey = `ronde${r}`; const
                    roundData = roundsStore[roundKey]; if (roundData) {
                        roundData.physicalTables.forEach(t => {
                            t.boards.forEach(b => {
                                if (b.players) {
                                    let myColor = null;
                                    let opp = null;
                                    let result = null;

                                    if (b.players.white && (b.players.white.id === p.id || b.players.white.name ===
                                        p.lastName + ' ' + p.firstName)) {
                                        myColor = 'B';
                                        opp = b.players.black;
                                        if (b.score.white === '1') result = '1';
                                        else if (b.score.white === '0') result = '0';
                                        else if (b.score.white === '1/2') result = '½';
                                    } else if (b.players.black && (b.players.black.id === p.id || b.players.black.name
                                        === p.lastName + ' ' + p.firstName)) {
                                        myColor = 'N';
                                        opp = b.players.white;
                                        if (b.score.black === '1') result = '1';
                                        else if (b.score.black === '0') result = '0';
                                        else if (b.score.black === '1/2') result = '½';
                                    }

                                    if (myColor) {
                                        const oppName = opp ? `${opp.name}` : "BYE";
                                        const oppElo = opp ? (opp.elo || '') : '';
                                        html += `
                                    <tr>
                                        <td>${r}</td>
                                        <td>${myColor}</td>
                                        <td><strong>${result || '?'}</strong></td>
                                        <td style="text-align:left;">${oppName}</td>
                                        <td>${oppElo}</td>
                                    </tr>
                                    `;
                                    }
                                }
                            });
                        });
                    }
            }

            html += `</tbody>
                        </table>`;

            tooltip.innerHTML = html;
            tooltip.style.display = 'block';

            // Positionnement intelligent
            const tooltipRect = tooltip.getBoundingClientRect();
            let top = e.clientY + 15;
            let left = e.clientX + 15;

            // Si ça dépasse en bas
            if (top + tooltipRect.height > window.innerHeight) {
                top = e.clientY - tooltipRect.height - 15;
            }
            // Si ça dépasse à droite
            if (left + tooltipRect.width > window.innerWidth) {
                left = e.clientX - tooltipRect.width - 15;
            }

            tooltip.style.top = top + 'px';
            tooltip.style.left = left + 'px';
        }

        function hideGridTooltip() {
            document.getElementById('gridHoverTooltip').style.display = 'none';
        }

        // --- CUP BRACKET (TABLEAU COUPE) ---
        function showCupBracket() {
            // Close registration overlay if it's open
            closeRegistrationOverlay();

            const modal = document.getElementById('cupBracketModal');
            const container = document.getElementById('cupBracketContainer');

            // Build bracket from history
            const history = buildHistoryFromStore();
            const players = RegDB.getAll();

            // Group matches by round
            const roundMatches = {};
            history.forEach(match => {
                if (!roundMatches[match.round]) roundMatches[match.round] = [];
                roundMatches[match.round].push(match);
            });

            let html = '<div style="padding: 20px; overflow-x: auto;">';
            html += '<div style="display: flex; gap: 40px; min-width: fit-content;">';

            const rounds = Object.keys(roundMatches).sort((a, b) => a - b);
            rounds.forEach(round => {
                html += `<div style="flex: 1; min-width: 250px;">`;
                html += `<h3 style="text-align: center; margin-bottom: 20px;">Ronde ${round}</h3>`;

                roundMatches[round].forEach(match => {
                    const whitePlayer = players.find(p => p.id === match.white) || {
                        lastName:
                            'Inconnu', firstName: ''
                    };
                    const blackPlayer = players.find(p => p.id === match.black) || {
                        lastName:
                            'Inconnu', firstName: ''
                    };

                    const whiteWon = match.result === '1-0';
                    const blackWon = match.result === '0-1';
                    const draw = match.result === '0.5-0.5';

                    html += `<div
                                        style="background: white; border: 1px solid #ddd; border-radius: 8px; padding: 12px; margin-bottom: 15px;">
                                        `;
                    html += `<div
                                            style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: ${whiteWon ? '#d4edda' : '#f8f9fa'}; border-radius: 4px; margin-bottom: 8px;">
                                            `;
                    html += `<span
                                                style="font-weight: ${whiteWon ? 'bold' : 'normal'};">${whitePlayer.lastName}
                                                ${whitePlayer.firstName}</span>`;
                    html += `<span style="font-weight: bold;">${match.result ?
                        match.result.split('-')[0] : '-'}</span>`;
                    html += `</div>`;
                    html += `<div
                                            style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: ${blackWon ? '#d4edda' : '#f8f9fa'}; border-radius: 4px;">
                                            `;
                    html += `<span
                                                style="font-weight: ${blackWon ? 'bold' : 'normal'};">${blackPlayer.lastName}
                                                ${blackPlayer.firstName}</span>`;
                    html += `<span style="font-weight: bold;">${match.result ?
                        match.result.split('-')[1] : '-'}</span>`;
                    html += `</div>`;
                    html += `</div>`;
                });

                html += `</div>`;
            });

            html += `</div>
                        </div>`;

            if (rounds.length === 0) {
                html = `<div style="text-align:center; padding: 50px;">
                            <h3>Aucune partie jouée</h3>
                            <p>Générez des appariements et encodez des résultats pour voir le tableau.</p>
                        </div>`;
            }

            container.innerHTML = html;
            modal.style.display = 'flex';
        }

        // Afficher le bouton Coupe seulement si le mode est Coupe
        document.getElementById('pairingSystemSelect').addEventListener('change', function () {
            const btn = document.getElementById('btnShowCupBracket');
            if (this.value === 'cup') btn.style.display = 'block';
            else btn.style.display = 'none';
        });
        // --- RESULTS MANAGEMENT INTERFACE ---
        function showResultsManagement() {
            const modal = document.getElementById('resultsManagementModal');
            modal.style.display = 'flex';
            showResultsTab('input');
        }

        function showResultsTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.results-tab-content').forEach(tab => {
                tab.style.display = 'none';
            });
            document.querySelectorAll('.results-tab').forEach(btn => {
                btn.classList.remove('active');
                btn.style.background = 'transparent';
                btn.style.color = '#333';
                btn.style.borderBottom = 'none';
            });

            // Show selected tab
            document.getElementById(`results-${tabName}-tab`).style.display = 'block';

            // Find and highlight the correct button
            const buttons = document.querySelectorAll('.results-tab');
            buttons.forEach((btn, index) => {
                const btnTabName = ['input', 'history', 'validation'][index];
                if (btnTabName === tabName) {
                    btn.classList.add('active');
                    btn.style.background = 'white';
                    btn.style.color = '#667eea';
                    btn.style.borderBottom = '3px solid #667eea';
                }
            });

            // Load content
            if (tabName === 'input') loadResultsInput();
            else if (tabName === 'history') loadResultsHistory();
            else if (tabName === 'validation') loadResultsValidation();
        }

        function loadResultsInput() {
            const container = document.getElementById('resultsInputContainer');
            const round = roundsStore[currentRoundKey];

            if (!round || !round.physicalTables || round.physicalTables.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 40px; color: #999;">Aucune partie à saisir pour cette ronde</div>';
                return;
            }

            // Update round number
            const roundNum = parseInt(currentRoundKey.replace('ronde', ''));
            document.getElementById('resultsInputRound').textContent = roundNum;

            let html = '<div style="display: grid; gap: 15px;">';

            round.physicalTables.forEach(table => {
                table.boards.forEach(board => {
                    if (!board.players || !board.players.white) return;

                    const isBye = !board.players.black;
                    const boardNum = board.boardNumber;

                    html += `<div style="background: white; border: 2px solid #e0e0e0; border-radius: 10px; padding: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">`;
                    html += `<div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px;">`;

                    // Board number
                    html += `<div style="font-weight: bold; font-size: 1.1em; min-width: 80px;">Échiquier ${boardNum}</div>`;

                    if (isBye) {
                        // Bye game
                        html += `<div style="flex: 2; display: flex; align-items: center; gap: 10px;">`;
                        html += `<span style="font-weight: 600;">${board.players.white.name}</span>`;
                        html += `<span style="background: #ffc107; color: white; padding: 4px 12px; border-radius: 15px; font-size: 0.9em;">EXEMPT</span>`;
                        html += `</div>`;
                        html += `<div style="font-weight: bold; color: #28a745;">1 point (automatique)</div>`;
                    } else {
                        // Normal game
                        html += `<div style="flex: 2;">`;
                        html += `<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 5px;">`;
                        html += `<span style="display: inline-block; width: 20px; height: 20px; background: white; border: 2px solid #333; border-radius: 50%;"></span>`;
                        html += `<span style="font-weight: 600;">${board.players.white.name}</span>`;
                        html += `<span style="color: #999;">(${board.players.white.elo || '?'})</span>`;
                        html += `</div>`;
                        html += `<div style="display: flex; align-items: center; gap: 10px;">`;
                        html += `<span style="display: inline-block; width: 20px; height: 20px; background: #333; border: 2px solid #333; border-radius: 50%;"></span>`;
                        html += `<span style="font-weight: 600;">${board.players.black.name}</span>`;
                        html += `<span style="color: #999;">(${board.players.black.elo || '?'})</span>`;
                        html += `</div>`;
                        html += `</div>`;

                        // Result buttons
                        const currentResult = board.score ? (board.score.white === '1' ? '1-0' : board.score.black === '1' ? '0-1' : board.score.white === '1/2' ? '1/2-1/2' : '') : '';
                        html += `<div style="display: flex; gap: 8px;">`;
                        html += `<button class="reg-btn ${currentResult === '1-0' ? 'reg-btn-success' : 'reg-btn-secondary'}" onclick="setResult(${boardNum}, '1-0')" style="padding: 8px 16px;">1-0</button>`;
                        html += `<button class="reg-btn ${currentResult === '1/2-1/2' ? 'reg-btn-success' : 'reg-btn-secondary'}" onclick="setResult(${boardNum}, '1/2-1/2')" style="padding: 8px 16px;">½-½</button>`;
                        html += `<button class="reg-btn ${currentResult === '0-1' ? 'reg-btn-success' : 'reg-btn-secondary'}" onclick="setResult(${boardNum}, '0-1')" style="padding: 8px 16px;">0-1</button>`;
                        html += `</div>`;
                    }

                    html += `</div></div>`;
                });
            });

            html += '</div>';
            container.innerHTML = html;
        }

        function setResult(boardNum, result) {
            const round = roundsStore[currentRoundKey];
            if (!round) return;

            // Find the board
            for (const table of round.physicalTables) {
                for (const board of table.boards) {
                    if (board.boardNumber === boardNum) {
                        if (result === '1-0') {
                            board.score = { white: '1', black: '0' };
                        } else if (result === '0-1') {
                            board.score = { white: '0', black: '1' };
                        } else if (result === '1/2-1/2') {
                            board.score = { white: '1/2', black: '1/2' };
                        }
                        saveHistoryState();
                        loadResultsInput(); // Refresh display
                        return;
                    }
                }
            }
        }

        function saveAllResults() {
            saveHistoryState();
            alert('✅ Tous les résultats ont été enregistrés !');
        }

        function goToNextRound() {
            // Validate current round
            const missing = validatePreviousRoundResults(currentRoundKey);
            if (missing.length > 0) {
                if (!confirm(`Attention: ${missing.length} résultat(s) manquant(s):\n${missing.join(', ')}\n\nContinuer quand même ?`)) {
                    return;
                }
            }

            // Create next round
            const roundNum = parseInt(currentRoundKey.replace('ronde', ''));
            const nextRoundKey = `ronde${roundNum + 1}`;

            if (!roundsStore[nextRoundKey]) {
                alert('Utilisez le bouton "Générer Appariements" pour créer la ronde suivante.');
                return;
            }

            currentRoundKey = nextRoundKey;
            loadStateFromStore(nextRoundKey);
            loadResultsInput();
        }

        function loadResultsHistory() {
            const container = document.getElementById('resultsHistoryContainer');
            const history = buildHistoryFromStore();

            if (history.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 40px; color: #999;">Aucun résultat enregistré</div>';
                return;
            }

            // Group by round
            const byRound = {};
            history.forEach(match => {
                if (!byRound[match.round]) byRound[match.round] = [];
                byRound[match.round].push(match);
            });

            let html = '';
            Object.keys(byRound).sort((a, b) => b - a).forEach(round => {
                html += `<div style="margin-bottom: 30px;">`;
                html += `<h3 style="background: linear-gradient(135deg, #667eea, #764ba2); color: white; padding: 15px; border-radius: 8px; margin-bottom: 15px;">Ronde ${round}</h3>`;
                html += `<div style="display: grid; gap: 10px;">`;

                byRound[round].forEach((match, idx) => {
                    html += `<div style="background: white; border: 1px solid #e0e0e0; border-radius: 8px; padding: 15px; display: flex; justify-content: space-between; align-items: center;">`;

                    if (match.isBye) {
                        html += `<div><strong>${match.white}</strong> <span style="background: #ffc107; color: white; padding: 2px 8px; border-radius: 10px; font-size: 0.85em; margin-left: 10px;">EXEMPT</span></div>`;
                        html += `<div style="font-weight: bold; color: #28a745;">1-0</div>`;
                    } else {
                        html += `<div><strong>${match.white}</strong> vs <strong>${match.black}</strong></div>`;
                        html += `<div style="font-weight: bold; color: ${match.result === '1-0' ? '#28a745' : match.result === '0-1' ? '#dc3545' : '#ffc107'};">${match.result || 'En cours'}</div>`;
                    }

                    html += `</div>`;
                });

                html += `</div></div>`;
            });

            container.innerHTML = html;
        }

        function loadResultsValidation() {
            const container = document.getElementById('resultsValidationContainer');
            const players = RegDB.getAll();
            const history = buildHistoryFromStore();

            let errors = [];
            let warnings = [];

            // Check for missing results
            Object.keys(roundsStore).forEach(roundKey => {
                const missing = validatePreviousRoundResults(roundKey);
                if (missing.length > 0) {
                    errors.push(`Ronde ${roundKey.replace('ronde', '')}: ${missing.length} résultat(s) manquant(s) (${missing.join(', ')})`);
                }
            });

            // Check for duplicate pairings
            const pairings = new Set();
            history.forEach(match => {
                if (!match.isBye) {
                    const pair = [match.white, match.black].sort().join('-');
                    if (pairings.has(pair)) {
                        warnings.push(`Paire répétée: ${match.white} vs ${match.black}`);
                    }
                    pairings.add(pair);
                }
            });

            let html = '<div style="max-width: 800px; margin: 0 auto;">';

            if (errors.length === 0 && warnings.length === 0) {
                html += `<div style="background: #d4edda; border-left: 4px solid #28a745; color: #155724; padding: 20px; border-radius: 8px; text-align: center;">`;
                html += `<h3 style="margin: 0 0 10px 0;">✅ Validation réussie</h3>`;
                html += `<p style="margin: 0;">Tous les résultats sont correctement enregistrés.</p>`;
                html += `</div>`;
            } else {
                if (errors.length > 0) {
                    html += `<div style="background: #f8d7da; border-left: 4px solid #dc3545; color: #721c24; padding: 20px; border-radius: 8px; margin-bottom: 20px;">`;
                    html += `<h3 style="margin: 0 0 10px 0;">❌ Erreurs (${errors.length})</h3>`;
                    html += `<ul style="margin: 0; padding-left: 20px;">`;
                    errors.forEach(err => html += `<li>${err}</li>`);
                    html += `</ul></div>`;
                }

                if (warnings.length > 0) {
                    html += `<div style="background: #fff3cd; border-left: 4px solid #ffc107; color: #856404; padding: 20px; border-radius: 8px;">`;
                    html += `<h3 style="margin: 0 0 10px 0;">⚠️ Avertissements (${warnings.length})</h3>`;
                    html += `<ul style="margin: 0; padding-left: 20px;">`;
                    warnings.forEach(warn => html += `<li>${warn}</li>`);
                    html += `</ul></div>`;
                }
            }

            html += '</div>';
            container.innerHTML = html;
        }

        // Make function globally accessible
        window.showResultsManagement = showResultsManagement;

    </script>
</body>

</html>